;	ELF75C.3
	.TITLE	NNCP2 -- NCP FLOW CONTROL PROCEDURES
	.NLIST	ME
	$CNFIG
	$DFREG
	$DFCT
	$DFCCT
	$DFSCC			; SOCKET CONDITION CODES
	$DFHTE
	$DFIFN
	$NPARM
	$NSDEF			; NCP STATE DEFINITIONS
	

	.GLOBL	$NSIOC,$NCXS
	.GLOBL	$RCFLO,$SNFLO
	.GLOBL	$RLSCT
	.GLOBL	$MQFMT,$HIENQ,$ALOCW,$ALOCB
	.GLOBL	$DISMQ,$ENQ,$DEQ,$HHENQ,$HIENQ
	.GLOBL	$INCAL,$DECAL,$SNDAL
	.GLOBL	$ETCST
	.GLOBL	$IHQP
	.IF EQ	N.XNCP-1
	.GLOBL	$FXCTB
	.ENDC


HHMBS	=	4		; OFFSET TO HOST-HOST BYTE SIZE
HHMBC	=	6		; OFFSET TO HOST-HOST BYTE COUNT
SDMBS	=	11		; OFFSET TO BEGIN OF TEXT IN HH MSG
SDP0L	=	128.		; LENGTH OF BUFFER USED IN SND MSGS
SNMSIZ	=	SDP0L-SDMBS-4	; NUMBER OF BYTES ALLOWED FOR TEXT

RCMTHR	=	256.		; MSG CNT THRESHOLD FOR SENDING AN ALLOCATE
RCMINM	=	2048.		; 'TARGET' MESSAGE CNT ALLOC
RCMINB	=	128.*8.		; MIN DESIRED BIT CNT ALLOC
ALLEAD	=	0		; BITS ALLOCATION LEAD VALUE
ALTHRS	=	24.*8.		; ALLOCATE THRESHOLD

OPNCXS	=	4		; NCP OP FOR CHANGE IN STATE
OPNSIO	=	3		; OP-CODE INDICATING SIO COMPL.
OPNNUL	=	6		; NCP OP-CODE FOR NULL SIGNAL.
	.PAGE
	.SBTTL	$RCFLO -- RECEIVE FLOW CONTROL

;			ASSUME R2 CONTAINS CT ADDRESS

$RCFLO:	MOVB	CTSTAT(R2),R3	; MOVE CONNECTION STATUS TO R3
	BMI	RCFRT1		; BRANCH IF IPP I/O IN PROGRESS
	.IF NE	N.XNCP
	BITB	#100,R3		; IS THIS AN EXPERIMENTAL CONNECTION?
	BNE	RCX		;    .. YES - BYPASS FLOW CONTROL.
	.ENDC
	BIC	#177760,R3	; MASK ALL BUT CONNECTION STATE
	CMP	#STDRAI,R3	; ELSE, ARE WE IN DRAIN-WAIT STATE?
	BEQ	RCX		; YES, NO MORE ALLOCATES, PLEASE!
	$PUSH	R2		; SAVE CT WHILE GETTING BYTES READY
	MOV	CTIPP(R2),R0	; IPP DEV NAME
	MOV	CTIPP+2(R2),R1	; DEV NUMBER (ADDRESS)
	CLR	R2		; REQUEST NR BYTES OUTSTANDING
	$DEVC	R0,R1,R2,R3	; DEVICE CHARACTERISTICS
	$POP	R2		; RESTORE CT POINTER
	TST	R3		; ANY BYTES OUTSTANDING ?
	BNE	RCCALL		; YES, TEST ALLOCATION
	JSR	PC,NCPCX2	; ELSE JUST RE-INIT TEST OF IPP
RCFRT1:	RTS	PC

RCCALL:	MOV	R3,R4		; BYTES READY-TO-GO TO R4
	MOV	#RCMINM,R0	; OBTAIN MIN DESIRED MSG ALL
	SUB	CTMCT(R2),R0	; IS AN INCREASE NECESSARY?
	CMP	R0,#RCMINM-RCMTHR ; HAVE WE CROSSED THRESHOLD ?
	BGE	1$		; BRANCH IF SO
	CLR	R0		; ENSURE WE DON'T HAVE NEG NR
	TST	CTBCT(R2)	; ARE WE BELOW THRESHOLD?
	BNE	RCX		; NO, DON'T BOTHER WITH ALLOCATE
	CMP	CTBCT+2(R2),#ALTHRS ; CHECK THRESHOLD
	BHIS	RCX
1$:	CLR	R3		; SETUP TO OBTAIN BIT ALLOCATON
	ASL	R4		; AND DO FULL SHIFT LEFT 3
	ROL	R3
	ASL	R4
	ROL	R3
	ASL	R4
	ROL	R3		; R3,R4 NOW CONTAIN UPDATE ALLOC INFO
	ADD	#ALLEAD,R4	; ADVANCE TO LEAD VALUE (BUFFER FACTOR)
	ADC	R3
	SUB	CTBCT+2(R2),R4	; COMPUTE DIFFERENCE
	SBC	R3		; IN R3, R4 (REQUESTED - CURRENT)
	SUB	CTBCT(R2),R3	; AND USE THAT TO UPDATE ALLOC INFO
	BCC	5$		;  SEND ALL IF HAVE ENOUGH
	CLR	R3
	CLR	R4		; SET 0 ALLOC (BITS)
5$:	TST	R3
	BNE	3$
	TST	R4
	BEQ	RCX		; SKIP ALLOCATE IF PARAMS ARE 0
3$:
;				  R2 CONTAINS CT POINTER
	$PUSH	R2		; SAVE CT POINTER
	JSR	PC,$SNDAL	; SEND AN ALLOCATE
;				  NOTE THAT $SNDAL UPDATES ALLOCATION
;				  INFO IN CT.
	$POP	R2		; RESTORE CT POINTER
RCX:	$PUSH	R2		; SAVE CALLER CT POINTER
	ADD	#CTQ,R2		; ADVANCE POINTER TO CONNX QUEUE
	JSR	PC,$DEQ		; TRY TO FETCH AN ENTRY
	BEQ	RCVAB		; NONE AVAIL
	$POP	R2		; CT POINTER AGAIN
	MOV	R0,CTMQP(R2)	; SAVE MESSAGE QUEUE PTR
	MOV	-(R0),R1	; FETCH MESSAGE BASE
	.IF NE	N.XNCP
	BITB	#100,CTSTAT(R2)	; IS THIS AN EXPERIMENTAL CONNECTION?
	BNE	XINPUT		;    .. YES - DON'T MASSAGE THE DATA!
	.ENDC
	MOV	(R1)+,CTIBR(R2)	; SET NUMBER OF BYTES FOR IPP
	BR	RCSCON		; DOWN TO INITIATE IPP I/O
RCVAB:	$POP	R2		; RESTORE CT POINTER
	RTS	PC

	.IF NE	N.XNCP

;	    INPUT IS ON AN EXPERIMENTAL LINK;  TRANSFER ENTIRE
;	    BUFFER ACROSS IPP WITHOUT REFORMATTING DATA IN ANY WAY.

XINPUT:	MOV	-4(R0),R0		; PICK UP INPUT WORD COUNT.
	ASL	R0			; CONVERT TO BYTE COUNT,
	MOV	R0,CTIBR(R2)		; SAVE IT FOR IPP TRANSFER.
	BR	RCSCON			; SET BUFR ADDR & START IT.
	.ENDC
	.PAGE
	.SBTTL	$SNFL0 -- SEND FLOW CONTROL

;			THIS PROCEDURE IS ENTERED WHEN THE NCP
;			INPUT PROCESS DETECTS THAT A LOCAL PROCESS
;			HAS REQUESTED TRANSFER OF DATA ON A
;			CONNECTION.  "SEND FLOW CONTROL" DETERMINES
;			THE ABILITY OF THE REMOTE HOST TO RECEIVE DATA
;			(I.E., ITS BUFFERING STATUS.)

;				$SNFLO IS CALLED WHEN THE
;			NCP INPUT PROCESS RECEIVES A IMP-HOST
;			"RFNM" MESSAGE, INDICATING THAT A MESSAGE
;			WHICH WAS PREVIOUSLY TRANSMITTED WAS RECEIVED BY
;			THE DESTINATION HOST.  THE RFNM INDICATES
;			THAT ANOTHER MESSAGE MAY BE TRANSMITTED TO
;			THE DESTINATION HOST, AND ACKNOWLEDGES CORRECT
;			RECEPTION OF THE MESSAGE.
;			(NOTE THAT MESSAGES ARE SAVED UNTIL THE
;			RFNM IS RECEIVED, IN ORDER TO ALLOW
;			RE-TRANSMISSION IF A MESSAGE IS NOT
;			RECEIVED CORRECTLY.)

;				THIS PROCEDURE ALSO RECEIVES
;			CONTROL WHEN THE NCP INPUT PROCESS
;			RECEIVES A HOST-HOST PROTOCOL "ALLOCATE"
;			MESSAGE, INDICATING THAT BUFFER SPACE HAS
;			BEEN ALLOCATED AT THE REMOTE HOST. THUS,
;			THE FUNCTION OF $SNFLO IS THE SUPERVISION OF
;			DATA FLOW OVER SEND CONNECTIONS.

$SNFLO:	TSTB	CTSTAT(R2)	; TEST I/O IN PROGRESS TO IPP
	BMI	SNFRT1		; BRANCH IF SO
	MOV	CTIPP(R2),R0	; IPPNAME TO R0
	MOV	CTIPP+2(R2),R1	; UNIT NUMBER
	$PUSH	R2		; SAVE CT POINTER
	CLR	R2		; FUNCTION CODE
	$DEVC	R0,R1,R2,R3	; DEVICE CHARACTERISTICS
;				  R3 NOW HAS NUMBER OF BYTES
;				  PENDING ON IPP
	$POP	R2		; RESTORE CT POINTER
	TST	R3		; NUMBER BYTES NON-ZERO ??
	BNE	SNFACH		; DOWN TO CHECK ALLOCATION
;				;  ELSE ISSUE SIO (0)
	JSR	PC,NCPCX2	; INIT/CHECK BYTES REQ.
SNFRT1:	RTS	PC		; RETURN


;			HAVE BYTES TO TRANSFER, SEE IF ALLOCATION
;			EXISTS ON CONNECTION.

SNFACH:
	.IF NE	N.XNCP		; XNCP INCLUDED IN THIS SYSTEM
	BITB	#100,CTSTAT(R2)	; IS IT XNCP CONNECTION ?
	BNE	SNXBUF		; YES, JUST MOVE INTO XMIT BUFFER
	.ENDC
	TST	CTMCT(R2)	; MESSAGE COUNT ALLOCATION ??
	BEQ	SNFRT1		; RETURN, INSUFFICIENT MESSAGE COUNT
	TST	CTBCT(R2)	; NOW TEST BIT COUNT
	BEQ	1$		; CHECK LO ORDER WORD, HI ONE IS 0
4$:	MOV	#SNMSIZ,R0	; SET INPUT MESSAGE REQUEST SIZE MAX
	BR	2$		; DOWN TO SET BYTES REQ AND SIO (N)
1$:	MOV	CTBCT+2(R2),R0	; OBTAIN LOW ORDER 16 BITS BIT ALL
	BEQ	SNFRT1		; INSUFFICIENT
	CLC			; SETUP TO GET IN 8-BIT BYTES
	ROR	R0		; LOGICAL SHIFT RIGHT 3
	ASR	R0
	ASR	R0
	CMP	R0,#SNMSIZ	; GREATER THAN MAX SIZE ??
	BHI	4$		; YES, TRIM BYTE COUNT REQ
2$:	CMP	R0,R3		; TRIM TO NR BYTES REQUESTED
	BLOS	6$		; BRANCH IF L.T.
	MOV	R3,R0		; ELSE SET NR BYTES TO ALL
6$:	MOV	R0,CTIBR(R2)	; ELSE SET BYTES REQ FROM IPP
	$PUSH	R2		; SAVE CCT POINTER.
	ADD	#SDMBS+2,R0	; ACCOUNT FOR H-H MSG OVERHEAD
	MOV	R0,R2		; SETUP LENGTH OF MESSAGE FOR IMP XFER.
XOST:	JSR	PC,$ALOCB	; GET A BUFFER
	TST	R1		; DID WE SUCCEED?
	BEQ	SNFRQ9		; NO, DO A $REQ
	JSR	PC,$MQFMT	; FORMAT MQE
	$POP	R2		; RESTORE CT POINTER.
	MOV	R4,CTMQP(R2)	; SET MSG Q POINTER, WC = CT PTR
;				  NR WORDS IN MQE WILL BE SETUP WHEN
;				  IPP I/O COMPLETES
	.IF NE	N.XNCP

	BITB	#100,CTSTAT(R2)	; IS THIS AN EXPERIMENTAL CONNECTION?
	BEQ	9$		;    NO -- CHECK BYTE SIZE FOR NORMAL MSG.
	MOV	CTCCT(R2),R0	;    YES - FORMAT XNCP-SPECIFIC PART OF MQE.
	SUB	#12,R4		; POINT TO XNCP PARMS IN MQE.
	MOV	R0,(R4)+	; DATA WORD FOR SIGNAL = XCCT ADDR.
	MOVB	CTPCI(R2),(R4)+	; SET PROCESS ID FOR GONE-TO-IMP SIGNAL.
	MOVB	3(R0),(R4)	; USE OP CODE IN XCCT.
	BR	10$		; SKIP MUNDANE BYTE SIZE HASSLING.
9$:	.ENDC
	ADD	#SDMBS,R1	; BASE FOR MESSAGE XFER
	CMPB	#10,CTBSIZ(R2)	; IF BYTE-SIZE IS 8, THEN BYTE MODE
	BEQ	10$		; ELSE ITS WORD OR MUL-WORD MODE
	INC	R1		; THEN START AT WORD BOUNDARY
10$:
RCSCON:	MOV	R1,CTIADI(R2)	; SET ADDRX IN IPP
	MOV	R2,R0		; COMPUTE IORB ADDRX
	ADD	#CTIPP,R0	; FOR SIO
	BIS	#200,CTSTAT(R2)	; SET IPP I/O IN PROGRESS
	$SIO	R0		; INIT IPP (READ)
	RTS	PC		; AND RETURN FROM $SNFLO
	.IF NE	N.XNCP

SNXBUF:	MOV	R3,R0		; ALLOCATE BUFFER SIZED TO MATCH
	MOV	R0,CTIBR(R2)	;     AVAILABLE DATA.
	$PUSH	R2		; SAVE CT POINTER.
	MOV	R0,R2		; SET LENGTH PARM FOR MQE . . .
	ASR	R2		; ... CONVERT BYTE COUNT TO WORD COUNT,
	ADC	R2		; ... ROUNDING UP IF ODD.
	COM	R0		; ... LET IMP OUTPUT PROCESS FREE BUFFER
	BR	XOST		; JOIN NORMAL BUFFER HANDLING HERE.
	.ENDC
SNFRQ9:	$POP	R2		; RESTORE CT ADDRESS
	MOV	R2,R1		; CT ADDRESS TO R1
	ADD	#CTIPP,R1	; OBTAIN BASE OF IPP IORB
	$REQ	R0,CTIOPC(R2),R1 ; ISSUE $REQUEST ON BUFFER SEMAPHORE
	RTS	PC		; AND RETURN
	.PAGE
	.SBTTL	NCP -- CHANGE IN CONNECTION STATE

;			THIS PROCEDURE RECEIVES CONTROL
;			WHEN A CONNECTION IS ESTABLISHED
;			AND WHEN THERE IS SUFFICIENT ALLOCATION
;			FOR TRANSMISSION OF DATA ON A NETWORK
;			CONNECTION.  IT ASSUMES R1 POINTS
;			TO THE CONNECTION TABLE (PASSED AS
;			THE ARGUMENT BY THE $SIGNL-ING
;			PROCESS. (NOTE THAT WE CAN BE ENTERED
;			AT NCPCX2 UPON COMPLETION OF AN SIO,
;			IN ORDER TO WAIT FOR A NEW USER DATA-
;			TRANSFER REQUEST (THRU IPP).)


$NCXS:	MOV	R1,R2		;OBTAIN CT ADDRESS
NCPCX2:	MOVB	CTSTAT(R2),R3	;CONNX STATUS TO R3
	BIC	#177740,R3
	BEQ	NCPCXF		; IT GOT CLOSED, FREE THE CT
	CMPB	#STOPEN,R3	;IS CONNECTION IN OPEN STATE 
	BNE	NCNXC		; NO, UNKNOWN
NCZRD:	CLR	CTIBR(R2)	; SET UP FOR 0-LENGTH READ
	MOV	R2,R0		;GET IPP ADDR
	ADD	#CTIPP,R0
	BISB	#200,CTSTAT(R2) ; INDICATE I/O IN PROGRESS ON IPP
	$SIO	R0		;ISSUE SIO TO WAIT FOR SENDER
NCNXC:	RTS	PC		; BACK FOR NEXT NCP OP

;			NCP CONNECTION WAS CLOSED, FREE THE
;			CONNECTION TABLE AND CLEAN OFF OLD
;			NCP EVENT QUEUE ELEMENTS.

NCPCXF:	$PUSH	R2		; SAVE FOR COMPARE LATER
	JSR	PC,$RLSCT	; RELEASE THE CONNX TBL
	$POP	R2		; RECOVER CT VALUE
	ADD	#CTIPP,R2	; ADDR OF IORB IN OLD CT
	$SIGNL	#0,#-1,R1	; SIGNAL SELF, OP = -1
2$:	$WAIT			; NOW REMOVE ENTRIES AND SEARCH
	TSTB	R0		; SEE IF WE'VE REACHED THE FLAG
	BMI	1$		; THAT'S IT, WE'RE DONE
	CMPB	#OPNSIO,R0	; WAS IT SIO COMPLETION?
	BNE	3$		; NO, DON'T DELETE IT
	CMP	R1,R2		; IS SIGNALLED VALUE SAME AS CT?
	BEQ	2$		; YES, DELETE IT
3$:	SWAB	R0		; ELSE SIGNAL SELF WITH ENTRY
	CLRB	R0		; INDICATE OWN PROCESS ID
	$SIGNL	R0,R0,R1	; CAN PROCESS REQUESTS LATER
	BR	2$		; SEARCH FOR FLAG INDICATING END.
1$:	RTS	PC		; ALL THRU, RETURN
	.PAGE
	.SBTTL	NCP -- SIO (IPP) COMPLETION

$NSIOC:	MOV	R1,R2		; IORB ADDRX TO R2 SO WE
	SUB	#CTIPP,R2	; CAN COMPUTE CT POINTER
	BICB	#200,CTSTAT(R2)	; INDICATE IPP I/O NOT IN PROG.
	BEQ	NSIONR		; CONNECTION GOT CLOSED!
	BIT	#1,CTLCL(R2)	; IS THIS SEND CONNECTION ??
	BEQ	NSIOI		; NO, ITS RECEIVE
	TST	CTIBR(R2)	; WAS IT JUST A TEST ??
	BEQ	NSIORI		; YES, GO FIND HOW MUCH THERE IS TO GO
	.IF EQ	N.XNCP-1	; XNCP OPTION DEFINED?
	BITB	#100,CTSTAT(R2)	; IS IT XNCP CONNECTION ??
	BNE	NSIOOX		; YES, NO MSG FORMATTING FOR HH PROTOCOL
		.ENDC

;			UPDATE ALLOCATION INFORMATION FOR CONNECTION

	DEC	CTMCT(R2)	; DECREMENT MESSAGE COUNT
	MOV	CTIBX(R2),R4	; OBTAIN BYTES TRANSFERRED FROM USER
	MOV	R4,R0		; SAVE FOR LATER
	ASL	R4		; COMPUTE NUMBER BITS TO GO
	ASL	R4
	ASL	R4		; = NR BYTES * 8
	CLR	R3		; SETUP FOR BIT ALLOCATION UPDATE
	JSR	PC,$DECAL	; DECREASE CURRENT ALLOCATION ON CONNX
	MOV	CTMQP(R2),R1	; OBTAIN BASE OF MESSAGE
	MOV	-(R1),R1	; FROM MQE...

;			NOW FORMAT THE OUT-GOING MESSAGE

;			R0 CONTAINS NUMBER OF 8-BIT BYTES TO BE XF'D
;			R1 POINTS TO THE MESSAGE BUFFER
;			R3 = 0
;			R4 CONTAINS NUMBER OF BITS TO BE XFERRED

	MOV	@CTHTA(R2),(R1)+	; SET HOST ADDRESS
	CLRB	(R1)+		; NULL FIELD IN LEADER
	MOVB	CTLINK(R2),(R1)+	; SET LINK NUMBER
	BISB	CTBSIZ(R2),R3	; STORE BYTE SIZE IN R3
	MOV	R3,(R1)+	; MOVE BYTES SIZE (S) TO HH MESSAGE
	ASR	R3		; SETUP FOR DIVIDE
1$:	ASR	R4		; DIVIDE NUMBER OF BITS BY BYTE
;				  SIZE TO GET NUMBER OF BYTES.
	ASR	R3		; SHIFT DIVISOR (NOTE THAT WE'RE DIV
;				  BY A POWER OF TWO).
	BCC	1$		; KEEP SHIFTING TILL 1 GOES OFF END
	MOV	R4,(R1)+	; MOVE NUMBER BYTES INTO MESSAGE
	MOV	R0,R5		; NUMBER OF 8-BIT BYTES SAVED IN R5
	ASR	R0		; COMPUTE NUMBER OF WORDS (16-BIT)
	INC	R0		; ACCOUNT FOR M2 FIELD
	CMPB	#10,CTBSIZ(R2)	; IS THIS 8-BIT B.S. CONNX ??
	BNE	NSIOML		; NO, HANDLE WORD TRAPACKING
	CLRB	(R1)		; CLEAR M2 FIELD FOR BYTE FORMAT
2$:	SWAB	(R1)+		; CONVERT TO NET STD. BYTE STRING
	$LOOP	R0,2$		; FOR EACH WORD IN MSG
	ASR	R5		; WAS NUMBER OF BYTES EVEN ?
	BCS	NSIOC1		; NO, DON'T PUT M3 FIELD IN
NSIOC0:	CLRB	-2(R1)		; SET M3 FIELD = 8 BITS OF 0
NSIOC1:	MOV	CTMQP(R2),R0	; OBTAIN ORIGINAL MQE POINTER
	SUB	-2(R0),R1	; COMPUTE WORD COUNT FOR MESSAGE
	ASR	R1
	ADC	R1		; ROUND IT
	MOV	R1,-6(R0)	; SET IT UP IN MQE
	MOV	CTHTA(R2),R1	; HTE POINTER FOR HHENQ
	$PUSH	R2		; SAVE CT POINTER
	JSR	PC,$HHENQ	; SET FOR ENQUEUE
	$POP	R2		; RETRIEVE CT POINTER
	CLR	CTMQP(R2)	; INDICATE ITS ON HOST-IMP QUEUE
NSIORI:	JSR	PC,$SNFLO	; TRY SOME MORE FLOW CONTROL...
NSIONR:	RTS	PC		; AND THAT'S IT FOR THE MSG
NSIOML:	CLR	(R1)+		; FORMAT WORD OR MUL-WORD MSGS
	BR	2$		; ACCOUNT FOR FIRST WORD MOVED
1$:	MOVB	1(R1),-2(R1)	; RE-PACK
	SWAB	(R1)+		; SWAP BYTES IN MSG
2$:	$LOOP	R0,1$		; TO ACCOUNT FOR PDP-11 CONVENTION
	BR	NSIOC0
	.IF NE	N.XNCP

;	   IPP TRANFER COMPLETE ON XNCP OUTPUT CONNECTION:
;	   ENQUEUE MESSAGE FOR TRANSMISSION.

NSIOOX:	MOV	CTMQP(R2),R0	; LOAD POINTER TO MSG'S MQE.
	CLR	CTMQP(R2)	; INDICATE NO ACTIVE QUEUE EL.
	$PUSH	R2		; $HIENQ TROMPS CT POINTER!!!
	JSR	PC,$HIENQ	; ENQUEUE TO IMP.
	$POP	R2
	BR	NCZRD		; ISSUE 0-LENGTH READ TO IPP & RETURN
	.ENDC
	.PAGE
	.SBTTL	RECEIVE CONNECTION IPP I/O COMPLETION HANDLER

NSIOI:	MOV	CTIBR(R2),R4	; WAS PREVIOUS SIO JUST A TEST ?
	BEQ	NRIRT		; YES, CALL FLOW CONTROL
	CLR	R3
	ASL	R4		; COMPUTE NUMBER BITS TO GO
	ROL	R3		; AND SHIFT IN HIGH BITS TO R3
	ASL	R4
	ROL	R3
	ASL	R4		; = NR BYTES * 8
	ROL	R3
	JSR	PC,$DECAL	; DECREASE CURRENT ALLOCATION ON CONNX
	MOV	CTMQP(R2),R0	; OK, DISCARD THAT LAST MQE
	BEQ	NRIRT		; ITS NON-EXISTENT!
	CLR	CTMQP(R2)	; AND FLAG AS RELEASED
	JSR	PC,$DISMQ	; RELEASE MQE AND BUFFER.
NRIRT:	MOVB	CTSTAT(R2),R3	; OBTAIN CONNEXTION STATE
	BIC	#177760,R3	; MASK OFF  FLAG BITS
	CMPB	#STDRAI,R3		; ARE WE IN CLOSE (DRAIN) WAIT
	BNE	1$		; NO, DON'T BOTHER WITH CLOSE CONNX
	TST	CTQ(R2)		; HAS ALL DATA BEEN RCD ?
	BNE	1$		; NO, ALLOW RECEIVER TO GET IT
	MOV	#40002,CTIFCN(R2)	; SET END OF STREAM
	MOVB	#OPNNUL,CTIOPC(R2)	; NO MORE SIGNALS, PLEASE
	MOV	R2,R0		; OBTAIN IORB ADDRESS
	CLR	CTIBR(R2)	; CLEAR BYTES REQ
	ADD	#CTIPP,R0	; BASE OF IORB TO R0
	$SIO	R0		; INIT STRT I/O TO PORT
	MOV	#STCLWL,R0	; GO TO CLOSE-WAIT-LOCAL STATE
	JSR	PC,$ETCST	; SET CONNECTION STATUS
	MOV	CTPCI(R2),R0	; PROCESS ID OF USER 
	MOV	CTCCT(R2),R1	; CCT ADDRESS
	MOVB	#WCCCLS,CCTCC(R1) ; SET COMPLETION CODE "REMOTE CLOSE"
	$SIGNL	R0,R0,R1	; TELL HIM IT CLOSED REMOTELY
	RTS	PC		; AND RETURN
1$:	JSR	PC,$RCFLO	; ENTER RECEIVE FLOW CONTROL
	RTS	PC		; AND RETURN


	.END
    