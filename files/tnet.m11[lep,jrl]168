;	ELF75C.5
	.PAGE
;
;TCT STATUS BYTE
HINP	=	200			;HIDE INPUT
RVIO	=	100			;RCV I/O IN PROGRESS
ECHS	=	40			;ECH BIT 0=> LOCAL ECHO
PRFC	=	3			;PROTOCOL PREFACE(DO,WILL,ETC.)


	.SBTTL
	.SBTTL	SEND CONNECTION TELNET PROCESS (PRIMARY)
	.SBTTL	SND - ESTABLISH AND MAINTAIN A CONNECTION

;	R0 - HOST #
;	R1 - SKT #
;	R2 - TCT ADR

$CONN:	$PUSH	R0,R1			;SAVE REGISTERS
	$EPSET	#TRNSE			;SET CTL-C TRANSPARENT
	$POP	R1,R0			;RESTORE REGISTERS
	JSR	PC,CONCHK		;CHK FOR EXISTING CONNS
	BNE	10$			;NONE
	MOV	#21,R0			;'RECONNECTING'
	JSR	PC,ASYMSG		;SAY IT
	BR	1$			;ALRDY SET UP
10$:	TST	R0			;HOST # = 0?
	BEQ	5$			;QUIT IF YES
	JSR	PC,CONINI		;INIT A PAIR OF CONNS
	BNE	4$			;ERROR
1$:	JSR	PC,NETSND		;MAINTAIN SEND CONNECTION
	BEQ	5$			;USER WANTS OUT
4$:	CLR	R1			;ERR, SUPPRESS MSGS AND
	JSR	PC,$CLS			;CLOSE ALL CONNECTIONS
5$:	$EPSET	#TRNSD			;RESTORE CTL-C
	JSR	PC,$ERINR		;RESET EXEC RING BUFFER
	RTS	PC			;RETURN TO CMD INTERPRETER
	.PAGE
	.SBTTL	SND - CHECK FOR EXISTING CONNECTION

;	R0 - HOST #
;	R1 - SKT #
;	R2 - TCT ADR

;RETURNS Z = 1 IF EXISTING CONNECTION
;	R3 - SND TCCT
;	R4 - RCV TCCT

;RIGHT NOW ONLY ONE CONNECTION AT A TIME
CONCHK:	MOV	TCTRCV(R2),R4		;GET RCV TCCT'S LINK
	BEQ	3$			;EMPTY
	MOV	TCTSND(R2),R3		;GET SND TCCT'S LINK
	SEZ				;ALL'S WELL
	RTS	PC			;ELSE RETURN ALL SET UP
3$:	CLZ				;ELSE INDICATE FAILURE
	RTS	PC			;AND RETYURN
	.PAGE
	.SBTTL	SND - INITIALIZE A PAIR OF CONNECTIONS

;	R0 - HOST #
;	R1 - SKT #
;	R2 - TCT ADR

;INDICATE ERROR WITH Z=0
;ELSE
;	R3 - TCCT-SND
;	R4 - TCCT-RCV

CONINI:	JSR	PC,CONALO		;ALLOCATE PAIR OF TCCT'S
	BNE	7$			;ERR NO AVAIL STORAGE
	MOV	R0,TCCCCT(R4)		;SET RCV HOST #
	MOV	R0,TCCCCT(R3)		;SET SND HOST #
	MOV	R1,TCCFGN+2(R4)		;RCV ICP SKT
	MOV	R1,TCCFGN+2(R3)		;SND ICP SKT #
	MOVB	#COS,TCCOPC(R3)		;SEND CCT OP-CODE
	MOVB	#COR,TCCOPC(R4)		;RCV CCT 0PCODE
	MOVB	TCTMPI(R2),TCCPID(R3)	;ASGN PRIME PROC TO SND CONN
	MOVB	TCTSPI(R2),TCCPID(R4)	;AND SUBSID PROC TO RCV CONN
	MOV	#OPICP,R0		;USABLE OP-CODE
	$PUSH	R2			;SAVE TCT ADR
	MOV	R3,R1			;SND TCCT ADR IN R1
	MOV	R4,R2			;RCV TCCT ADR IN R2
	$NUICP	R0,R1,R2		;SET UP SKTS VIA ICP
	$POP	R2			;RECOVER TCT ADR
	MOVB	TCCSTA(R4),R0		;RCV CCT OP-CODE
	BIC	#177600,R0		;MINUS MISC
	BEQ	3$			;ITS OK
	CMPB	#WCCIST-200,R0		;MIGHT BE ERR
	BGT	4$			;CONN ERR
3$:	MOVB	TCCSTA(R3),R0		;SND CCT OP CODE
	BIC	#177600,R0		;W/O MISC
	BEQ	5$			;LOOKS OK
4$:	JSR	PC,ASYMSG		;REPORT IMP INFO
	CMPB	#WCCIST-200,R0		;WAS IT AN INFO MSG?
	BNE	6$			;NO RETRN Z=0 FOR ERR
5$:	MOV	#23,R0			;'CONNECTION COMPLETE'
	JSR	PC,ASYMSG		;SAY IT
	SEZ				;ALLS WELL
	RTS	PC			;SO RETURN
6$:	MOVB	#1,TCCSTA(R3)		;INDICATE CONN CLOSED
	MOVB	#1,TCCSTA(R4)		;FOR SND & RCV 
	RTS	PC			;RETURN
7$:	JSR	PC,ASYMSG		;'INSUFFIENT STORRAGE'
	CLZ				;INDICATE ERROR
	RTS	PC			;RETURN
	.PAGE
	.SBTTL	SND - ALLOCATE A PAIR OF TCCT'S

;	R0 - HOST #
;	R1 - SKT #
;	R2 - TCT ADR

;ERROR IF Z=0
;ELSE
;	R3 - TCCT-SND
;	R4 - TCCT-RCV

CONALO:	$PUSH	R0,R1,R2		;SAVE REGISTERS
	$AVS	#TCCLEN*2,#0		;ALLOC A BLOCK FOR 2 TCCT'S
	TST	R0			;CHK RESULT
	BEQ	4$			;NO STORAGE
	MOV	R2,R3			;ADDRESS OF PAIR OF TCCT'S
1$:	CLRB	(R3)+			;ZERO BYTE AND INCREMENT ADDRESS
	$LOOP	R0,1$			;LOOP UNTIL ALL BYTES ZEROED
	MOV	(SP),R4			;GET TCT ADR
	ADD	#TCTRCV,R4		;PT AT RCV TCCT LINK
	MOV	R4,R3			;NOW CALC
	TST	(R3)+			;THE ADR OF SND TCCT LINK
2$:	TST	(R4)			;END OF RCV LINK
	BEQ	3$			;YES
	MOV	(R4),R4			;ELSE GET NXT LEVEL OF TCCTS
	MOV	(R3),R3			;SEND AND RCV
	BR	2$			;CHK FOR END AGAIN
3$:	MOV	R2,(R4)			;ADD NEW TCCT TO RCV LINK
	ADD	#TCCLEN,R2		;ADR OF SND PAIR
	MOV	R2,(R3)			;ADD NEW TCCT TO SEND LINK
	MOV	(R3),R3			;NEW SND TCCT IN R3
	MOV	(R4),R4			;NEW RCV TCCT IN R4
	$POP	R2,R1,R0		;RESTORE REGISTERS
	SEZ				;ALL'S WELL
	RTS	PC			;AND RETURN
4$:	$POP	R2,R1,R0		;RESTORE REGISTERS
	MOV	#22,R0			;SET ERR CODE(NO AVAIL STG)
	RTS	PC			;AND RETURN
	.PAGE
	.SBTTL	SND - MAINTAIN A SEND CONNECTION

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR
;	R5 - DSTN CHAR ADR

NETSND:	$SIGNL	TCTSPI(R2),#STRT,#1	;START THE NET RCV PROC
	BITB	#ECHS,TCTSTA(R2)	;LOCAL ECHO
	BEQ	1$			;YES
	$EPSET	#ECHDSA			;NO
1$:	JSR	PC,SETSND		;INIT SEND LINE BUFF
SNDTST:	$TSTQ				;ANY QUEUE ELEMENTS ON PROCESS
	BEQ	2$			;NO CARRY ON
	$WAIT				;YES GET IT OFF Q
	TSTB	R0			;A TELNET CMD?
	BPL	10$			;NO
	JSR	PC,SNDCMD		;ELSE SEND IT
	BNE	NETSNX			;QUIT IF ERR
	BR	SNDTST			;ALL'S WELL
10$:	CMPB	R0,#RCVERR		;RCV SIDE ERR?
	BNE	20$			;NO
	MOV	R1,R0			;ELSE SET MSG CODE
	BR	NETSNX			;AND EXIT
20$:	CMPB	R0,#COS			;CONNECTION OP-CODE?
	BNE	SNDTST			;NO
	MOVB	TCCSTA(R3),R0		;GET GET CONN OP-CODE
	BIC	#177600,R0		;W/O MISC
	BEQ	SNDTST			;NOTHING
	CMPB	R0,#WCCIST-200		;IMP INFO MSG
	BNE	NETSNX			;NO SOME ERROR
	JSR	PC,ASYMSG		;PRINT 'IMP GOING DOWN'
	BR	SNDTST			;AND CARRYON
2$:	$PUSH	R2			;SAVE REGISTERS
	MOV	TCTIFH(R2),R1		;FILE HANDLE IN R1
	JSR	PC,$BIN			;GET CHAR FROM TERMINAL
	MOV	R2,R0			;CHAR IN R0
	$POP	R2			;RESTORE TCT ADR
	CMPB	R0,TCTESC(R2)		;ESC CHAR?
	BNE	15$			;NO
	JSR	PC,GENSND		;YES SND WHAT'S HERE
	BR	NETSNX			;THEN EXIT
15$:	CMPB	R0,#CR			;CARRIAGE RETURN
	BNE	30$			;NO
	JSR	PC,SNDCHR		;SEND THE CHAR
	JSR	PC,GENSND		;SEND WHAT'S THERE
	BNE	NETSNX			;CONN ERR
	MOV	#LF,R0			;SEND LF AFTER CR
30$:	CMPB	R0,TCTATN(R2)		;BREAK CHAR?
	BNE	40$			;NO
	MOV	#OBRK,R0		; SEND OLD TELNET BRK
	JSR	PC,SNDCHR
	MOV	#IAC,R0			; SEDTUP FOR NEW TELNET
	JSR	PC,SNDCHR
	MOV	#BRK,R0			;YES SND A BRK CMD
	JSR	PC,SNDCHR		;SET CMD IN BUFF
	JSR	PC,GENSND		;AND SND WHAT'S THERE
	BEQ	SNDTST			;CONN STILL OK
	BR	NETSNX			;ELSE EXIT
40$:	$PUSH	R0			;SAVE CHAR
	TSTB	TCTSTA(R2)		;HIDE INPUT MODE
	BPL	4$			;NO
	MOV	#DLMTBL,R1		;ADR OF TERMINATOR TABLE
3$:	TSTB	(R1)			;END OF TBL
	BEQ	4$			;YES
	CMPB	R0,(R1)+		;A MATCH?
	BNE	3$			;NO
	BICB	#200,TCTSTA(R2)		;YES CLR HIDE INPUT MODE
	$EPSET	#ECHENA			;ENABLE LOCAL ECHO
4$:	$POP	R0			;RECOVER CHAR
	BEQ	SNDTST			;DON'T SEND NULLS
	JSR	PC,SNDCHR		;SEND THE R0 CHAR OVER THE NET
	BGT	SNDTST			;THERE'S ANOTHER CHAR
	JSR	PC,GENSND		;ELSE SEND THE LINE BUFF
	BEQ	SNDTST			;CARRY ON UNLESS ERR
NETSNX:	$PUSH	R0			;SAVE ERR CODE IF ANY
	$SIGNL	TCTSPI(R2),#STOP,#0	;STOP THE NETRCV PROC
	$WAITS	#STPACK			;WAIT TIL HE ANSWERS
	$EPSET	#ECHENA			;ENABLE ECHO
	$POP	R0			;RECOVER ERR CODE IF ANY
	BEQ	2$			;ESC EXIT
	JSR	PC,ASYMSG		;ELSE PRINT ERR MSG
2$:	RTS	PC			;AND RETURN
DLMTBL:	.BYTE	CR,LF,BLN,ESC,ALT,0
	.EVEN
	.PAGE

	.SBTTL	SND - SEND A TELNET COMMAND

;	R0 - COMMAND CODE
;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR
;	R5 - DSTN CHAR ADR

;ERR CODE IN R0 IF Z=0

SNDCMD:	$PUSH	R1			;SAVE DATA WD
	MOV	#CMDTBL,R1		;ADR OF CMD TBL PROCEDURES IN R1
	BIC	#177400,R0		;CLR HI BYTE OF CMD CODE
1$:	TST	(R1)			;END OF TABLE
	BEQ	3$			;YES GUESS WE DONT SUPPORT THAT CMD
	CMP	R0,(R1)+		;A MATCH
	BEQ	2$			;YES
	CMP	(R1)+,(R1)+		;NO MOVE TO NXT ONE
	BR	1$			;TRY AGAIN
2$:	TSTB	(R1)			;END OF CMD CHARS?
	BEQ	20$			;YES
	MOVB	(R1)+,(R5)+		;INSERT CMD CHAR
	INC	TCCBR(R3)		;BMP CHAR CNT
	BR	2$			;GET NXT CHAR
20$:	TST	(SP)+			;RESTORE STACK
	JSR	PC,GENSND		;DO A GENERAL PURPOSE SEND
	RTS	PC			;AND RETURN
;SEND NEGATIVE ACKNOWLEDGE FOR NON-PROCESSED TELNET CMDS
3$:	MOV	(SP),R1			;CMD/PREF IN R1
	MOVB	R0,(R5)+		;IAC CHAR
	MOVB	R1,(R5)+		;WONT OR DONT
	SWAB	R1			;ALIGN BYTE
	MOVB	R1,(R5)+		;NON-PROCESSED CMD
	ADD	#3,TCCBR(R3)		;BMP CHAR CNT
	BR	20$			;SEND THE CMD

	.SBTTL	SND - SEND A CHARACTER OVER THE CONNECTION

;	R0 - CHAR
;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR
;	R5 - DSTN CHAR ADR

;TIME TO SEND BUFF IF Z=0

SNDCHR:	MOVB	R0,(R5)+		;INSERT CHAR
	INC	TCCBR(R3)		;BUMP SEND CNT
	JSR	PC,$ERINC		;MORE CHARS IN RING BUFF?
	BLE	1$			;NO RETURN
	MOV	R2,R1			;TCT ADR IN R1
	ADD	#TCTSLB+TCTSBL-3,R1	;ADR OF 1ST BYTE AFTER SEND BUFF
	CMP	R1,R5			;CHK IF DSTN ADR THAT FAR
1$:	RTS	PC			;RETRN Z=0 IF TIME TO SEND 

;SEND TCCT SET-UP
;
;	R2 - TCT ADR
;	R3 - SEND TCCT ADR
;	R4 - RCV TCCT ADR
;	R5 - SEND BUFF ADR (UPON RETURN)

SETSND:	MOVB	#IOS,TCCIOP(R3)		;SET IORB OP-CODE
	MOV	R2,R5			;TCT ADR
	ADD	#TCTSLB,R5		;SEND LINE BUFF ADR
	MOV	R5,TCCADD(R3)		;IORB BUFF ADR
	CLR	TCCBR(R3)		;CLR BYTES REQSTD
	CLR	TCCBX(R3)		;CLR BYTES XFRD
	CLR	TCCSTA(R3)		;CLR I/O STATUS
	MOV	#WRT,TCCFNC(R3)		;SET FCN CODE
	RTS	PC			;AND RETURN


;COMMAND TABLE SEQUENCES
CMDTBL:	.WORD	WECHO
	.BYTE	IAC,WILL,ECHO,0
	.WORD	WNECHO
	.BYTE	IAC,WONT,ECHO,0
	.WORD	DECHO
	.BYTE	IAC,DO,ECHO,0
	.WORD	DNECHO
	.BYTE	IAC,DONT,ECHO,0
;	.WORD	GA
;	.BYTE	GA,0,0,0
	.WORD	0			
	.PAGE
	.SBTTL	SND - SEND BYTES OVER CONNECTION PORT

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR
;ERR IF Z=0

GENSND:	MOVB	TCCSTA(R3),R0		;GET CONN STAT
	BIC	#177600,R0		;W/O MISC
	BEQ	50$			;ALL'S WELL
	CMPB	#WCCIST-200,R0		;IMP INFO?
	BNE	2$			;ERR IF NOT
50$:	TST	TCCBR(R3)		;CHK NUM BYTES REQSTD
	BEQ	20$			;QUIT IF NONE
	MOV	R3,R0			;SEND TCCT ADR
	ADD	#TCCIOR,R0		;SEND PORT IORB ADR
	CLR	TCCIST(R3)		;CLR I/O STATUS
	$SIO	R0			;DO THE I/O
	BR	10$			;1ST PASS DONT WAIT
1$:	$DSCHD				;WAIT LEAVING MSG Q INTACT
10$:	$TSTQS	#RCVERR			;RCV SIDE ERR
	BNE	4$			;YES
	$TSTQS	#COS			;OR CONNECTION ERROR
	BNE	30$			;YES
	$TSTQS	#IOS			;I/O COMPLETE
	BNE	3$			;YES
	BR	1$			;NO GO BACK TO SLEEP
30$:	$WAITS	#COS			;GET CONNECTION OP-CODE
	MOVB	TCCSTA(R3),R0		;GET CONNECTION STATUS
	BIC	#177600,R0		;W/O MISC
	BEQ	10$			;ITS OK WAIT FOR I/O
	CMPB	#WCCIST-200,R0		;SEE IF IMP INFO
	BNE	2$			;NO AN ERR
	JSR	PC,ASYMSG		;SEND IMP INFO MSG
	BR	10$			;WAIT FOR I/O
2$:	RTS	PC			;ELSE RETRN WITH ERR CODE
3$:	$WAITS	#IOS			;GET THE I/O OP-CODE
20$:	JSR	PC,SETSND		;INIT SND BUFF FOR NXT TIME
	CLR	R0			;ALL'S WELL
	RTS	PC			;AND RETURN
4$:	$WAITS	#RCVERR			;GET RCV ERR MQE
	MOV	R1,R0			;GET MSG CODE IN R0
	RTS	PC			;AND RETURN
	.PAGE
	.SBTTL
	.SBTTL	RCV CONNECTION TELNET PROCESS(SUBSIDIARY)
	.SBTTL	RCV - MAINTAIN A TELNET RECEIVE CONNECTION

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR

STPRCV:	$SIGNL	TCTMPI(R2),#STPACK,#0	;SEND ACKNOWLEDGEMENT
NETRCV:	$TSTQS	#STRT			;START ELEM ON Q?
	BNE	NTRCV2			;YES GO DO IT
	$TSTQS	#STOP			;STOP ELEM ON PROCESS Q
	BNE	NTRCV1			;YES GO GET IT
	$DSCHD				;NEITHER WAIT FOR NEW SIGNALS
	BR	NETRCV			;AND TRY AGAIN
NTRCV1:	$WAITS	#STOP			;GET THE STOP MQE
	BR	STPRCV			;AND GO ACKNOWLEDGE IT
NTRCV2:	$WAITS	#STRT			;WAIT TO BE STARTED BY NETSND
	TST	R1			;CHK DATA 
	BEQ	20$			;0 => FLUSH Q
	CMPB	R1,#11			;RESET CLOSE?
	BNE	2$			;NO
	CLR	R0			;YES HOST = 0 FOR ALL
	CLR	R1			;SUPPRESS MSG PRINT OUT
	MOVB	TCTMPI(R2),TCTSPI(R2)	;REMEMBER EXEC'S PID
	JSR	PC,$CLS			;CLOSE CONNS FOR EXEC RESET
	MOVB	TCTSPI(R2),TCTMPI(R2)	;RESTORE EXEC PID
	BR	STPRCV			;DO STOP ACKNOWLEDGE
20$:	$TSTQ				;ELSE FLUSH Q
	BEQ	STPRCV			;GO BACK TO SLEEP
	$WAIT				;GET Q ELEMENT
	BR	20$			;LOOK FOR ANOTHER
1$:	JSR	PC,NETRD		;READ FROM THE NET
	BNE	STPRCV			;TIME TO STOP
2$:	MOV	TCTRCV(R2),R4		;INIT RCV TCCT ADR
	MOV	TCTSND(R2),R3		;AND SND TCCT ADR
	BITB	#100,TCTSTA(R2)		;RCV CONN I/O IN PROGRESS?
	BNE	1$			;YES GO COMPLETE IT
	JSR	PC,CHKPT		;CHK FOR ERRS,STOPS,SYNCS ETC.
	BNE	STPRCV			;STOP CMD
	CLR	R1			;GET RDY
	BISB	TCTCMX(R2),R1		;GET INDEX TO CMD PROCEDURE
	JSR	PC,@CXTBL(R1)		;EXECUTE THAT PROCEDURE
	BEQ	2$			;NORMAL EXIT
	JSR	PC,CHROUT		;ELSE EMPTY LINE BUFFER
	BNE	2$			;STILL SOME NET CHARS LEFT
	BR	1$			;FILL IT AGAIN

;COMMAND INDEX TABLE
CXTBL:	.WORD	RCVCHR			;RCV A CHAR
	.WORD	CMDHNT			;INITIAL CMD INTERPRETATION
	.WORD	NEWCMD			;PROCESS NEW PROTOCOL CMDS
	.WORD	OPTCMD			;PROCESS NEW CMD OPTION PROTOCOL
	.PAGE
	.SBTTL	RCV - OUTPUT TELNET CHARS TO TERMINAL

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR

;Z=1 NET INPUT CHARS EXHAUSTED

CHROUT:	MOV	TCTDCT(R2),R0		;GET OUTPUT CHAR CNT
	BEQ	1$			;QUIT IF NOTHING
	$PUSH	R2			;ELSE SAVE TCT ADR
	MOV	TCTOFH(R2),R1		;OUTPUT FILE HANDLE
	MOV	TCTDST(R2),R2		;ADR OF OUTPUT CHAR STRING
	JSR	PC,$SOUT		;OUTPUT THRU EXEC
	MOV	R2,R1			;UPDATED DSTN ADDRESS
	$POP	R2			;RECOVER TCT ADR
	MOV	R1,TCTDST(R2)		;GET NEW DSTN ADR
	CLR	TCTDCT(R2)		;CLR DSTN CNT
1$:	TST	TCTSCT(R2)		;RETRN STATUS OF NET INPUT CHARS
	RTS	PC			;AND RETURN
	.PAGE
	.SBTTL	RCV - RECEIVE NET CHARS FOR TERMINAL OUTPUT

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR

;NET BUFF EMPTY IF Z=0

RCVCHR:	CMP	#TLINL,TCTDCT(R2)	; ACCUMULATED CHR LIMIT?
	BGT	1$			; NO, PROCEED
	JSR	PC,CHROUT		; OUTPUT WHAT'S BEEN ACCUM
1$:	TST	TCTSCT(R2)		;CHK IF ANY NET CHARS
	BEQ	NOCHAR			;NO
	BITB	#TRNSPM,TCTFLG(R2)	;TRANSPARENT MODE?
	BNE	RCVENT			;YES, IGNORE CMDS
	TSTB	@TCTSRC(R2)		;CMD CHAR?
	BMI	CMDCHR			;GOOD CHANCE OF IT
;ENTRY FOR NULLED CMD CHARS
RCVENT:	INC	TCTSRC(R2)		;BMP SRC ADR
	DEC	TCTSCT(R2)		;REDUCE SRC CNT
	BITB	#TRNSPM,TCTFLG(R2)	;TRANSPARENT MODE?
	BNE	1$			;YES
	TSTB	TCTSC(R2)		;WAITING FOR DATA MARK?
	BLE	1$			;NO
	INC	TCTDST(R2)		;YES SKIP THIS CHAR
	BR	RCVX			;THEN EXIT
1$:	INC	TCTDCT(R2)		;INCREASE DSTN CNT
RCVX:	SEZ				;;ALLS WELL
	RTS	PC			;RETURN
CMDCHR:	MOVB	#2,TCTCMX(R2)		;SET NDX TO CMDHNT
	JSR	PC,CHROUT		;OUTPUT ANY CHARS BEFORE MODE CHNG
	BR	RCVX			;AND EXIT
NOCHAR:	CLZ				;SET NET BUFF EMPTY FLAG
	RTS	PC			;AND RETURN
	.PAGE
	.SBTTL	RCV - TELNET CMD CHAR INITIAL INTERPRETATION

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR

;NET BUFF EMTPY IF Z=0

CMDHNT:	TST	TCTSCT(R2)		;ANY NET CHARS?
	BEQ	NOCHAR			;YES EXIT
	CLR	R1			;GET RDY TO GET BYTE
	BISB	@TCTSRC(R2),R1		;GET NXT SRC(NET) BYTE
	MOV	#OTCTBL,R0		;ADR OF OLD TELNET CMD TBL
1$:	TST	(R0)			;END OF TABLE
	BEQ	3$			;YES
	CMP	(R0)+,R1		;MATCH?
	BEQ	2$			;YES
	TST	(R0)+			;NO SKIP AHEAD
	BR	1$			;AND TRY AGAIN
2$:	JMP	@(R0)			;BRANCH TO OLD CMD HNDLR

3$:	CMPB	R1,#IAC			;NEW TELNET CMD HERALD
	BEQ	4$			;YES
	CLRB	TCTCMX(R2)		;ESLE RESTORE NDX TO RCVCHR
	BR	RCVENT			;GIVE USER THIS NULL CMD CHAR
4$:	MOVB	#4,TCTCMX(R2)		;SET NDX TO NEW TELNET CMD HNDLR
CMDCXX:	INC	TCTSRC(R2)		;BMP SRC PTR
	INC	TCTDST(R2)		;BMP DST PTR
	DEC	TCTSCT(R2)		;DEC NUM NET CHARS
	SEZ				;ALL'S WELL
	RTS	PC			;RETURN
	.PAGE
	.SBTTL	RCV - OLD TELNET COMMAND HANDLERS

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR

;OLD TELNET COMMAND TABLE
OTCTBL:	.WORD	ODM,ODMR		;DATA MARK
	.WORD	OEC,OECR		;ECHO
	.WORD	ONEC,ONECR		;NO ECHO
	.WORD	OHI,OHIR		;HIDE INPUT
;	.WORD	GA,GAHD			;GO AHEAD
	.WORD	0


;DATA MARK
ODMR:	DECB	TCTSC(R2)		;DEC SYNC CNT
	BR	OTCXX			;EXIT

;ECHO
OECR:	$EPSET	#ECHENA			;ENABLE LOCAL ECHO
	BICB	#ECHS,TCTSTA(R2)		;LOCAL ECHO
	BR	OTCXX			;EXIT

;HIDE INPUT
OHIR:	$EPSET	#ECHDSA			;DSABLE ECHO
	BISB	#200,TCTSTA(R2)		;SET HIDE INPUT MODE
	BR	OTCXX			;EXIT

;NO ECHO
ONECR:	$EPSET	#ECHDSA			;DSABLE LOCAL ECHO
	BISB	#ECHS,TCTSTA(R2)	;REMOTE ECHO
	BR	OTCXX			;EXIT

;GO AHEAD
GAHD:	MOV	#GA,R0			;RETRN A GO AHEAD CMD
	BR	ECHSIG			;AND EXIT
	
;EXIT
OTCXX:	CLRB	TCTCMX(R2)		;SET NDX TO RCVCHR
	BR	CMDCXX			;USE NRML CMD EXIT
	.PAGE
	.SBTTL	RCV - PROCESS NEW TELNET CMD CHARACTERS

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR

;NET BUFF EMPTY IF Z=0

NEWCMD:	TST	TCTSCT(R2)		;ANY NET CHARS
	BEQ	NOCHAR			;NO
	CLR	R1			;GET RDY TO GET CHAR
	BISB	@TCTSRC(R2),R1		;GET SRC(NET) CHAR
	CMPB	R1,#IAC			;REPEAT OF HERALD
	BNE	1$			;NO
	CLRB	TCTCMX(R2)		;ELSE SET NDX TO RCVCHR
	BR	RCVENT			;AND LET USER HAVE CHAR
1$:	CMPB	R1,#NDM			;DATA MARK CHAR?
	BNE	2$			;NO
	DECB	TCTSC(R2)		;ELSE DECR SYNC CNT
	BR	OTCXX			;USE OLD TELNET CMD EXIT
2$:	SUB	#WILL,R1		;NORMALIZE TO OPTION PREFACE
	BLT	OTCXX			;QUIT IF ANY OTHER CMD
	BICB	#3,TCTSTA(R2)		;PREPARE FIELD
	BISB	R1,TCTSTA(R2)		;SAVE OPTION PREFACE
	MOVB	#6,TCTCMX(R2)		;SET NDX TO CMD OPTION HNDLR
	BR	CMDCXX			;RETURN

	.PAGE
	.SBTTL	RCV - PROCESS TELNET CMD OPTIONS

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR

;NET BUFF EMPTY IF Z=0

OPTCMD:	TST	TCTSCT(R2)		;ANY NET CHARS?
	BEQ	NOCHAR			;NO
	CLR	R1			;GET RDY TO GET BYTE
	BISB	@TCTSRC(R2),R1		;GET NET CHAR
	MOV	#OPTTBL,R0		;OPTION TABLE ADR IN R0
1$:	TST	(R0)			;END OF TABLE
	BEQ	3$			;YES SEND NEG ACKNOWLEDGEMNT
	CMP	R1,(R0)+		;MATCH?
	BEQ	2$			;YES
	TST	(R0)+			;ESLE BMP PTR
	BR	1$			;TRY AGAIN
2$:	JMP	@(R0)			;EXECUTE RIGHT HANDLER
;SEND NEGATIVE ACKNOWLEDGEMNENT
3$:	MOV	R1,R0			;NON-PROCESSED CMD CODE
	MOVB	TCTSTA(R2),R1		;RCVD PREFACE-WILL/DO/ETC.
	COM	R1			;CREATE NEG ACKN
	BIC	#177776,R1		;CLR MISC BITS
	BIS	#1,R1			;DONT FOR WILL OR WONT
					;WONT FOR DO OR DONT
	ADD	#WILL,R1		;COMPUTE PREFACE CODE
	SWAB	R0			;ALIGN CMD BYTE
	BIS	R0,R1			;CMD/PREFACE IN R1
	MOV	#IAC,R0			;IAC IN LO-BYTE
	BR	ECHSIG			;SEND NEG ACKN TO SND PROC

;TELNET OPTION COMMANDS TABLE
OPTTBL:	.WORD	ECHO,ECHOH		;ECHO
	.WORD	0

;ECHO HANDLERS
ECHOH:	MOVB	TCTSTA(R2),R1		;GET OPTION CODE
	BIC	#177774,R1		;W/O MISC
	ASL	R1			;MAKE A BYTE NDX
	JMP	@ECHTBL(R1)		;EXECUTE RIGHT RESPONSE
ECHSIG:	SWAB	R0			;CMD OP-CODE IN HIGH BYTE
	BISB	TCTMPI(R2),R0		;SND CONN PROC ID
	$SIGNL	R0,R0,R1		;SND CMD TO SND CONN
	CLR	R0			;SEND A NULL CHAR
	JSR	PC,$ERINA		;TO AWAKEN SEND PROCESS
	BR	OTCXX			;AND EXIT
ECHTBL:	.WORD	NECHR			;WILL ECHO
	.WORD	NNECHR			;WONT ECHO
	.WORD	DECHR			;DO ECHO
	.WORD	DNECHR			;DONT ECHO
;WILL ECHO
NECHR:	$EPSET	#ECHDSA			;DSABLE ECHO
	BISB	#ECHS,TCTSTA(R2)	;REMOTE ECHO
	MOV	#DECHO,R0		;ACKN WITH 'DO ECHO'
	BR	ECHSIG			;SEND IT
;WONT ECHO
NNECHR:	$EPSET	#ECHENA			;ENABLE LOCAL ECHO
	BICB	#ECHS,TCTSTA(R2)	;LOCAL ECHO
	MOV	#DNECHO,R0		;ACKN WITH 'DONT ECHO'
	BR	ECHSIG			;SEND IT
;DO ECHO
DECHR:	$EPSET	#ECHENA			;ENABLE ECHO
	BICB	#ECHS,TCTSTA(R2)	;LOCAL ECHO
	MOV	#WECHO,R0		;ACKN WITH 'WILL ECHO'
	BR	ECHSIG			;SEND IT
;DONT ECHO
DNECHR:	$EPSET	#ECHDSA			;DISABLE ECHO
	BISB	#ECHS,TCTSTA(R2)	;REMOTE ECHO
	MOV	#WNECHO,R0		;ACKN WITH 'WONT ECHO'
	BR	ECHSIG			;SEND IT
	.PAGE
	.SBTTL	RCV - CHECK STATUS OF RECEIVE CONNECTION

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR

;Z=0 INDICATES  STOP CMD

CHKPT:	$TSTQ				;ANY MQES
	BEQ	1$			;NO
	$WAIT				;SEE WHAT IT IS
	CMPB	R0,#STOP		;STOP CMD?
	BEQ	CHPTST			;YES
	CMPB	R0,#COR			;RCV CONN OP-CODE?
	BNE	CHKPT			;NO
	MOVB	TCCSTA(R2),R1		;GET CONN OPCODE
	BIC	#177600,R1		;W/O MISC
	BEQ	1$			;NOP
	CMP	#WCCIST-200,R1		;CHK IF IMP INFO
	BLT	10$			;SYNC 
	BEQ	1$			;IMP INFO
	$SIGNL	TCTMPI(R2),#RCVERR,R1	;TELL PRIMARY PROC OF CONN ERR
	CLR	R0			;ADD NULL TO RING BUFFER
	JSR	PC,$ERINA		;TO AROUSE SEND PROCESS
	$WAITS	#STOP			;WAIT FOR 'STOP'
	BR	CHPTST			;THEN EXIT
10$:	INCB	TCTSC(R2)		;NO BMP SYNC CNT
1$:	BITB	#TRNSPM,TCTFLG(R2)	;TRANS MODE?
	BNE	2$			;YES
	TSTB	TCTSC(R2)		;CHK SYNC CNT
	BGE	2$			;OK IF POS
	$TSTQ				;MORE ON THE Q
	BNE	CHKPT			;YES DO THEM
	$DSCHD				;NO SO WAIT
	BR	CHKPT			;CHK NEW MQES
2$:	SEZ				;ALLS WELL
	RTS	PC			;RETURN
CHPTST:	CLZ				;GOT A STOP SIGNAL
	RTS	PC			;RETURN
	.PAGE
	.SBTTL	RCV - READ CHARS FROM RECEIVE CONNECTION

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR

;Z=0 INDICATES TIME TO STOP

NETRD:	BITB	#100,TCTSTA(R2)		;RCV I/O IN PROG?
	BNE	10$			;YES COMPLETE IT
	MOVB	TCCSTA(R4),R0		;GET CONN STAT
	BIC	#177600,R0		;W/O MISC
	BEQ	50$			;IT'S OK
	CMP	#WCCIST-200,R0		;IMP INFO OR SYNC?
	BGT	4$			;ERR IF NOT
50$:	BISB	#100,TCTSTA(R2)		;I/O IN PROG NOW
	MOV	#TCTRBL,TCCBR(R4)	;SET # CHARS TO READ
	MOV	R2,R5			;TCT ADR
	ADD	#TCTRLB,R5		;READ BUFF ADR
	MOV	R5,TCCADD(R4)		;SET BUFF ADR
	MOV	R5,TCTSRC(R2)		;INIT SRC PTR
	MOV	R5,TCTDST(R2)		;INIT DST PTR
	CLR	TCTDCT(R2)		;INIT DSTN CNT
	CLR	TCTSCT(R2)		;INIT SOURCE COUNT
	CLR	TCCIST(R4)		;CLR I/O STATUS
	CLR	TCCBX(R4)		;CLR BYTES XRRD
	MOVB	#IOR,TCCIOP(R4)		;INIT IORB OP CODE
	MOV	#RD,TCCFNC(R4)		;INIT FCN CODE TO BE 'READ'
	MOV	R4,R0			;RCV TCC ADR
	ADD	#TCCIOR,R0		;RCV PORT IORB ADR
	$SIO	R0			;READ FROM NET
	BR	10$			;1ST TIME DONT WAIT
1$:	$DSCHD				;WAIT FOR SOMETHING NEW
10$:	$TSTQS	#STOP			;STOP CMD?
	BNE	5$			;YES
	$TSTQS	#COR			;CONNECTION OPCODE
	BNE	20$			;YES
	$TSTQS	#IOR			;I/O COMPLETE?
	BNE	2$			;YES
	BR	1$			;NO KEEP WAITING
20$:	$WAITS	#COR			;GET CONN MQE
	MOVB	TCCSTA(R4),R0		;GET CONN STATUS
	BIC	#177600,R0		;W/O MISC
	BEQ	10$			;NOTHING KEEP WAITING
	CMP	#WCCIST-200,R0		;IMP INFO
	BEQ	10$			;YES KEEP WAITING
	BGT	4$			;CONN ERR SO QUIT WAITING
	INCB	TCTSC(R2)		;A SYNC SO BMP SYNC CNT
	BR	10$			;AND KEEP WAITING
2$:	$WAITS	#IOR			;GET THE I/O MQE
	MOV	TCCBX(R4),TCTSCT(R2)	;SRC CNT IS NUM XFRD
	BICB	#100,TCTSTA(R2)		;I/O NO LONGER IN PROGRESS
3$:	SEZ				;ALLS WELL
	RTS	PC			;AND RETURN
4$:	MOV	R0,R1			;PASS CONN STAT AS DATA
	$SIGNL	TCTMPI(R2),#RCVERR,R1	;REPORT ERR TO PRIMARY PROCESS
	CLR	R0			;ADD NULL  CHAR TO RING BUFF
	JSR	PC,$ERINA		;TO AROUSE SEND PROCESS
5$:	$WAITS	#STOP			;WAIT TO BE STOPPED
	CLZ				;TIME TO STOP
	RTS	PC			;AND RETURN
	.PAGE
	.SBTTL
	.SBTTL	TELNET UTILITY
	.SBTTL	STAT - OBTAIN HOST/IMP STATUS

;	R0 - HOST # (0 => LOCAL IMP)
;	R1 - SKT #
;	R2 - TCT ADR

$STAT:	$PUSH	R0,R1			;SAVE REGISTERS
	$EPSET	#CTLCD			;TURN OFF CTL-C
	$NPSET	#NPIST			;GET IMP STATUS
	MOV	#20,R0			;'IMP DOWN' CODE IN R0
	TST	R1			;CHK RETRN CODE
	BNE	1$			;IMP IS DOWN
	DEC	R0			;ELSE ADJUST ID TO IMP UP
1$:	JSR	PC,ASYMSG		;PRINT THE MSG
	$EPSET	#CTLCE			;TURN ON CTL-C
	$POP	R1,R0			;RESTORE REGISTERS
	RTS	PC			;AND RETURN
	.PAGE
	.SBTTL
	.SBTTL	TELNET UTILITY
	.SBTTL	CLS - CLOSE A CONNECTION PAIR

;	R0 - HOST # (0 => 'CLOSE ALL CONNECTIONS')
;	R1 - SUPPRESS PRINTOUT IF '0'
;	R2 - TCT ADR

$CLS:	$PUSH	R1,R0			;SAVE REGISTERS
	$EPSET	#CTLCD			;TURNOFF CTL-C
	CLRB	TCTSTA(R2)		;INDICATE NO REASGN
10$:	$TSTQ				;FLUSH Q
	BEQ	20$			;ITS EMPTY
	$WAIT				;GET AN MQE
	BR	10$			;GET ANOTHER
20$:	$GAPID				;GET ACTV PROC ID
	CMPB	R0,TCTMPI(R2)		;SAME AS TNET SND PROC?
	BEQ	30$			;YES
	MOVB	#200,TCTSTA(R2)		;NO INDICATE REASSGN
	MOVB	R0,TCTMPI(R2)		;SET PID CODE TO NEW PROC
30$:	$POP	R0			;RECOVER HOST ID
	JSR	PC,CONCHK		;CHK THE CONNECTIONS
	BNE	CLOX			;NONE, ELSE SND/RCV TCCTS IN R3/R4
	CLR	R5			;CURRENTLY NO ACTV CLOSES
	MOV	R3,R0			;TCCT ADR TO R0
	JSR	PC,CHKCLS		;CHK IF CLOSED
	BEQ	1$			;YES IT ALRDY IS
	BIS	#100000,R5		;ACTV SEND CLOSE
	TST	(R0)+			;COMPUTE CCT ADR
	TSTB	TCTSTA(R2)		;REASSGN?
	BEQ	40$			;NO
	$PUSH	R0			;YES SAVE CCT ADR
	MOV	R0,R1			;CCT ADR IN R1
	MOVB	TCTMPI(R2),TCCPID(R3)	;SET NEW PID IN SND CCT
	$NPSET	#NPASSG			;REASSIGN CONNECTION
	$POP	R0			;RESTORE CCT ADR
40$:	$N.CLS	R0			;CLOSE IT
1$:	MOV	R4,R0			;RCV TCCT ADR IN R0
	JSR	PC,CHKCLS		;CHK IT
	BEQ	2$			;CLOSED
	MOVB	TCTMPI(R2),TCCOPC+1(R4)	;ASGN RCV CONN TO PRIM PROC
	MOV	R4,R1			;TCCT ADR
	TST	(R1)+			;CCT ADR
	$NPSET	#NPASSG			;ASSIGN CONN FOR CLSNG
	MOV	R4,R0			;TCCT ADR BACK IN R0
	BIS	#200,R5			;IDICATE ACTV RCV CLOSE
	TST	(R0)+			;COMPUTE CCT ADR
	$N.CLS	R0			;CLOSE RCV CONN
2$:	TST	R5			;ANY CLOSES IN PROGRESS
	BEQ	CLOX			;NO QUIT NOW
	$STIME	#TIME,#30000.		;SET TIMER TO 30 SECONDS

CLWT:	$DSCHD				;WAIT FOR SOMETHING NEW
	TST	R5			;ACTV SND CLS?
	BPL	1$			;NO
	$TSTQS	#COS			;YES IS IT THERE
	BNE	SCLS			;YES IT IS
1$:	TSTB	R5			;ACTV RCV CLS
	BPL	2$			;NO
	$TSTQS	#COR			;ELSE CHK FOR IT
	BNE	RCLS			;ITS HERE
2$:	$TSTQS	#TIME			;TIME UP?
	BEQ	CLWT			;NOT YET
	BR	TCLS			;CLOSE TIMED OUT
	.PAGE
	.SBTTL	CLS - CLOSE COMPLETE


;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCC ADR
;	R5 - ACT RCV/SND CLOSE FLAGS

;SEND CONN CLOSED
SCLS:	MOV	#COS,R0			;OP CODE IN R0
	$PUSH	R3			;TCCT ADR ON STACK
	JSR	PC,CCLS			;CMPLT CLOSE
	BIC	#100000,R5		;INDICATE NO ACTV SND CLS
	BEQ	CLOX			;ALL DONE
	BR	CLWT			;ELSE WAIT FOR RCV SIDE

;RECEIVE CONN CLOSED
RCLS:	MOV	#COR,R0			;OP CODE IN R0
	$PUSH	R4			;TCCT ADR ON STACK
	JSR	PC,CCLS			;COMPLETE CLOSE
	BIC	#200,R5			;NO LONGER ACTV RCV CLS
	BEQ	CLOX			;ALL DONE
	BR	CLWT			;ELSE WAIT FOR SEND SIDE

	.PAGE
	.SBTTL	CLS - CLOSE TIMED OUT

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR
;	R5 - ACTV CLOSE FLAGS
;	(SP)- PRINT FLAG IF NON-ZERO

;CLOSE TIMED OUT
TCLS:	$WAITS	#TIME			;GET THE MQE
	TST	(SP)			;MSG SUPPRESSION?
	BEQ	1$			;YES
	MOV	#16,R0			;'CLOSE TIMED OUT'
	JSR	PC,ASYMSG		;SAY IT
1$:	CLR	(SP)			;NO MORE PRINTOUT
	TST	R5			;CHK ACTV CLOSES
	BEQ	CLOX			;QUIT IF NONE
	BPL	2$			;NO ACTV SND
	MOV	R3,R0			;TCCT ADR
	TST	(R0)+			;CCT ADR
	$N.CLS	R0			;CLOSE IT FOR THE NCP CLNUP
	$N.CLS	R0			;3X TO BE SAFE
2$:	TSTB	R5			;ACTV RCV CLS
	BPL	CLOX			;NO, EXIT
	MOV	R4,R0			;RCV TCCT ADR
	TST	(R0)+			;RCV CCT ADR
	$N.CLS	R0			;CLOSE IT
	$N.CLS	R0			;3X TO BE SAFE
					;AND EXIT THRU CLOX

	.PAGE
	.SBTTL	CLS - CLOSE EXIT


;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR
;	(SP) - PRINT FLAG IF NOT 0

;CLOSE COMPLETE
CLOX:	TST	(SP)			;MSG SUPPRESSION?
	BEQ	1$			;YES
	MOV	#15,R0			;'CLOSE COMPLETE'
	JSR	PC,ASYMSG		;SAY IT
1$:	$STIME	#TIME,#1		;TURN OFF TIMER
	$WAITS	#TIME			;WAIT FOR IT
	$PUSH	R2			;SAVE TCT ADR
	MOV	#TCCLEN*2,R0		;# BYTES FOR TCCT PAIR
	CLR	R1			;VSM ID
	MOV	R4,R2			;ADR
	BEQ	10$			;NO BUFF ALLOCATED
	$FVS	R0,R1,R2		;RELEASE THE TCCTS
10$:	$POP	R2			;RECOVER TCCT ADR
	CLR	TCTRCV(R2)		;CLR RCV PTR
	CLR	TCTSND(R2)		;CLR SND PTR
	TSTB	TCTSTA(R2)		;REASSGND?
	BMI	4$			;YES
2$:	$TSTQ				;FLUSH THE Q
	BEQ	3$			;DONE
	$WAIT				;PULL ONE OFF
	BR	2$			;LOOK FOR MORE
3$:	$SIGNL	TCTSPI(R2),#STRT,#0	;TELL RCV PROC TO FLUSH Q
	$WAITS	#STPACK			;WAIT FOR IT
4$:	CLRB	TCTSTA(R2)		;CLR STATUS OF TELNET CONN
	CLR	TCTSC(R2)		;CLR SYNC CNT & CMD NDX
	CLR	TCTSCT(R2)		;CLR SRC AND DSTN CNTS
	CLR	TCTDCT(R2)
	$EPSET	#CTLCE			;TURN ON CTL C
	TST	(SP)+			;RESTORE STACK
	RTS	PC			;AND RETURN
	.PAGE
	.SBTTL	CLS - CLOSE UTILITIES


;	R0 - ACTV TCCT ADR
;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR


;CHK IF CONN CLOSED,  YES IF Z=1
CHKCLS:	CLR	R1			;GET RDY FOR BYTE
	MOVB	TCCSTA(R0),R1		;GET CONN STATUS
	BIC	#177600,R1		;W/O MISC
	BEQ	1$			;NRML STAT => OPEN
	CMPB	#WCCCLS-200,R1		;WAS IT CLOSED REMOTELY?
	BEQ	1$			;YES THEN RETURN $N.CLS 
	CMPB	#WCCIST-200,R1		;CHK AGAINST UPPER LIMIT
	BLE	1$			;INFO+SYNC => OPEN
	SEZ				;ERR => CLOSED
	RTS	PC			;RETURN
1$:	CLZ				;SET FLAG TO OPEN
	RTS	PC			;AND RETURN


;	R0 - CONN OP-CODE
;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCC ADR
;	R5 - ACT CLS FLAGS
;	(SP) - RETRN ADR
;	2(SP) - CURRENT TCCT ADR
;	4(SP) - PRINT FLAG IF NOT 0

;COMPLETE THE CLOSE CHK
CCLS:	$WAITS	R0			;GET THE CONN MQE
	MOV	2(SP),R1		;GET CURR TCCT ADR
	MOVB	TCCSTA(R1),R0		;GET CONN STATUS
	BIC	#177600,R0		;W/O MISC
	BEQ	2$			;OK
	CMP	#WCCCLS-200,R0		;CONNECTION CLOSED?
	BEQ	2$			;YES EXIT
	CMP	#WCCIST-200,R0		;CHK AGAINST LIMIT
	BLE	2$			;OK
	TST	4(SP)			;ERR, CHK IF PRINTABLE
	BEQ	2$			;NO
	$PUSH	R5			;ELSE SAVE FLAGS
	JSR	PC,ASYMSG		;PRINT THE MSG
	$POP	R5			;RESTORE THE FLAGS
	CLR	4(SP)			;CLR PRINT FLAG
2$:	MOV	(SP),2(SP)		;MOVE RETRN OVER ARG
	TST	(SP)+			;PULL OFF REDUNDANT RETRN
	RTS	PC			;RETURN
	.END
;	ELF75A.2
	.PAGE
	.SBTTL
	.SBTTL	SEND CONNECTION TELNET PROCESS (PRIMARY)
	.SBTTL	SND - ESTABLISH AND MAINTAIN A CONNECTION

;	R0 - HOST #
;	R1 - SKT #
;	R2 - TCT ADR

$CONN:	$PUSH	R0,R1			;SAVE REGISTERS
	$EPSET	#TRNSE			;SET CTL-C TRANSPARENT
	$POP	R1,R0			;RESTORE REGISTERS
	JSR	PC,CONCHK		;CHK FOR EXISTING CONNS
	BNE	10$			;NONE
	MOV	#21,R0			;'RECONNECTING'
	JSR	PC,ASYMSG		;SAY IT
	BR	1$			;ALRDY SET UP
10$:	TST	R0			;HOST # = 0?
	BEQ	5$			;QUIT IF YES
	JSR	PC,CONINI		;INIT A PAIR OF CONNS
	BNE	4$			;ERROR
1$:	JSR	PC,NETSND		;MAINTAIN SEND CONNECTION
	BEQ	5$			;USER WANTS OUT
4$:	CLR	R1			;ERR, SUPPRESS MSGS AND
	JSR	PC,$CLS			;CLOSE ALL CONNECTIONS
5$:	$EPSET	#TRNSD			;RESTORE CTL-C
	JSR	PC,$ERINR		;RESET EXEC RING BUFFER
	RTS	PC			;RETURN TO CMD INTERPRETER
	.PAGE
	.SBTTL	SND - CHECK FOR EXISTING CONNECTION

;	R0 - HOST #
;	R1 - SKT #
;	R2 - TCT ADR

;RETURNS Z = 1 IF EXISTING CONNECTION
;	R3 - SND TCCT
;	R4 - RCV TCCT

;RIGHT NOW ONLY ONE CONNECTION AT A TIME
CONCHK:	MOV	TCTRCV(R2),R4		;GET RCV TCCT'S LINK
	BEQ	3$			;EMPTY
	MOV	TCTSND(R2),R3		;GET SND TCCT'S LINK
	SEZ				;ALL'S WELL
	RTS	PC			;ELSE RETURN ALL SET UP
3$:	CLZ				;ELSE INDICATE FAILURE
	RTS	PC			;AND RETYURN
	.PAGE
	.SBTTL	SND - INITIALIZE A PAIR OF CONNECTIONS

;	R0 - HOST #
;	R1 - SKT #
;	R2 - TCT ADR

;INDICATE ERROR WITH Z=0
;ELSE
;	R3 - TCCT-SND
;	R4 - TCCT-RCV

CONINI:	JSR	PC,CONALO		;ALLOCATE PAIR OF TCCT'S
	BNE	7$			;ERR NO AVAIL STORAGE
	MOV	R0,TCCCCT(R4)		;SET RCV HOST #
	MOV	R0,TCCCCT(R3)		;SET SND HOST #
	MOV	R1,TCCFGN+2(R4)		;RCV ICP SKT
	MOV	R1,TCCFGN+2(R3)		;SND ICP SKT #
	MOVB	#COS,TCCOPC(R3)		;SEND CCT OP-CODE
	MOVB	#COR,TCCOPC(R4)		;RCV CCT 0PCODE
	MOVB	TCTMPI(R2),TCCPID(R3)	;ASGN PRIME PROC TO SND CONN
	MOVB	TCTSPI(R2),TCCPID(R4)	;AND SUBSID PROC TO RCV CONN
	MOV	#OPICP,R0		;USABLE OP-CODE
	$PUSH	R2			;SAVE TCT ADR
	MOV	R3,R1			;SND TCCT ADR IN R1
	MOV	R4,R2			;RCV TCCT ADR IN R2
	$NUICP	R0,R1,R2		;SET UP SKTS VIA ICP
	$POP	R2			;RECOVER TCT ADR
	MOVB	TCCSTA(R4),R0		;RCV CCT OP-CODE
	BIC	#177600,R0		;MINUS MISC
	BEQ	3$			;ITS OK
	CMPB	#WCCIST-200,R0		;MIGHT BE ERR
	BGT	4$			;CONN ERR
3$:	MOVB	TCCSTA(R3),R0		;SND CCT OP CODE
	BIC	#177600,R0		;W/O MISC
	BEQ	5$			;LOOKS OK
4$:	JSR	PC,ASYMSG		;REPORT IMP INFO
	CMPB	#WCCIST-200,R0		;WAS IT AN INFO MSG?
	BNE	6$			;NO RETRN Z=0 FOR ERR
5$:	MOV	#23,R0			;'CONNECTION COMPLETE'
	JSR	PC,ASYMSG		;SAY IT
	SEZ				;ALLS WELL
	RTS	PC			;SO RETURN
6$:	MOVB	#1,TCCSTA(R3)		;INDICATE CONN CLOSED
	MOVB	#1,TCCSTA(R4)		;FOR SND & RCV 
	RTS	PC			;RETURN
7$:	JSR	PC,ASYMSG		;'INSUFFIENT STORRAGE'
	CLZ				;INDICATE ERROR
	RTS	PC			;RETURN
	.PAGE
	.SBTTL	SND - ALLOCATE A PAIR OF TCCT'S

;	R0 - HOST #
;	R1 - SKT #
;	R2 - TCT ADR

;ERROR IF Z=0
;ELSE
;	R3 - TCCT-SND
;	R4 - TCCT-RCV

CONALO:	$PUSH	R0,R1,R2		;SAVE REGISTERS
	$AVS	#TCCLEN*2,#0		;ALLOC A BLOCK FOR 2 TCCT'S
	TST	R0			;CHK RESULT
	BEQ	4$			;NO STORAGE
	MOV	R2,R3			;ADDRESS OF PAIR OF TCCT'S
1$:	CLRB	(R3)+			;ZERO BYTE AND INCREMENT ADDRESS
	$LOOP	R0,1$			;LOOP UNTIL ALL BYTES ZEROED
	MOV	(SP),R4			;GET TCT ADR
	ADD	#TCTRCV,R4		;PT AT RCV TCCT LINK
	MOV	R4,R3			;NOW CALC
	TST	(R3)+			;THE ADR OF SND TCCT LINK
2$:	TST	(R4)			;END OF RCV LINK
	BEQ	3$			;YES
	MOV	(R4),R4			;ELSE GET NXT LEVEL OF TCCTS
	MOV	(R3),R3			;SEND AND RCV
	BR	2$			;CHK FOR END AGAIN
3$:	MOV	R2,(R4)			;ADD NEW TCCT TO RCV LINK
	ADD	#TCCLEN,R2		;ADR OF SND PAIR
	MOV	R2,(R3)			;ADD NEW TCCT TO SEND LINK
	MOV	(R3),R3			;NEW SND TCCT IN R3
	MOV	(R4),R4			;NEW RCV TCCT IN R4
	$POP	R2,R1,R0		;RESTORE REGISTERS
	SEZ				;ALL'S WELL
	RTS	PC			;AND RETURN
4$:	$POP	R2,R1,R0		;RESTORE REGISTERS
	MOV	#22,R0			;SET ERR CODE(NO AVAIL STG)
	RTS	PC			;AND RETURN
	.PAGE
	.SBTTL	SND - MAINTAIN A SEND CONNECTION

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR
;	R5 - DSTN CHAR ADR

NETSND:	$SIGNL	TCTSPI(R2),#STRT,#1	;START THE NET RCV PROC
	JSR	PC,SETSND		;INIT SEND LINE BUFF
SNDTST:	$TSTQ				;ANY QUEUE ELEMENTS ON PROCESS
	BEQ	2$			;NO CARRY ON
	$WAIT				;YES GET IT OFF Q
	TSTB	R0			;A TELNET CMD?
	BPL	10$			;NO
	JSR	PC,SNDCMD		;ELSE SEND IT
	BNE	NETSNX			;QUIT IF ERR
	BR	SNDTST			;ALL'S WELL
10$:	CMPB	R0,#RCVERR		;RCV SIDE ERR?
	BNE	20$			;NO
	MOV	R1,R0			;ELSE SET MSG CODE
	BR	NETSNX			;AND EXIT
20$:	CMPB	R0,#COS			;CONNECTION OP-CODE?
	BNE	SNDTST			;NO
	MOVB	TCCSTA(R3),R0		;GET GET CONN OP-CODE
	BIC	#177600,R0		;W/O MISC
	BEQ	SNDTST			;NOTHING
	CMPB	R0,#WCCIST-200		;IMP INFO MSG
	BNE	NETSNX			;NO SOME ERROR
	JSR	PC,ASYMSG		;PRINT 'IMP GOING DOWN'
	BR	SNDTST			;AND CARRYON
2$:	$PUSH	R2			;SAVE REGISTERS
	MOV	TCTIFH(R2),R1		;FILE HANDLE IN R1
	JSR	PC,$BIN			;GET CHAR FROM TERMINAL
	MOV	R2,R0			;CHAR IN R0
	$POP	R2			;RESTORE TCT ADR
	CMPB	R0,#CR			;CARRIAGE RETURN
	BNE	30$			;NO
	JSR	PC,SNDCHR		;SEND THE CHAR
	JSR	PC,GENSND		;SEND WHAT'S THERE
	BNE	NETSNX			;CONN ERR
	MOV	#LF,R0			;SEND LF AFTER CR
30$:	CMPB	R0,TCTATN(R2)		;BREAK CHAR?
	BNE	35$			;NO
	MOV	#BRK,R0			;YES SND A BRK CMD
	JSR	PC,SNDCHR		;SET CMD IN BUFF
	JSR	PC,GENSND		;AND SND WHAT'S THERE
	BEQ	SNDTST			;CONN STILL OK
	BR	NETSNX			;ELSE EXIT
35$:	CMPB	R0,TCTESC(R2)		;ESC CHAR?
	BNE	40$			;NO
	JSR	PC,GENSND		;YES SND WHAT'S HERE
	BR	NETSNX			;THEN EXIT
40$:	$PUSH	R0			;SAVE CHAR
	TSTB	TCTSTA(R2)		;HIDE INPUT MODE
	BPL	4$			;NO
	MOV	#DLMTBL,R1		;ADR OF TERMINATOR TABLE
3$:	TSTB	(R1)			;END OF TBL
	BEQ	4$			;YES
	CMPB	R0,(R1)+		;A MATCH?
	BNE	3$			;NO
	BICB	#200,TCTSTA(R2)		;YES CLR HIDE INPUT MODE
	$EPSET	#ECHENA			;ENABLE LOCAL ECHO
4$:	$POP	R0			;RECOVER CHAR
	JSR	PC,SNDCHR		;SEND THE R0 CHAR OVER THE NET
	BGT	SNDTST			;THERE'S ANOTHER CHAR
	JSR	PC,GENSND		;ELSE SEND THE LINE BUFF
	BEQ	SNDTST			;CARRY ON UNLESS ERR
NETSNX:	$PUSH	R0			;SAVE ERR CODE IF ANY
	$SIGNL	TCTSPI(R2),#STOP,#0	;STOP THE NETRCV PROC
	$WAITS	#STPACK			;WAIT TIL HE ANSWERS
	$EPSET	#ECHENA			;ENABLE ECHO
	$POP	R0			;RECOVER ERR CODE IF ANY
	BEQ	2$			;ESC EXIT
	JSR	PC,ASYMSG		;ELSE PRINT ERR MSG
2$:	RTS	PC			;AND RETURN
DLMTBL:	.BYTE	CR,LF,BLN,ESC,ALT,0
	.EVEN
	.PAGE

	.SBTTL	SND - SEND A TELNET COMMAND

;	R0 - COMMAND CODE
;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR
;	R5 - DSTN CHAR ADR

;ERR CODE IN R0 IF Z=0

SNDCMD:	$PUSH	R1			;SAVE DATA WD
	MOV	#CMDTBL,R1		;ADR OF CMD TBL PROCEDURES IN R1
	BIC	#177600,R0		;CLR HI BYTE OF CMD CODE
1$:	TST	(R1)			;END OF TABLE
	BEQ	3$			;YES GUESS WE DONT SUPPORT THAT CMD
	CMP	R0,(R1)+		;A MATCH
	BEQ	2$			;YES
	CMP	(R1)+,(R1)+		;NO MOVE TO NXT ONE
	BR	1$			;TRY AGAIN
2$:	TSTB	(R1)			;END OF CMD CHARS?
	BEQ	20$			;YES
	MOVB	(R1)+,(R5)+		;INSERT CMD CHAR
	INC	TCCBR(R3)		;BMP CHAR CNT
	BR	2$			;GET NXT CHAR
20$:	TST	(SP)+			;RESTORE STACK
	JSR	PC,GENSND		;DO A GENERAL PURPOSE SEND
	RTS	PC			;AND RETURN
;SEND NEGATIVE ACKNOWLEDGE FOR NON-PROCESSED TELNET CMDS
3$:	MOV	(SP),R1			;WONT-DONT/IAC IN R1
	MOVB	R1,(R5)+		;IAC CHAR
	SWAB	R1			;ALIGN BYTE
	MOVB	R1,(R5)+		;WONT OR DONT
	MOVB	R0,(R5)+		;NON-PROCESSED CMD
	ADD	#3,TCCBR(R3)		;BMP CHAR CNT
	BR	20$			;SEND THE CMD

	.SBTTL	SND - SEND A CHARACTER OVER THE CONNECTION

;	R0 - CHAR
;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR
;	R5 - DSTN CHAR ADR

;TIME TO SEND BUFF IF Z=0

SNDCHR:	MOVB	R0,(R5)+		;INSERT CHAR
	INC	TCCBR(R3)		;BUMP SEND CNT
	JSR	PC,$ERINC		;MORE CHARS IN RING BUFF?
	BLE	1$			;NO RETURN
	MOV	R2,R1			;TCT ADR IN R1
	ADD	#TCTSLB+TCTSBL-3,R1	;ADR OF 1ST BYTE AFTER SEND BUFF
	CMP	R1,R5			;CHK IF DSTN ADR THAT FAR
1$:	RTS	PC			;RETRN Z=0 IF TIME TO SEND 

;SEND TCCT SET-UP
;
;	R2 - TCT ADR
;	R3 - SEND TCCT ADR
;	R4 - RCV TCCT ADR
;	R5 - SEND BUFF ADR (UPON RETURN)

SETSND:	MOVB	#IOS,TCCIOP(R3)		;SET IORB OP-CODE
	MOV	R2,R5			;TCT ADR
	ADD	#TCTSLB,R5		;SEND LINE BUFF ADR
	MOV	R5,TCCADD(R3)		;IORB BUFF ADR
	CLR	TCCBR(R3)		;CLR BYTES REQSTD
	CLR	TCCBX(R3)		;CLR BYTES XFRD
	CLR	TCCSTA(R3)		;CLR I/O STATUS
	MOV	#WRT,TCCFNC(R3)		;SET FCN CODE
	RTS	PC			;AND RETURN


;COMMAND TABLE SEQUENCES
CMDTBL:	.WORD	WECHO
	.BYTE	IAC,WILL,ECHO,0
	.WORD	WNECHO
	.BYTE	IAC,WONT,ECHO,0
	.WORD	DECHO
	.BYTE	IAC,DO,ECHO,0
	.WORD	DNECHO
	.BYTE	IAC,DONT,ECHO,0
	.WORD	GA
	.BYTE	GA,0,0,0
	.WORD	0			
	.PAGE
	.SBTTL	SND - SEND BYTES OVER CONNECTION PORT

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR
;ERR IF Z=0

GENSND:	MOVB	TCCSTA(R3),R0		;GET CONN STAT
	BIC	#177600,R0		;W/O MISC
	BEQ	50$			;ALL'S WELL
	CMPB	#WCCIST-200,R0		;IMP INFO?
	BNE	2$			;ERR IF NOT
50$:	TST	TCCBR(R3)		;CHK NUM BYTES REQSTD
	BEQ	20$			;QUIT IF NONE
	MOV	R3,R0			;SEND TCCT ADR
	ADD	#TCCIOR,R0		;SEND PORT IORB ADR
	CLR	TCCIST(R3)		;CLR I/O STATUS
	$SIO	R0			;DO THE I/O
	BR	10$			;1ST PASS DONT WAIT
1$:	$DSCHD				;WAIT LEAVING MSG Q INTACT
10$:	$TSTQS	#RCVERR			;RCV SIDE ERR
	BNE	4$			;YES
	$TSTQS	#COS			;OR CONNECTION ERROR
	BNE	30$			;YES
	$TSTQS	#IOS			;I/O COMPLETE
	BNE	3$			;YES
	BR	1$			;NO GO BACK TO SLEEP
30$:	$WAITS	#COS			;GET CONNECTION OP-CODE
	MOVB	TCCSTA(R3),R0		;GET CONNECTION STATUS
	BIC	#177600,R0		;W/O MISC
	BEQ	10$			;ITS OK WAIT FOR I/O
	CMPB	#WCCIST-200,R0		;SEE IF IMP INFO
	BNE	2$			;NO AN ERR
	JSR	PC,ASYMSG		;SEND IMP INFO MSG
	BR	10$			;WAIT FOR I/O
2$:	RTS	PC			;ELSE RETRN WITH ERR CODE
3$:	$WAITS	#IOS			;GET THE I/O OP-CODE
20$:	JSR	PC,SETSND		;INIT SND BUFF FOR NXT TIME
	CLR	R0			;ALL'S WELL
	RTS	PC			;AND RETURN
4$:	$WAITS	#RCVERR			;GET RCV ERR MQE
	MOV	R1,R0			;GET MSG CODE IN R0
	RTS	PC			;AND RETURN
	.PAGE
	.SBTTL
	.SBTTL	RCV CONNECTION TELNET PROCESS(SUBSIDIARY)
	.SBTTL	RCV - MAINTAIN A TELNET RECEIVE CONNECTION

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR

STPRCV:	$SIGNL	TCTMPI(R2),#STPACK,#0	;SEND ACKNOWLEDGEMENT
NETRCV:	$TSTQS	#STRT			;START ELEM ON Q?
	BNE	NTRCV2			;YES GO DO IT
	$TSTQS	#STOP			;STOP ELEM ON PROCESS Q
	BNE	NTRCV1			;YES GO GET IT
	$DSCHD				;NEITHER WAIT FOR NEW SIGNALS
	BR	NETRCV			;AND TRY AGAIN
NTRCV1:	$WAITS	#STOP			;GET THE STOP MQE
	BR	STPRCV			;AND GO ACKNOWLEDGE IT
NTRCV2:	$WAITS	#STRT			;WAIT TO BE STARTED BY NETSND
	TST	R1			;CHK DATA 
	BEQ	20$			;0 => FLUSH Q
	CMPB	R1,#11			;RESET CLOSE?
	BNE	2$			;NO
	CLR	R0			;YES HOST = 0 FOR ALL
	CLR	R1			;SUPPRESS MSG PRINT OUT
	MOVB	TCTMPI(R2),TCTSPI(R2)	;REMEMBER EXEC'S PID
	JSR	PC,$CLS			;CLOSE CONNS FOR EXEC RESET
	MOVB	TCTSPI(R2),TCTMPI(R2)	;RESTORE EXEC PID
	BR	STPRCV			;DO STOP ACKNOWLEDGE
20$:	$TSTQ				;ELSE FLUSH Q
	BEQ	STPRCV			;GO BACK TO SLEEP
	$WAIT				;GET Q ELEMENT
	BR	20$			;LOOK FOR ANOTHER
1$:	JSR	PC,NETRD		;READ FROM THE NET
	BNE	STPRCV			;TIME TO STOP
2$:	MOV	TCTRCV(R2),R4		;INIT RCV TCCT ADR
	MOV	TCTSND(R2),R3		;AND SND TCCT ADR
	BITB	#100,TCTSTA(R2)		;RCV CONN I/O IN PROGRESS?
	BNE	1$			;YES GO COMPLETE IT
	JSR	PC,CHKPT		;CHK FOR ERRS,STOPS,SYNCS ETC.
	BNE	STPRCV			;STOP CMD
	CLR	R1			;GET RDY
	BISB	TCTCMX(R2),R1		;GET INDEX TO CMD PROCEDURE
	JSR	PC,@CXTBL(R1)		;EXECUTE THAT PROCEDURE
	BEQ	2$			;NORMAL EXIT
	JSR	PC,CHROUT		;ELSE EMPTY LINE BUFFER
	BNE	2$			;STILL SOME NET CHARS LEFT
	BR	1$			;FILL IT AGAIN

;COMMAND INDEX TABLE
CXTBL:	.WORD	RCVCHR			;RCV A CHAR
	.WORD	CMDHNT			;INITIAL CMD INTERPRETATION
	.WORD	NEWCMD			;PROCESS NEW PROTOCOL CMDS
	.WORD	OPTCMD			;PROCESS NEW CMD OPTION PROTOCOL
	.PAGE
	.SBTTL	RCV - OUTPUT TELNET CHARS TO TERMINAL

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR

;Z=1 NET INPUT CHARS EXHAUSTED

CHROUT:	MOV	TCTDCT(R2),R0		;GET OUTPUT CHAR CNT
	BEQ	1$			;QUIT IF NOTHING
	$PUSH	R2			;ELSE SAVE TCT ADR
	MOV	TCTOFH(R2),R1		;OUTPUT FILE HANDLE
	MOV	TCTDST(R2),R2		;ADR OF OUTPUT CHAR STRING
	JSR	PC,$SMOV		;OUTPUT THRU EXEC
	MOV	R2,R1			;UPDATED DSTN ADDRESS
	$POP	R2			;RECOVER TCT ADR
	MOV	R1,TCTDST(R2)		;GET NEW DSTN ADR
	CLR	TCTDCT(R2)		;CLR DSTN CNT
1$:	TST	TCTSCT(R2)		;RETRN STATUS OF NET INPUT CHARS
	RTS	PC			;AND RETURN
	.PAGE
	.SBTTL	RCV - RECEIVE NET CHARS FOR TERMINAL OUTPUT

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR

;NET BUFF EMPTY IF Z=0

RCVCHR:	TST	TCTSCT(R2)		;CHK IF ANY NET CHARS
	BEQ	NOCHAR			;NO
	BITB	#TRNSPM,TCTFLG(R2)	;TRANSPARENT MODE?
	BNE	RCVENT			;YES, IGNORE CMDS
	TSTB	@TCTSRC(R2)		;CMD CHAR?
	BMI	CMDCHR			;GOOD CHANCE OF IT
;ENTRY FOR NULLED CMD CHARS
RCVENT:	INC	TCTSRC(R2)		;BMP SRC ADR
	DEC	TCTSCT(R2)		;REDUCE SRC CNT
	TSTB	TCTSC(R2)		;WAITING FOR DATA MARK?
	BLE	1$			;NO
	INC	TCTDST(R2)		;YES SKIP THIS CHAR
	BR	RCVX			;THEN EXIT
1$:	INC	TCTDCT(R2)		;INCREASE DSTN CNT
RCVX:	SEZ				;;ALLS WELL
	RTS	PC			;RETURN
CMDCHR:	MOVB	#2,TCTCMX(R2)		;SET NDX TO CMDHNT
	JSR	PC,CHROUT		;OUTPUT ANY CHARS BEFORE MODE CHNG
	BR	RCVX			;AND EXIT
NOCHAR:	CLZ				;SET NET BUFF EMPTY FLAG
	RTS	PC			;AND RETURN
	.PAGE
	.SBTTL	RCV - TELNET CMD CHAR INITIAL INTERPRETATION

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR

;NET BUFF EMTPY IF Z=0

CMDHNT:	TST	TCTSCT(R2)		;ANY NET CHARS?
	BEQ	NOCHAR			;YES EXIT
	CLR	R1			;GET RDY TO GET BYTE
	BISB	@TCTSRC(R2),R1		;GET NXT SRC(NET) BYTE
	MOV	#OTCTBL,R0		;ADR OF OLD TELNET CMD TBL
1$:	TST	(R0)			;END OF TABLE
	BEQ	3$			;YES
	CMP	(R0)+,R1		;MATCH?
	BEQ	2$			;YES
	TST	(R0)+			;NO SKIP AHEAD
	BR	1$			;AND TRY AGAIN
2$:	JMP	@(R0)			;BRANCH TO OLD CMD HNDLR

3$:	CMPB	R1,#IAC			;NEW TELNET CMD HERALD
	BEQ	4$			;YES
	CLRB	TCTCMX(R2)		;ESLE RESTORE NDX TO RCVCHR
	BR	RCVENT			;GIVE USER THIS NULL CMD CHAR
4$:	MOVB	#4,TCTCMX(R2)		;SET NDX TO NEW TELNET CMD HNDLR
CMDCXX:	INC	TCTSRC(R2)		;BMP SRC PTR
	INC	TCTDST(R2)		;BMP DST PTR
	DEC	TCTSCT(R2)		;DEC NUM NET CHARS
	SEZ				;ALL'S WELL
	RTS	PC			;RETURN
	.PAGE
	.SBTTL	RCV - OLD TELNET COMMAND HANDLERS

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR

;OLD TELNET COMMAND TABLE
OTCTBL:	.WORD	ODM,ODMR		;DATA MARK
	.WORD	OEC,OECR		;ECHO
	.WORD	ONEC,ONECR		;NO ECHO
	.WORD	OHI,OHIR		;HIDE INPUT
	.WORD	GA,GAHD			;GO AHEAD
	.WORD	0


;DATA MARK
ODMR:	DECB	TCTSC(R2)		;DEC SYNC CNT
	BR	OTCXX			;EXIT

;ECHO
OECR:	$EPSET	#ECHENA			;ENABLE LOCAL ECHO
	BR	OTCXX			;EXIT

;HIDE INPUT
OHIR:	$EPSET	#ECHDSA			;DSABLE ECHO
	BISB	#200,TCTSTA(R2)		;SET HIDE INPUT MODE
	BR	OTCXX			;EXIT

;NO ECHO
ONECR:	$EPSET	#ECHDSA			;DSABLE LOCAL ECHO
	BR	OTCXX			;EXIT

;GO AHEAD
GAHD:	MOV	#GA,R0			;RETRN A GO AHEAD CMD
	BR	ECHSIG			;AND EXIT
	
;EXIT
OTCXX:	CLRB	TCTCMX(R2)		;SET NDX TO RCVCHR
	BR	CMDCXX			;USE NRML CMD EXIT
	.PAGE
	.SBTTL	RCV - PROCESS NEW TELNET CMD CHARACTERS

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR

;NET BUFF EMPTY IF Z=0

NEWCMD:	TST	TCTSCT(R2)		;ANY NET CHARS
	BEQ	NOCHAR			;NO
	CLR	R1			;GET RDY TO GET CHAR
	BISB	@TCTSRC(R2),R1		;GET SRC(NET) CHAR
	CMPB	R1,#IAC			;REPEAT OF HERALD
	BNE	1$			;NO
	CLRB	TCTCMX(R2)		;ELSE SET NDX TO RCVCHR
	BR	RCVENT			;AND LET USER HAVE CHAR
1$:	CMPB	R1,#NDM			;DATA MARK CHAR?
	BNE	2$			;NO
	DECB	TCTSC(R2)		;ELSE DECR SYNC CNT
	BR	OTCXX			;USE OLD TELNET CMD EXIT
2$:	SUB	#WILL,R1		;NORMALIZE TO OPTION PREFACE
	BLT	OTCXX			;QUIT IF ANY OTHER CMD
	BICB	#3,TCTSTA(R2)		;PREPARE FIELD
	BISB	R1,TCTSTA(R2)		;SAVE OPTION PREFACE
	MOVB	#6,TCTCMX(R2)		;SET NDX TO CMD OPTION HNDLR
	BR	CMDCXX			;RETURN

	.PAGE
	.SBTTL	RCV - PROCESS TELNET CMD OPTIONS

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR

;NET BUFF EMPTY IF Z=0

OPTCMD:	TST	TCTSCT(R2)		;ANY NET CHARS?
	BEQ	NOCHAR			;NO
	CLR	R1			;GET RDY TO GET BYTE
	BISB	@TCTSRC(R2),R1		;GET NET CHAR
	MOV	#OPTTBL,R0		;OPTION TABLE ADR IN R0
1$:	TST	(R0)			;END OF TABLE
	BEQ	3$			;YES SEND NEG ACKNOWLEDGEMNT
	CMP	R1,(R0)+		;MATCH?
	BEQ	2$			;YES
	TST	(R0)+			;ESLE BMP PTR
	BR	1$			;TRY AGAIN
2$:	JMP	@(R0)			;EXECUTE RIGHT HANDLER
;SEND NEGATIVE ACKNOWLEDGEMNENT
3$:	MOV	R1,R0			;NON-PROCESSED CMD CODE
	MOVB	TCTSTA(R2),R1		;RCVD PREFACE-WILL/DO/ETC.
	COM	R1			;CREATE NEG ACKN
	BIC	#177776,R1		;CLR MISC BITS
	BIS	#1,R1			;DONT FOR WILL OR WONT
					;WONT FOR DO OR DONT
	ADD	#WILL,R1		;COMPUTE PREFACE CODE
	SWAB	R1			;PREFACE IN HI-BYE
	BISB	#IAC,R1			;IAC IN LO-BYTE
	BR	ECHSIG			;SEND NEG ACKN TO SND PROC

;TELNET OPTION COMMANDS TABLE
OPTTBL:	.WORD	ECHO,ECHOH		;ECHO
	.WORD	0

;ECHO HANDLERS
ECHOH:	MOVB	TCTSTA(R2),R1		;GET OPTION CODE
	BIC	#177774,R1		;W/O MISC
	ASL	R1			;MAKE A BYTE NDX
	JMP	@ECHTBL(R1)		;EXECUTE RIGHT RESPONSE
ECHSIG:	SWAB	R0			;CMD OP-CODE IN HIGH BYTE
	BISB	TCTMPI(R2),R0		;SND CONN PROC ID
	$SIGNL	R0,R0,R1		;SND CMD TO SND CONN
	BR	OTCXX			;AND EXIT
ECHTBL:	.WORD	NECHR			;WILL ECHO
	.WORD	NNECHR			;WONT ECHO
	.WORD	DECHR			;DO ECHO
	.WORD	DNECHR			;DONT ECHO
;WILL ECHO
NECHR:	$EPSET	#ECHDSA			;DSABLE ECHO
	MOV	#DECHO,R0		;ACKN WITH 'DO ECHO'
	BR	ECHSIG			;SEND IT
;WONT ECHO
NNECHR:	$EPSET	#ECHENA			;ENABLE LOCAL ECHO
	MOV	#DNECHO,R0		;ACKN WITH 'DONT ECHO'
	BR	ECHSIG			;SEND IT
;DO ECHO
DECHR:	$EPSET	#ECHENA			;ENABLE ECHO
	MOV	#WECHO,R0		;ACKN WITH 'WILL ECHO'
	BR	ECHSIG			;SEND IT
;DONT ECHO
DNECHR:	$EPSET	#ECHDSA			;DISABLE ECHO
	MOV	#WNECHO,R0		;ACKN WITH 'WONT ECHO'
	BR	ECHSIG			;SEND IT
	.PAGE
	.SBTTL	RCV - CHECK STATUS OF RECEIVE CONNECTION

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR

;Z=0 INDICATES  STOP CMD

CHKPT:	$TSTQ				;ANY MQES
	BEQ	1$			;NO
	$WAIT				;SEE WHAT IT IS
	CMPB	R0,#STOP		;STOP CMD?
	BEQ	CHPTST			;YES
	CMPB	R0,#COR			;RCV CONN OP-CODE?
	BNE	CHKPT			;NO
	MOVB	TCCSTA(R2),R1		;GET CONN OPCODE
	BIC	#177600,R1		;W/O MISC
	BEQ	1$			;NOP
	CMP	#WCCIST-200,R1		;CHK IF IMP INFO
	BLT	10$			;SYNC 
	BEQ	1$			;IMP INFO
	$SIGNL	TCTMPI(R2),#RCVERR,R1	;TELL PRIMARY PROC OF CONN ERR
	CLR	R0			;ADD NULL TO RING BUFFER
	JSR	PC,$ERINA		;TO AROUSE SEND PROCESS
	$WAITS	#STOP			;WAIT FOR 'STOP'
	BR	CHPTST			;THEN EXIT
10$:	INCB	TCTSC(R2)		;YES BMP SYNC CNT
1$:	TSTB	TCTSC(R2)		;CHK SYNC CNT
	BGE	2$			;OK IF POS
	$TSTQ				;MORE ON THE Q
	BNE	CHKPT			;YES DO THEM
	$DSCHD				;NO SO WAIT
	BR	CHKPT			;CHK NEW MQES
2$:	SEZ				;ALLS WELL
	RTS	PC			;RETURN
CHPTST:	CLZ				;GOT A STOP SIGNAL
	RTS	PC			;RETURN
	.PAGE
	.SBTTL	RCV - READ CHARS FROM RECEIVE CONNECTION

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR

;Z=0 INDICATES TIME TO STOP

NETRD:	BITB	#100,TCTSTA(R2)		;RCV I/O IN PROG?
	BNE	10$			;YES COMPLETE IT
	MOVB	TCCSTA(R4),R0		;GET CONN STAT
	BIC	#177600,R0		;W/O MISC
	BEQ	50$			;IT'S OK
	CMP	#WCCIST-200,R0		;IMP INFO OR SYNC?
	BGT	4$			;ERR IF NOT
50$:	BISB	#100,TCTSTA(R2)		;I/O IN PROG NOW
	MOV	#TCTRBL,TCCBR(R4)	;SET # CHARS TO READ
	MOV	R2,R5			;TCT ADR
	ADD	#TCTRLB,R5		;READ BUFF ADR
	MOV	R5,TCCADD(R4)		;SET BUFF ADR
	MOV	R5,TCTSRC(R2)		;INIT SRC PTR
	MOV	R5,TCTDST(R2)		;INIT DST PTR
	CLR	TCTDCT(R2)		;INIT DSTN CNT
	CLR	TCTSCT(R2)		;INIT SOURCE COUNT
	CLR	TCCIST(R4)		;CLR I/O STATUS
	CLR	TCCBX(R4)		;CLR BYTES XRRD
	MOVB	#IOR,TCCIOP(R4)		;INIT IORB OP CODE
	MOV	#RD,TCCFNC(R4)		;INIT FCN CODE TO BE 'READ'
	MOV	R4,R0			;RCV TCC ADR
	ADD	#TCCIOR,R0		;RCV PORT IORB ADR
	$SIO	R0			;READ FROM NET
	BR	10$			;1ST TIME DONT WAIT
1$:	$DSCHD				;WAIT FOR SOMETHING NEW
10$:	$TSTQS	#STOP			;STOP CMD?
	BNE	5$			;YES
	$TSTQS	#COR			;CONNECTION OPCODE
	BNE	20$			;YES
	$TSTQS	#IOR			;I/O COMPLETE?
	BNE	2$			;YES
	BR	1$			;NO KEEP WAITING
20$:	$WAITS	#COR			;GET CONN MQE
	MOVB	TCCSTA(R4),R0		;GET CONN STATUS
	BIC	#177600,R0		;W/O MISC
	BEQ	10$			;NOTHING KEEP WAITING
	CMP	#WCCIST-200,R0		;IMP INFO
	BEQ	10$			;YES KEEP WAITING
	BGT	4$			;CONN ERR SO QUIT WAITING
	INCB	TCTSC(R2)		;A SYNC SO BMP SYNC CNT
	BR	10$			;AND KEEP WAITING
2$:	$WAITS	#IOR			;GET THE I/O MQE
	MOV	TCCBX(R4),TCTSCT(R2)	;SRC CNT IS NUM XFRD
	BICB	#100,TCTSTA(R2)		;I/O NO LONGER IN PROGRESS
3$:	SEZ				;ALLS WELL
	RTS	PC			;AND RETURN
4$:	MOV	R0,R1			;PASS CONN STAT AS DATA
	$SIGNL	TCTMPI(R2),#RCVERR,R1	;REPORT ERR TO PRIMARY PROCESS
	CLR	R0			;ADD NULL  CHAR TO RING BUFF
	JSR	PC,$ERINA		;TO AROUSE SEND PROCESS
5$:	$WAITS	#STOP			;WAIT TO BE STOPPED
	CLZ				;TIME TO STOP
	RTS	PC			;AND RETURN
	.PAGE
	.SBTTL
	.SBTTL	TELNET UTILITY
	.SBTTL	STAT - OBTAIN HOST/IMP STATUS

;	R0 - HOST # (0 => LOCAL IMP)
;	R1 - SKT #
;	R2 - TCT ADR

$STAT:	$PUSH	R0,R1			;SAVE REGISTERS
	$EPSET	#CTLCD			;TURN OFF CTL-C
	$NPSET	#NPIST			;GET IMP STATUS
	MOV	#20,R0			;'IMP DOWN' CODE IN R0
	TST	R1			;CHK RETRN CODE
	BNE	1$			;IMP IS DOWN
	DEC	R0			;ELSE ADJUST ID TO IMP UP
1$:	JSR	PC,ASYMSG		;PRINT THE MSG
	$EPSET	#CTLCE			;TURN ON CTL-C
	$POP	R1,R0			;RESTORE REGISTERS
	RTS	PC			;AND RETURN
	.PAGE
	.SBTTL
	.SBTTL	TELNET UTILITY
	.SBTTL	CLS - CLOSE A CONNECTION PAIR

;	R0 - HOST # (0 => 'CLOSE ALL CONNECTIONS')
;	R1 - SUPPRESS PRINTOUT IF '0'
;	R2 - TCT ADR

$CLS:	$PUSH	R1,R0			;SAVE REGISTERS
	$EPSET	#CTLCD			;TURNOFF CTL-C
	CLRB	TCTSTA(R2)		;INDICATE NO REASGN
10$:	$TSTQ				;FLUSH Q
	BEQ	20$			;ITS EMPTY
	$WAIT				;GET AN MQE
	BR	10$			;GET ANOTHER
20$:	$GAPID				;GET ACTV PROC ID
	CMPB	R0,TCTMPI(R2)		;SAME AS TNET SND PROC?
	BEQ	30$			;YES
	MOVB	#200,TCTSTA(R2)		;NO INDICATE REASSGN
	MOVB	R0,TCTMPI(R2)		;SET PID CODE TO NEW PROC
30$:	$POP	R0			;RECOVER HOST ID
	JSR	PC,CONCHK		;CHK THE CONNECTIONS
	BNE	CLOX			;NONE, ELSE SND/RCV TCCTS IN R3/R4
	CLR	R5			;CURRENTLY NO ACTV CLOSES
	MOV	R3,R0			;TCCT ADR TO R0
	JSR	PC,CHKCLS		;CHK IF CLOSED
	BEQ	1$			;YES IT ALRDY IS
	BIS	#100000,R5		;ACTV SEND CLOSE
	TST	(R0)+			;COMPUTE CCT ADR
	TSTB	TCTSTA(R2)		;REASSGN?
	BEQ	40$			;NO
	$PUSH	R0			;YES SAVE CCT ADR
	MOV	R0,R1			;CCT ADR IN R1
	MOVB	TCTMPI(R2),TCCPID(R3)	;SET NEW PID IN SND CCT
	$NPSET	#NPASSG			;REASSIGN CONNECTION
	$POP	R0			;RESTORE CCT ADR
40$:	$N.CLS	R0			;CLOSE IT
1$:	MOV	R4,R0			;RCV TCCT ADR IN R0
	JSR	PC,CHKCLS		;CHK IT
	BEQ	2$			;CLOSED
	MOVB	TCTMPI(R2),TCCOPC+1(R4)	;ASGN RCV CONN TO PRIM PROC
	MOV	R4,R1			;TCCT ADR
	TST	(R1)+			;CCT ADR
	$NPSET	#NPASSG			;ASSIGN CONN FOR CLSNG
	MOV	R4,R0			;TCCT ADR BACK IN R0
	BIS	#200,R5			;IDICATE ACTV RCV CLOSE
	TST	(R0)+			;COMPUTE CCT ADR
	$N.CLS	R0			;CLOSE RCV CONN
2$:	TST	R5			;ANY CLOSES IN PROGRESS
	BEQ	CLOX			;NO QUIT NOW
	$STIME	#TIME,#30000.		;SET TIMER TO 30 SECONDS

CLWT:	$DSCHD				;WAIT FOR SOMETHING NEW
	TST	R5			;ACTV SND CLS?
	BPL	1$			;NO
	$TSTQS	#COS			;YES IS IT THERE
	BNE	SCLS			;YES IT IS
1$:	TSTB	R5			;ACTV RCV CLS
	BPL	2$			;NO
	$TSTQS	#COR			;ELSE CHK FOR IT
	BNE	RCLS			;ITS HERE
2$:	$TSTQS	#TIME			;TIME UP?
	BEQ	CLWT			;NOT YET
	BR	TCLS			;CLOSE TIMED OUT
	.PAGE
	.SBTTL	CLS - CLOSE COMPLETE


;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCC ADR
;	R5 - ACT RCV/SND CLOSE FLAGS

;SEND CONN CLOSED
SCLS:	MOV	#COS,R0			;OP CODE IN R0
	$PUSH	R3			;TCCT ADR ON STACK
	JSR	PC,CCLS			;CMPLT CLOSE
	BIC	#100000,R5		;INDICATE NO ACTV SND CLS
	BEQ	CLOX			;ALL DONE
	BR	CLWT			;ELSE WAIT FOR RCV SIDE

;RECEIVE CONN CLOSED
RCLS:	MOV	#COR,R0			;OP CODE IN R0
	$PUSH	R4			;TCCT ADR ON STACK
	JSR	PC,CCLS			;COMPLETE CLOSE
	BIC	#200,R5			;NO LONGER ACTV RCV CLS
	BEQ	CLOX			;ALL DONE
	BR	CLWT			;ELSE WAIT FOR SEND SIDE

	.PAGE
	.SBTTL	CLS - CLOSE TIMED OUT

;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR
;	R5 - ACTV CLOSE FLAGS
;	(SP)- PRINT FLAG IF NON-ZERO

;CLOSE TIMED OUT
TCLS:	$WAITS	#TIME			;GET THE MQE
	TST	(SP)			;MSG SUPPRESSION?
	BEQ	1$			;YES
	MOV	#16,R0			;'CLOSE TIMED OUT'
	JSR	PC,ASYMSG		;SAY IT
1$:	CLR	(SP)			;NO MORE PRINTOUT
	TST	R5			;CHK ACTV CLOSES
	BEQ	CLOX			;QUIT IF NONE
	BPL	2$			;NO ACTV SND
	MOV	R3,R0			;TCCT ADR
	TST	(R0)+			;CCT ADR
	$N.CLS	R0			;CLOSE IT FOR THE NCP CLNUP
	$N.CLS	R0			;3X TO BE SAFE
2$:	TSTB	R5			;ACTV RCV CLS
	BPL	CLOX			;NO, EXIT
	MOV	R4,R0			;RCV TCCT ADR
	TST	(R0)+			;RCV CCT ADR
	$N.CLS	R0			;CLOSE IT
	$N.CLS	R0			;3X TO BE SAFE
					;AND EXIT THRU CLOX

	.PAGE
	.SBTTL	CLS - CLOSE EXIT


;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR
;	(SP) - PRINT FLAG IF NOT 0

;CLOSE COMPLETE
CLOX:	TST	(SP)			;MSG SUPPRESSION?
	BEQ	1$			;YES
	MOV	#15,R0			;'CLOSE COMPLETE'
	JSR	PC,ASYMSG		;SAY IT
1$:	$STIME	#TIME,#1		;TURN OFF TIMER
	$WAITS	#TIME			;WAIT FOR IT
	$PUSH	R2			;SAVE TCT ADR
	MOV	#TCCLEN*2,R0		;# BYTES FOR TCCT PAIR
	CLR	R1			;VSM ID
	MOV	R4,R2			;ADR
	BEQ	10$			;NO BUFF ALLOCATED
	$FVS	R0,R1,R2		;RELEASE THE TCCTS
10$:	$POP	R2			;RECOVER TCCT ADR
	CLR	TCTRCV(R2)		;CLR RCV PTR
	CLR	TCTSND(R2)		;CLR SND PTR
	TSTB	TCTSTA(R2)		;REASSGND?
	BMI	4$			;YES
2$:	$TSTQ				;FLUSH THE Q
	BEQ	3$			;DONE
	$WAIT				;PULL ONE OFF
	BR	2$			;LOOK FOR MORE
3$:	$SIGNL	TCTSPI(R2),#STRT,#0	;TELL RCV PROC TO FLUSH Q
	$WAITS	#STPACK			;WAIT FOR IT
4$:	CLRB	TCTSTA(R2)		;CLR STATUS OF TELNET CONN
	CLR	TCTSC(R2)		;CLR SYNC CNT & CMD NDX
	CLR	TCTSCT(R2)		;CLR SRC AND DSTN CNTS
	CLR	TCTDCT(R2)
	$EPSET	#CTLCE			;TURN ON CTL C
	TST	(SP)+			;RESTORE STACK
	RTS	PC			;AND RETURN
	.PAGE
	.SBTTL	CLS - CLOSE UTILITIES


;	R0 - ACTV TCCT ADR
;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCCT ADR


;CHK IF CONN CLOSED,  YES IF Z=1
CHKCLS:	CLR	R1			;GET RDY FOR BYTE
	MOVB	TCCSTA(R0),R1		;GET CONN STATUS
	BIC	#177600,R1		;W/O MISC
	BEQ	1$			;NRML STAT => OPEN
	CMPB	#WCCIST-200,R1		;CHK AGAINST UPPER LIMIT
	BLE	1$			;INFO+SYNC => OPEN
	SEZ				;ERR => CLOSED
	RTS	PC			;RETURN
1$:	CLZ				;SET FLAG TO OPEN
	RTS	PC			;AND RETURN


;	R0 - CONN OP-CODE
;	R2 - TCT ADR
;	R3 - SND TCCT ADR
;	R4 - RCV TCC ADR
;	R5 - ACT CLS FLAGS
;	(SP) - RETRN ADR
;	2(SP) - CURRENT TCCT ADR
;	4(SP) - PRINT FLAG IF NOT 0

;COMPLETE THE CLOSE CHK
CCLS:	$WAITS	R0			;GET THE CONN MQE
	MOV	2(SP),R1		;GET CURR TCCT ADR
	MOVB	TCCSTA(R1),R0		;GET CONN STATUS
	BIC	#177600,R0		;W/O MISC
	BEQ	2$			;OK
	CMP	#WCCCLS-200,R0		;CONNECTION CLOSED?
	BEQ	2$			;YES EXIT
	CMP	#WCCIST-200,R0		;CHK AGAINST LIMIT
	BLE	2$			;OK
	TST	4(SP)			;ERR, CHK IF PRINTABLE
	BEQ	2$			;NO
	$PUSH	R5			;ELSE SAVE FLAGS
	JSR	PC,ASYMSG		;PRINT THE MSG
	$POP	R5			;RESTORE THE FLAGS
	CLR	4(SP)			;CLR PRINT FLAG
2$:	MOV	(SP),2(SP)		;MOVE RETRN OVER ARG
	TST	(SP)+			;PULL OFF REDUNDANT RETRN
	RTS	PC			;RETURN
	.END
  