




                






                       ELF KERNEL PROGRAMMER'S GUIDE




                               April 1,  1974












                                D. L. Retz
                               J. R. Miller
                               J. L. McClurg
                               B. W. Schafer










                 Speech Communications Research Lab., Inc.
                           800-A Miramonte Drive
                      Santa Barbara, California 93109
                               (805) 965-3011






        This work is supported by the Advanced Research Projects Agency,
        through  Contract  No.   N00014-73-C-0221,  administered  by the
        Office of Naval Research.

        ELF KERNEL PROGRAMMER'S GUIDE                    Page   2



                       ELF KERNEL PROGRAMMER'S GUIDE

                                  CONTENTS



        Section         Title                                   Page



                        Table of Contents - Figures  . . . . . .   4

                        Table of Contents - Tables . . . . . . .   6



        I               Organization of the ELF System . . . . .   7



        II              The ELF Kernel - An Introduction . . . .   9

        II.1            Processor Management Techniques  . . . .   9

        II.1.1          Process Synchronization  . . . . . . . .   9

        II.1.2          Processor Scheduling . . . . . . . . . .  10

        II.1.3          Protection Mechanisms  . . . . . . . . .  10

        II.1.4          Resource Allocation Techniques . . . . .  10

        II.2            Storage Management Techniques  . . . . .  12

        II.2.1          Control Tables for Storage Management  .  13

        II.2.1.1        The Physical Storage Table (PST) . . . .  13

        II.2.1.2        The Virtual Storage Map (VSM)  . . . . .  15

        II.3            The ELF I/O System . . . . . . . . . . .  16

        II.3.1          I/O Primitives for ELF Processes . . . .  18



        III             Writing I/O Drivers for ELF  . . . . . .  22

        III.1           Primary Tasks of Device Drivers  . . . .  22

        III.1.1         Device Initialize. . . . . . . . . . . .  22


        ELF KERNEL PROGRAMMER'S GUIDE                    Page   3
        CONTENTS


        III.1.2         Transfer Initialize  . . . . . . . . . .  22

        III.1.3         Interrupts . . . . . . . . . . . . . . .  23

        III.2           Register Usage . . . . . . . . . . . . .  24

        III.3           Error Codes  . . . . . . . . . . . . . .  24

        III.4           Assembly . . . . . . . . . . . . . . . .  24



        IV              ELF Kernel Primitives  . . . . . . . . .  25

                        ELF Kernel Primitives, Index . . . . . .  85

        V               ELF System Tables and Data Structures  .  88

        V.1             DCT - Device Control Table . . . . . . .  88

        V.2             ICT - Interrupt Control Table  . . . . . 100

        V.3             IORB - I/O Request Block . . . . . . . . 102

        V.4             IORQE - I/O Request Queue Element  . . . 105

        V.5             DCTNT - Device Name Table  . . . . . . . 108

        V.6             DCTUT - Device Unit Table  . . . . . . . 109

        V.7             DCTCT - Device Channel Table . . . . . . 110

        V.8             DCTVT - DCT Vector Table . . . . . . . . 111

        V.9             ICTVT - ICT Vector Table . . . . . . . . 112



        VI              Kernel Process Error Codes . . . . . . . 118



                        Appendix A . . . . . . . . . . . . . . . 121


        ELF KERNEL PROGRAMMER'S GUIDE                    Page   4
        CONTENTS


                                  FIGURES





        Number          Title                                   Page



           1            PST0 . . . . . . . . . . . . . . . . . .  13

           2            Virtual Storage Map  . . . . . . . . . .  15

           3            IORB . . . . . . . . . . . . . . . . . .  19

           4            Caller's Stack . . . . . . . . . . . . .  78

           5            Kernel Stack . . . . . . . . . . . . . .  79

           6            Character Out DCT  . . . . . . . . . . .  93,94

           7            Character In DCT . . . . . . . . . . . .  95,96

           8            Block/Byte Addressable DCT . . . . . . .  97,98

           9            Inter-Process Port DCTs  . . . . . . . .  99

          10            Interrupt Control Table  . . . . . . . . 101

          11            IORB I/O Request Block . . . . . . . . . 104

          12            IORQE I/O Request Queue Element  . . . . 107

          13            Device Name Table  . . . . . . . . . . . 108

          14            Device Unit Table  . . . . . . . . . . . 109

          15            Device Channel Table . . . . . . . . . . 110

          16            DCT Vector Table . . . . . . . . . . . . 111

          17            ICT Vector Table . . . . . . . . . . . . 112

          18            Process Message Queue Elements . . . . . 113

          19            Free Semaphore Elements  . . . . . . . . 113

          20            Semaphore Storage Allocation . . . . . . 114

          21            Semaphore ID . . . . . . . . . . . . . . 114


        ELF KERNEL PROGRAMMER'S GUIDE                    Page   5
        CONTENTS


          22            Timer Queue Element  . . . . . . . . . . 115

          23            Process Ready Queue  . . . . . . . . . . 115

          24            Process Control Table  . . . . . . . . . 116

          25            Process Control Table, Kernel

                          Stack Formats  . . . . . . . . . . . . 117



          A1            Page Address Register  . . . . . . . . . 121

          A2            Page Descriptor Register . . . . . . . . 121

          A3            Format of Status Register #0 (SR0)  . . 122

          A4            Format of Status Register #2 (SR2)  . . 123

          A5            Page Description Register  . . . . . . . 123

          A6            Format of Status Register #0 (SR0)  . . 124

          A7            Format of Status Register #1 (SR1)  . . 124

          A8            Format of Status Register #3 (SR3)  . . 125


        ELF KERNEL PROGRAMMER'S GUIDE                    Page   6
        CONTENTS


                                   TABLES





        Number          Title                                   Page



          A1            PAR/PDR Address Assignments  . . . . . . 121

          A2            Access Control Field Keys  . . . . . . . 122


        ELF KERNEL PROGRAMMER'S GUIDE                    Page   7
        ELF System Structure


        I  Organization of the ELF System


             The ELF system has a hierarchical structure.  At the center
        of  the system exists a set of modules, collectively referred to
        as the kernel, which perform tasks of resource management  in  a
        multi-processing  environment.   The  kernel  provides  a set of
        primitive calls  for  outer-level  procedures,  performing  such
        tasks  as  the  creation  of processes, process synchronization,
        storage allocation, and sharing of an interval timer.

             System Procedures outside of the kernel perform tasks  such
        as  the interpretation of user requests at terminals (the EXEC),
        controlling communication with the ARPANET (the Network  Control
        Program), and maintenance of the system file structure.

             Kernel  primitives  fall  in  three  categories:  Processor
        Management,  Storage  Management,  and  Input/Output Management.
        Processor management primitives allow processes to  be  created,
        vie  for  processor service, intercommunicate, or be terminated.
        Storage Management Primitives control the allocation of  storage
        within  an  address  space;  when  the  PDP-11 memory management
        option is present, storage  management  primitives  control  the
        mapping  between  a process' address space and physical storage.
        In this case, storage management primitives allow  the  creation
        of a set of virtual address spaces, and perform tasks of storage
        allocation within each address space.   Input/Output  primitives
        control   the  management  of  I/O  devices,  scheduling  device
        requests performed by  calling  processes,  and  performing  the
        address-mapping   tasks   necessary  when  the  virtual  storage
        capability is present.

             Kernel procedures  reside  in  a  fixed  area  of  physical
        storage,  and  are  distinguished  by  the  fact that the PDP-11
        processor runs in privileged, or  "kernel"  mode  (on  11/40  or
        /45).    This   provides   a   protection  scheme,  under  which
        outer-level procedures may be debugged  without  destroying  the
        ELF environment.

             The EXEC consists of  a  set  of  modules  which  interpret
        commands  received  from  user's  terminals,  and allow users to
        access facilities available  on  the  network.   If  the  memory
        management  option is installed, the EXEC procedures reside in a
        unique address space.  Additional EXEC  commands  then  allow  a
        user  to create a new address space, cause programs to be loaded
        into the address space from a server on the network, and start a
        local process within that address space.

             The Network Control Program (NCP) allows processes  running
        in  the  ELF system to establish data-paths, or "connections" to
        processes running in local or remote processors on the  network.
        The NCP provides the set of "third-level" protocol primitives to
        local processes,  such  as  CONNECT,  LISTEN,  CLOSE,  etc.   In

        ELF KERNEL PROGRAMMER'S GUIDE                    Page   8
        ELF System Structure


        addition  to these, local processes may make calls to the NCP to
        follow  the  standard  Server-  or  User-   Initial   Connection
        Protocol.

             The storage management facilities which are included in the
        kernel,   coupled  with  PDP  11/40  or  /45  memory  management
        hardware, make possible  the  addition  of  new  facilities  for
        checkout  of  programs within the system framework.  This is the
        means by which higher-level network protocols may be  developed,
        or  supervisory  tasks  of  peripheral  signal processors may be
        performed, in  a  way  which  allows  effective  utilization  of
        network resources.

             The ELF system is written in  MACRO-11  Assembly  language.
        The  system  is  composed  of  a number of logically independent
        modules, which are separately  compiled  and  bound  to  form  a
        single  loadable  file.  Support software for system development
        exists at various PDP-10 sites on  the  ARPANET.   Compatibility
        exists  for  using  various  other  languages,  such  as BCPL or
        BLISS-11, in making extensions of the system.

             Hardware required for the ELF varies, according to  desired
        system  capability.  The minimal amount necessary to support the
        ELF kernel and NCP is 12K.  For terminal access to the net,  and
        the  ability  to  obtain  listings  (provided  a line-printer is
        attached) 16K is required.   Either  of  these  tasks  would  be
        adequately supported by a PDP-11/10, or larger, processor.

             Additional system flexibility is gained when the  processor
        is  a  PDP-11/40  or  /45 with the memory management option.  In
        this configuration, it is recommended that the system  have  32K
        of memory.  The existence of secondary storage on the ELF is not
        a basic requirement.  It is useful in the case of systems having
        virtual  storage, to allow automatic swapping of pages from main
        storage.  It should be emphasized  that  the  presence  of  disk
        storage  is  not  mandatory  in virtually addressed systems; the
        lack of secondary storage simply prevents automatic  replacement
        of  pages  in  main storage, while the protection and relocation
        features of the memory management hardware are still utilized.

             I/O devices supported under the  ELF  system  are  Dectape,
        fixed-head disk (RF-11), removable cartridge and disk pack (RK05
        and RP03), DEC line printers, and the various  line  controllers
        and multiplexers.  

        ELF KERNEL PROGRAMMER'S GUIDE                    Page   9
        ELF KERNEL -- INTRODUCTION


        II  The ELF Kernel -- An Introduction

             This chapter describes the portion of the ELF system  which
        performs  resource  management  tasks  necessary  to  support  a
        multiprocessing environment.  This section, referred to  as  the
        kernel,  concerns itself with three primary areas.  The first of
        these, Processor Management, controls distribution of the PDP-11
        processor  among  a  number  of processes, and provides means by
        which processes may synchronize  and  allocate  resources.   The
        second  major portion of the kernel is Storage Management, which
        handles the allocaton of primary, secondary, and virtual storage
        available  to  processes  in the system.  The third portion, I/O
        Management,  controls  the  interaction  between  processes  and
        external  devices (I/O devices), and additionally provides means
        for communication of data between processes.


        II.1  Processor Management Techniques

             The kernel provides a set of system calls, or "primitives",
        which  allow  processes to be created, vie for processor service
        according to priority,  inter-communicate,  and  be  terminated.
        The  term  process used here describes an autonomous sequence of
        states brought about  by  the  PDP-11  processor.   In  the  ELF
        system, a process is characterized by a virtual program-counter,
        a set of general-purpose registers, a stack,  and  process-owned
        storage  areas.  Processes are given control of the processor by
        a single controlling program, called the  scheduler.   Processes
        are  said  to  be  in  a  "ready"  or "waiting" state.  They are
        created  in  the  ready  state,  and  remain  ready  until  they
        explicitly  block  themselves  by calling a system primitive for
        synchronization or resource allocation.


        II.1.1  Process Synchronization

             Each system process has an associated  input  queue,  which
        consists  of a list of "messages" sent to it by other processes.
        A "message" in this case is a 24-bit field which is fetched from
        the  input  queue  when  the process WAITs, and is placed on its
        input queue by some  other  process  which  invokes  the  SIGNAL
        primitive.   The  process  may be thus viewed as a machine which
        interprets instructions fetched by means of the WAIT  primitive.
        Processes  enter  the waiting state if they WAIT and their input
        queue is empty; they enter the ready  state  when  an  entry  is
        placed on their input queue by the SIGNAL primitive.

             When a process awakens, it receives the 24-bit  message  in
        addition  to  the  8-bit  name (process ID) of the process which
        SIGNALled  it.   In  general,  the  24-bit  message   field   is
        interpreted  by  ELF  system processes as an 8-bit op-code and a
        16-bit  data  field.   While  this  assignment  of  bits  is   a
        convention  for  system processes, higher-level (user) processes

        ELF KERNEL PROGRAMMER'S GUIDE                    Page  10
        ELF KERNEL -- INTRODUCTION


        which choose to inter-communicate using SIGNAL and WAIT may  use
        this field arbitrarily.


        II.1.2  Processor Scheduling

             Internal system tables reflect the state of a process,  and
        control  its  priority  for processor service, relative to other
        processes in the system.  The  ability  of  a  process  to  gain
        control  of the processor is a function of the priority queue in
        which is runs, and its order within that  queue.   The  priority
        queue  in  which  the  process  resides  is determined when that
        process is created.  The priority of a process within its  queue
        is determined according to its behavior; it is re-evaluated at a
        regular interval, and its value is inversely proportional to the
        demand  made  by  the  process  for  processor  service over the
        interval.


        II.1.3  Protection Mechanisms

             Because processes rely on the validity of messages received
        on  their  input  queues,  a  protection  scheme  is required to
        prevent   processes   from   receiving   messages   from   other
        non-authorized  processes.   This  mechanism  is  implemented by
        means  of  a  ring  structure,  in  which  each  process  has  a
        "capability  level",  determined  as  a  function of its current
        processor mode (i.e., kernel/user)  and  a  capability  variable
        associated   with  the  process.   The  capability  variable  is
        assigned when the process is created,  and  may  change  as  the
        process  makes  calls  to  various  procedures  in the operating
        system.  The "capability level" of the process evaluates to 0 if
        the process is in kernel mode, or to the value of its capability
        variable if in user  mode.   The  access  rights  of  a  process
        executing  at  a  given  capability level are a subset of rights
        given at lower levels.


        II.1.4  Resource Allocation Techniques

             Processes request allocation of system resources  by  means
        of   binary   semaphores.    Kernel   primitives  allow  dynamic
        assignment of semaphore names, and provide Dijkstra's  P  and  V
        operations  on  those  semaphores.  The P primitive is used by a
        process to obtain ownership of a resource, which  is  identified
        by  a  specified semaphore name (an 8-bit code).  The process is
        placed in a waiting state  in  the  event  that  it  requests  a
        resource  which is owned by another process; it awakens when the
        other process relinquishes  the  resource  by  means  of  the  V
        primitive.   When  a  process  remains waiting for the resource,
        other processes may place event descriptors on its input  queue;
        the process may fetch the queued messages from its queue once it
        obtains ownership of the resource.

        ELF KERNEL PROGRAMMER'S GUIDE                    Page  11
        ELF KERNEL -- INTRODUCTION


             Two  additional  primitives  exist   for   utilization   of
        semaphores.   A process may request notification of ownership of
        a resource by means of the REQUEST primitive.  The  process,  in
        this  case, specifies a 24-bit message it wishes to receive when
        the  resource  is  obtained.   This  primitive  allows   various
        permutations  on  Dijkstra's P primitive (such as Multiple-P) to
        be constructed.  A second primitive, referred to as Exhaustive V
        (EXV),  effectively V's a semaphore until there are no processes
        queued on the semaphore wait-list.  This primitive  is  utilized
        in  cases  when semaphores are used for notification of a set of
        processes that a specified event has occurred (such as a process
        termination);  it  is usually the case that these processes have
        REQuested such information.

        ELF KERNEL PROGRAMMER'S GUIDE                    Page  12
        ELF STORAGE MANAGEMENT TECHNIQUES


        II.2  Storage Management Techniques

             Based on the PDP-11's 16 bit architecture,  a  process  may
        generate   references   to  a  possible  32,768  different  word
        addresses  in  memory.   Because  there  is  not  necessarily  a
        one-to-one  correspondence  between these addresses and physical
        storage addresses, we say that the  process  has  an  associated
        32,768-word  virtual  address space.  An address map defines the
        relation between the user's virtual storage and physical storage
        (e.g.,  core,  disk)  addresses.  A specific address map becomes
        associated with a process when  the  process  is  created.   The
        address  map  currently  in  use  is  determined  by the current
        processor mode  (kernel  or  user)  and  the  process  currently
        running.   Any  number  of  address  spaces  may  be defined for
        processes running in user mode; there is only one address  space
        defined in kernel mode, and this is utilized for system (kernel)
        primitives.

             The processor switches from kernel mode to user  mode  when
        it  gives control to a user process.  It switches from user mode
        to kernel mode when a user process makes a  system  call  or  is
        interrupted.

             If a user process is the "sole owner" of  an  address  map,
        then  its  address space is protected from modification by other
        processes.  Likewise, it may not  modify  physical  storage  not
        contained in its own address space.  When a process makes a call
        to a system primitive, the  system  performs  some  task  as  an
        extension  of  that  process.  Addresses are mapped according to
        the user's address map while the user's program is running,  and
        are  mapped according to the kernel address map when the program
        makes  a  kernel  primitive  call.   It   is   the   scheduler's
        responsibility  to  set  up the hardware registers in the PDP-11
        memory management unit according to the process' storage map.

             Processes may share a common virtual address space (address
        map);  the  address  map  to  be  associated  with  a process is
        assigned when the process is created.  (Processes may thus share
        virtual storage in the same fashion as they might share physical
        storage.)

             This  section  describes  techniques   used   for   storage
        allocation   in   ELF   systems,  and  particularly  deals  with
        establishment of a virtual storage structure for multiprocessing
        in   the   PDP-11/40  and  PDP-11/45  systems  with  the  memory
        management option.  The storage management portion  of  the  ELF
        kernel   allows   the   creation  of  a  number  of  independent
        32,768-word virtual address spaces,  and  controls  the  mapping
        between virtual storage addresses and physical storage addesses.
        Storage is divided into 4096-word pages, and the  PDP-11  memory
        management  unit  is  used to perform dynamic relocation of page
        addresses.  The mapping between  virtual  and  physical  address
        spaces  is transparent to processes in the system; thus, storage

        ELF KERNEL PROGRAMMER'S GUIDE                    Page  13
        ELF STORAGE MANAGEMENT TECHNIQUES


        accessed by processes in differing address spaces is  completely
        protected.

        II.2.1  Control Tables for Storage Management

             Two types of tables  are  used  in  providing  the  virtual
        storage  structure.   The  first of these is called the Physical
        Storage Table (PST), and reflects the state of physical  memory.
        The  second is referred to as a Virtual Storage Map (VSM); a VSM
        describes the state of each virtual address space.

        II.2.1.1  The Physical Storage Table (PST)

             The PST is used to indicate the  status  of  each  physical
        page  frame  in  core.  (Pages are 4096 words in length).  It is
        composed of three sub-tables: PST0,  PST1,  and  PST2;  each  is
        indexed   by   a   page   frame   number   in  physical  memory.
        (Essentially, this is identical to  a  single  table  of  3-word
        entries.)  Each  entry  in  PST0,  PST1, and PST2 is one word in
        length; the tables are physically contiguous, and resident in  a
        locked page in kernel space.

                         1    7   1    7
                        +-----------------+
        PST0:  Page 0   !W! Lock !A!  Age !
                        !-----------------!
                    1   !                 !
                        !-       .       -!
                    2   !        .        !
                        !-       .       -!
                    3   !        .        !
                        !-       .       -!
                    4   !        .        !   PST0  Format,
                        !-       .       -!
                    5   !        .        !   48K Configuration
                        !-       .       -!
                    6   !        .        !   (12 Page frames
                        !-       .       -!    of main storage.)
                    7   !        .        !
                        !-       .       -!
                    8   !        .        !
                        !-       .       -!
                    9   !        .        !
                        !-       .       -!
                    10  !        .        !
                        !-       V       -!
                    11  !                 !
                        +-----------------+



                        Figure 1.  PST0 Format

        ELF KERNEL PROGRAMMER'S GUIDE                    Page  14
        ELF STORAGE MANAGEMENT TECHNIQUES


        PST0 Entry Description:

             "W", (Bit 15), when set, indicates that the page frame  has
        been  modified.   If  the  page  is  to  be  purged from primary
        storage, the "W"-bit is tested to determine if the page  has  to
        be written on secondary storage.

             "Lock", (Bits 14-8), is a count specifying  the  number  of
        processes  currently requesting that this page be locked in core
        (not swapped out).  This is incremented by system routines  when
        they perform functions, such as I/O, which require that the page
        remain  resident.   The  "Lock"   count   is   incremented   and
        decremented   by   the  system  primitives  $LOCK  and  $UNLOCK,
        respectively.

             "A", (Bit 7) when set,  indicates  that  the  corresponding
        page  has  been  accessed.   It  is used at certain intervals to
        update the "Age" field, described below.

             "Age", (Bits 6-0), is a 7-bit  field  specifying  the  page
        age,  as  determined  by the system memory management algorithm.
        The page in memory with the minimum "Age" value is the one to be
        chosen to be purged from memory when necessary.

             PST1 reflects the utilization  of  physical  storage.   The
        high-order  ("F")  bit of each entry indicates that the physical
        page frame is free (not  occupied  by  a  virtual  page).   Thus
        memory  management  primitives test for negative entries in PST1
        to find an unused page.  When the "F" bit is zero, the low-order
        11  bits  contain  a virtual page address (VPA).  A virtual page
        address consists of a 3-bit page  number  and  an  8-bit  number
        which uniquely identifies a Virtual Storage Map (address space).
        Virtual Storage Maps are described in the next section.

             PST2  indicates   the   correspondence   between   physical
        (primary)  storage  and  secondary  storage.   When  a  page  is
        resident in memory, PST2 contains the secondary storage  address
        to be used when the page is to be removed from memory.

        ELF KERNEL PROGRAMMER'S GUIDE                    Page  15
        ELF STORAGE MANAGEMENT TECHNIQUES


        II.2.1.2  The Virtual Storage Map (VSM)

             A Virtual Storage Map defines the  relationship  between  a
        32K  virtual  address  space  and  its  utilization  of physical
        storage.  The VSM consists of two 8-word tables, each  of  which
        is  indexed  by  the  high  order  3  bits  of a virtual address
        generated  by  a  process.   (Thus,  each  entry  in  the  table
        corresponds  to  a  4096-word  page  in  the 32,768-word virtual
        address space.) The first 8-word table in the VSM describes  the
        correspondence  between  virtual  storage  and  primary  storage
        (core), and also reflects the status of  each  page  (e.g.,  its
        residency).     The    second   8-word   table   describes   the
        correspondence between virtual storage  and  secondary  storage.
        Each Virtual Storage Map (hence, each address space) is named by
        an 8-bit identifier, called the VSM ID.  Thus, a virtual address
        in  the  system  formally consists of a 24-bit number containing
        the 8-bit address space name (VSM ID), a 3-bit page number,  and
        a 13-bit offset within a page.


        ;PST0:  ! W!<-------LOCK------->!AC!<-------AGE-------->!
        ;       !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !
        ;PST1:  !AV! I!XX!XX!XX!  PG #  !      VSM   ID      !  !
        ;       !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !
        ;PST2   ! S! R!     FILE ID     !      SEC  PG  #       !


        ;VSM0   ! R! D! L! A! W!XX!XX!XX!XX!XX!     PST NDX     !
        ;       !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !
        ;VSM1   ! S! R!     FILE ID     !      SEC  PG  #       !
          L=0(SSA)
        ;       !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !
        ;VSM1   !XX!XX!XX!XX!XX!  PG #  !        VSM  ID        !
          L=1 (VPA)

        ;DEFINITIONS
        ;       VSM                             PST
        ;       ---                             ---
        ;
        ;R - Resident                    ;W - Written
        ;D - Defined in Virtual          ;AC - Accessed
        ;    Address Space
        ;L - Share Link                  ;AV - Available
        ;A - Allocated on                ;I  - I/O in Progress
        ;    Secondary Storage
        ;W - Working Set Member          ;S  - Sharable
        ;S - Sharable                    ;R  - Read Only
        ;R - Read Only                   ;XX - Unused
        ;XX - Unused


                       Figure 2.  Virtual Storage Map

        ELF KERNEL PROGRAMMER'S GUIDE                    Page  16
        ELF STORAGE MANAGEMENT TECHNIQUES


        II.3 The ELF I/O System

             The ELF  I/O  system  provides  an  interface  between  ELF
        programs  (processes)  and  external devices, such as terminals,
        disks,  line  printers,  etc.   The  I/O  system  performs   the
        following functions:

         1.  Coordinates requests for physical I/O transactions among  a
             set of ELF system processes, synchronizing the I/O requests
             with external devices.
         2.  Provides device independence, allowing processes to  select
             a specific device by means of a "device-address".
         3.  Performs  translation  necessary  in  virtual  memory   ELF
             systems   between  virtual  and  physical  storage  address
             spaces.

             ELF processes request physical I/O transactions by means of
        a  single  system primitive, Start-I/O.  The primary function of
        Start-I/O (SIO) is to enqueue a request specifying a transfer of
        data between a virtual storage address and a device address.  In
        addition, the SIO primitive allows the  transfer  of  data  thru
        pseudo-devices,  called  "ports",  which  facilitate transfer of
        data between processes (inter-process communication).

             When a program requests an I/O transaction by means of SIO,
        it  uses  a  control table called an I/O Request Block (IORB) to
        specify all parameters and addresses needed  to  carry  out  the
        request.   While  the  SIO  primitive makes requests for a given
        device,  the  requests  are  carried  out  according  to  device
        availability.  It is the responsibility of kernel I/O management
        processes to fetch entries from various device  request  queues,
        and  initiate  device  actions as devices become ready.  The I/O
        Executive or IOX  performs  all  necessary  translation  between
        virtual  and physical storage address space, and initiate device
        action   by   calling    special-purpose    procedures    called
        "device-drivers".

             Device drivers perform functions relating to  a  particular
        type  of  device.   A  device  driver must exist for each device
        which has unique programming characteristics, although more than
        one  device  of  the same type is usually controlled by a single
        I/O device driver procedure (for example, a terminal driver  may
        control 16 terminals).

             ELF devices  are  assigned  names,  or  "device  addresses"
        consisting  of  a  generic  name and a unit number.  The generic
        name consists of 3 characters packed in RAD50  format;  examples
        are  TTY,  IMP,  MTA,  DTA  etc.   The unit number consists of a
        16-bit unsigned integer.

             All information relating to a particular device address  is
        centrally  located  in  a system table called the Device Control
        Table, or DCT.  The DCT allows complete separation of procedures

        ELF KERNEL PROGRAMMER'S GUIDE                    Page  17
        ELF I/O SYSTEM -- INTRODUCTION


        handling devices and data relating to those devices.  DCT's have
        varying formats, depending on a distinction of  device  classes.
        Classes  are  assigned  to  character-at-a-time devices (such as
        terminals), byte-addressable Direct Memory Access devices  (such
        as  fixed-head  disks),  block  addressable DMA devices (such as
        moving-head disks), and inter-process ports.  

             A  second  system  control  table  is   used   to   contain
        information  relevant to specific device interupts.  This table,
        called the Interrupt Control Table (ICT), contains  the  address
        of  the  interrupt  vector  and the address of the corresponding
        interrupt service routine.  Each of these tables is  defined  by
        system macro calls, which provide a set of names for the various
        fields contained in the control tables.

             An I/O device is added to the ELF  system  by  defining  an
        appropriate  Device  Control Table, Interrupt Control Table, and
        Device Driver procedures.  The control  tables  are  defined  by
        means  of  macro  calls,  which  generate  proper table linkages
        according to specified macro  parameters.   Device  drivers  are
        linked  with  the set of modules which form the kernel.  Drivers
        are reentrant, and therefore are sharable by a  set  of  devices
        having equivalent characteristics.

             Each device in the  system  is  assigned  a  device  class,
        determined  by  the mode of data transfer between the device and
        main storage.  "Character" oriented devices  perform  I/O  on  a
        character-at-a-time  basis;  transfer  to this type of device is
        performed  under  control  of  the  PDP-11  processor   (usually
        referred  to  as  programmed  data transfer).  The device driver
        procedures are responsible for controlling the transfer of  data
        to or from the device.

             A second type of device is that which performs transfer  of
        data  to  or  from  main  storage  directly under device control
        (Direct Memory Access, or  DMA  devices).   In  this  case,  one
        device  driver procedure initiates a device action, and a second
        driver procedure (the interrupt handler) receives control on its
        completion.

             A third device class is the set  of  pseudo-devices  called
        "Inter-Process  Ports"  (IPP's)  which  facilitate inter-process
        communication.  Inter-Process Ports have  no  associated  device
        driver;  in  this  case,  data  transfers  are  controlled  by a
        specific I/O Auxiliary process.

             Each of the above device classes has  a  corresponding  I/O
        auxiliary  procedure.   The  primary  function of the system I/O
        Auxiliary process is to manage the mapping between I/O  requests
        and physical storage, allowing I/O requests to occur across page
        boundaries in a fashion which  is  transparent  to  the  caller.
        There exists one I/O auxiliary procedure per device class.

        ELF KERNEL PROGRAMMER'S GUIDE                    Page  18
        ELF I/O SYSTEM -- INTRODUCTION


             With the above overview in  mind,  the  following  material
        presents  a more detailed description of ELF I/O control tables,
        I/O driver procedures, and I/O primitives as they appear to user
        processes.



        II.3.1  I/O Primitives for ELF Processes


             The following describes the ELF I/O system as it appears to
        ELF processes.  The primitives for performing I/O-related tasks,
        and the necessary control tables for  communicating  information
        to the I/O primitives are discussed.

             ELF processes perform physical transfers of data to or from
        I/O  devices  by  means of the Start-I/O ($SIO) primitive.  $SIO
        places an I/O request on  a  request  queue  associated  with  a
        specified device, and returns control to its caller immediately.
        Parameters are passed to the Start-I/O primitive by means of  an
        I/O Request Block (IORB), shown below.  In the IORB, the process
        specifies a three-character RAD50 device  name,  a  device  unit
        number,  an  op-code  with  which  it  wishes to be signalled on
        completion, a buffer address, a function code, a byte count, and
        an  optional  device  byte  address  .  The I/O system returns a
        device status code and number of bytes actually transferred upon
        completion  of  the  operation.   When  the I/O request has been
        carried out, the  originating  process  is  signalled  with  the
        op-code  which  it  specified  when  the  request  was  made; in
        addition, the I/O system passes the address of an IORB  when  it
        signals  the  process.)  Then, for example, the process uses the
        op-code to determine that an I/O operation  has  completed,  and
        the IORB address specifies which request has completed.

        ELF KERNEL PROGRAMMER'S GUIDE                    Page  19
        ELF I/O SYSTEM -- INTRODUCTION


             The IORB is illustrated below:

                                           +----------------+
                IORB:                      !      NAME      !
                                           !----------------!
                                           !      UNIT      !
                                           !----------------!
                                           !  VSM   !   OP  !
                                           !----------------!
                                           !      ADDR      !
                                           !----------------!
                                           !      FUNC      !
                                           !----------------!
                                           !       BR       !
                                           !----------------!
                                           !      STAT      !
                                           !----------------!
                                           !       BX       !
                                           !----------------!
                                           !      BYTEH     !
                                           !----------------!
                                           !      BYTEL     !
                                           +----------------+


                              Figure 3.  IORB

        ELF KERNEL PROGRAMMER'S GUIDE                    Page  20
        ELF I/O SYSTEM -- INTRODUCTION


             NAME is the RAD50-coded name of the device,  such  as  TTY.
        The  UNIT   is  a  non-zero  binary  number  which  identifies a
        specific unit on a given device.  Thus, an  I/O  device  in  the
        system has a 32-bit name consisting of a device name/unit number
        pair.

             Each I/O device in ELF has  an  associated  request  queue;
        entries  are placed on the request queue when the process issues
        the $SIO primitive, and are removed as requests  are  satisfied.
        Thus  a process may make a number of requests, each specified by
        a unique IORB.

             The op-code field  specified  in  the  IORB  indicates  the
        op-code  with  which the process is to be signalled when the I/O
        operation completes.

             VSM is the 8-bit virtual  storage  map  identifier  of  the
        buffer to which I/O is to take place.  When the VSM is specified
        as 0, the VSM is taken to be that of the calling process' active
        VSM (current address space).  User processes using $S10 to carry
        out I/O operations should specify a VSM value of 0.

             ADDR is the address of a buffer to/from which data is to be
        transferred.

             FUNC is a 16-bit function code to indicate a  specific  I/O
        command,   such   as  read  or  write.   The  following  device-
        independent codes have been assigned:

               0  =  No operation
               1  =  Read
               2  =  Write
               3  =  Special Functions
               4  =  Write Check


             The low byte of the function word is  reserved  for  device
        independent   codes;   the   high  byte  may  be  used  to  pass
        device-specific function information.

             BR  is  the  number  of  8-bit  bytes   requested   to   be
        transferred.   In  the  case of output transfers, this is always
        the exact number of bytes  transferred.   For  input  transfers,
        this  is  the  maximum number to be transferred; the BX field of
        the IORB indicates the actual number of bytes  transferred  when
        the operation is completed.

             STATUS is a 16-bit field  which  indicates  the  completing
        status  of  the I/O request.  This always has bit 7 set when the
        operation is completed, and bit 15 set when there is  an  error.
        The  remaining  bits  in the low byte specify device independent
        error classes; these consist of  programming  error  and  device
        error.   Program  errors  are  a  result  of  such things as I/O

        ELF KERNEL PROGRAMMER'S GUIDE                    Page  21
        ELF I/O SYSTEM -- INTRODUCTION


        requests to invalid devices.  Device errors  occur  for  reasons
        such  as parity errors, or data over-runs.  The bits in the high
        byte indicate  device  dependent  information  such  as  "parity
        error" or "off-line".

             BYTEH and BYTEL are the high and low portions respectively,
        of  the  device  byte  address.   This  field  applies  only  to
        addressable devices such as disks, dectapes, and drums.



        Example:

             The following subroutine reads a record from disk block 1
        and writes it on Magtape unit 1 (no device byte address
        associated).

        IOOP =                           2  ;OP-CODE TO AWAIT FOR I/O

        RDW: $SIO                        #IORBI  ;START I/O FROM DISK
             $WAITS                      #IOOP  ;WAIT (SPECIFIC) FOR
         COMPLETION
             $SIO                        #IORBO  ;INIT I/O TO TAPE
             $WAITS                      #IOOP  ;WAIT (SPECIFIC) FOR
         OUTPUT
             RTS                         PC  ;RETURN TO CALLER

        IORBI:                           .RAD50 'DSK'  ;DISK
             .WORD                       0  ;UNIT 0
             .BYTE                       IOOP,0  ;OP-CODE TO BE RECEIVED
             .WORD                       BUFFER,1 ;BUFFER ADDRESS,
         FUNCTION =
                                             READ
             .WORD                       128.  ;128 BYTES
             .WORD                       0,0  ;STATUS ,  BYTES XFERRED
             .WORD                       0,512  ;512 BYTES PER BLOCK

        IORBO:                           .RAD50 'MTA'  ;MAG TAPE
             .WORD                       1  ;UNIT 1
             .BYTE                       IOOP,0  ;OP-CODE TO BE RECEIVED
             .WORD                       BUFFER,2 ;BUFFER ADDRESS,
         FUNCTION
             .WORD                       128.  ;128. BYTE WRITE
             .WORD                       0,0  ;STATUS, BYTES XFERRED
             .WORD                       0,0  ;DEVICE ADDRESS (NOT USED
         FOR 
                                            SEQ DEV

        ELF KERNEL PROGRAMMER'S GUIDE                    Page  22
        DEVICE DRIVERS


        III  Writing I/O Drivers for ELF


             Device Drivers are modules which are used to interface  the
        kernel I/O procedures with the PDP-11 hardware I/O devices.  The
        device driver is called upon by an I/O auxiliary  (IOX)  process
        in the ELF I/O system to initiate I/O requests to a device.  All
        necessary information for the driver is contained in the  Device
        Control  Table  (DCT)  belonging to the particular device.  When
        the I/O is complete, the driver returns  status  information  in
        the  DCT.   This  status  information is then passed back to the
        original requesting process so it can determine that the I/O was
        completed successfully.


        III.1  Primary Tasks of Device Drivers

             There are three tasks performed  by  device  drivers.   The
        task  a driver performs is selected by one of three driver entry
        points.

        III.1.1  Device Initialize:

             The first task is the initialization routine.  This routine
        is  called  by  an  IOX  by  means of the PDP-11 Jump-Subroutine
        instruction to the  driver's  entry  point  for  initialization.
        This  routine is called when the first I/O request occurs to the
        device after the system is started.  It performs  any  necessary
        action  needed  before  the  device  is  ready  for I/O (such as
        enabling of device interrupts).  The interrupt  vector  for  the
        device  is  set  by  the  IOX, and its initialization is not the
        responsibility  of  the  driver.   Upon  entry,  register   zero
        contains  the address of the Interrupt Control Table.  To return
        to the IOX, an RTS PC instruction  is  executed  by  the  device
        driver.

        III.1.2  Transfer Initialize:

             The second task of the driver is  to  handle  requests  for
        data  transfer.   The  requests originate from a process issuing
        the $SIO primitive.  Control is passed from the  $SIO  primitive
        to  the  IOX  process  handling the device.  The IOX does a jump
        subroutine to the  "transfer  initialize"  entry  point  of  the
        device driver, passing the DCT address of the device in R0.  The
        driver then sets up the I/O registers  for  the  transfer.   The
        byte  count, buffer address, function, and device output address
        are contained in the DCT.

             In some cases, the address of  the  ICT  for  a  device  is
        needed  in  the  transfer  initialize  routine.  The ICT for the
        interrupt vector that the driver is servicing is found by  using
        the  DCTICT  entry  in  the  DCT.   The DCTICT word contains the
        address of the first word of the ICT vector table  corresponding

        ELF KERNEL PROGRAMMER'S GUIDE                    Page  23
        DEVICE DRIVERS


        to  that  DCT.   The  ICT vector table has as its first word the
        number of ICT addresses  in  the  table.   The  following  words
        contain  an  address  to  an  ICT.   If  the device has only one
        interrupt vector, then it will only have one ICT and  one  entry
        in the ICT vector table.  

             For block transfer devices, a "go" bit is  usually  set  to
        start  the  transfer  after  the device registers are set.  Then
        device interrupts may be enabled, and control is returned to the
        I/O Auxialiary process by means of the RTS PC instruction.

             For character transfer devices, each character  is  usually
        handled  by  an interrupt routine.  Control may be passed to the
        interrupt routine directly from the transfer initialize routine;
        in  this  case,  the  stack  has  to be modified to look like an
        interrupt had occurred (instead of an RTS PC).  In  many  cases,
        an   initial  interrupt  may  be  obtained  by  simply  enabling
        interrupts, and such meddling with the stack is unnecessary.

        III.1.3  Interrupts:

             After the transfer initialize  routine  has  initiated  the
        I/O,  the third entry point of the driver can be entered through
        the device  interrupt  vector.   Upon  entry  of  the  interrupt
        routine  (from  a  device interrupt), register zero contains the
        address of the ICT.  The previous value of R0 is on the  top  of
        the stack followed by the PC and PS.  The address of the DCT can
        be found by using the address of the DCT vector table, which  is
        in  the ICTDCT word.  The first word of the DCT vector table has
        the number of DCT addresses in the table.  The number of entries
        in  the  DCT  vector  table  depends  on  the number of units or
        devices that the interrupt vector handles.  The order of entries
        in  the  DCT  vector  table  is  determined  by the order of DCT
        definitions using that interrupt vector.  The first DCT  defined
        using that interrupt vector will have the first entry in the DCT
        vector table etc.  Therefore, the interrupt handler could use  a
        unit  number  from its I/O status registers to index through the
        DCT vector table to obtain the correct DCT for servicing.

             For block transfer devices, the  interrupt  routine  checks
        the  I/O  status  registers for any error.  If there are errors,
        then it specifies what kind  (discussed  later)  in  the  DCTSTA
        word.   Otherwise,  it  just  sets  the  done  bit in DCTSTA and
        returns by one of two ways (discussed later).

             On interrupts for character transfer  devices  the  routine
        proceeds  with  the set-up for the next character transfer.  Any
        errors must be checked for, and appropriate  action  taken.   An
        error  code  may  be  returned  by  the driver in DCTSTA and the
        number of bytes successfully transferred in DCTBX.  If no errors
        occurred  on  the  last  character,  and  more  data  is  to  be
        transferred, the routine  may  continue  with  the  transfer  by
        enabling  device  interrupts  and executing the RTI instruction.

        ELF KERNEL PROGRAMMER'S GUIDE                    Page  24
        DEVICE DRIVERS


        When the entire transfer is complete the DCTSTA, DCTBX and other
        appropriate   DCT  entries  should  be  updated  by  the  driver
        interrupt routine.


             A return may be accomplished by one of two ways:

             (1)  Restore all registers except R0 and then jump
                  to the I/O completion routine, $IOCMP, with 
                  the address of the DCT in R0.

             (2)  Signal the IOX with R1 containing the DCT
                  address.  (The global $IOXID contains the
                  process ID for the IOX process.)  Restore
                  all the registers and exit via a $RTI
                  primitive.  Note R0 is already saved on top
                  of the stack upon entry to the interrupt
                  handler.

        III.2  Register Usage:

             All registers that are changed  by  the  driver  should  be
        pushed upon entry and popped before return (i.e., saved).

        III.3  Error Codes:

             When an error occurs, bit 15 of DCTSTA should be set.   The
        low  6  bits  of  DCTSTA, should be set to the appropriate error
        category.  Bit 7 is the done bit and must always be  set  before
        returning.  Bits 8 through 14 are set as either a device code or
        a user code, depending on the error category.  These  codes  are
        optional and need not be specified.

             Error categories may have value "2" for "user error", value
        "4"  for  "device error", or value "0" for no error.  A table of
        the equates for the error codes may be obtained by  calling  the
        $DFIST macro in KTBL.SML.

        III.4  Assembly:

             To assemble the driver the three entry points (and possibly
        $IOCMP  and  $IOXID)  must  be specified as "globals".  Also the
        $CNFIG, $DFREG, $DFIFN, $DFIST, $DFDCT and $DFICT macros must be
        called  in  order  to  include  the  equates  for  the DCT, ICT,
        registers, function codes, and error codes.

             The DCT and ICT for the device must  be  generated  in  the
        KDCT.M11  module, and it must be reassembled.  The object output
        of the driver and KDCT.M11 are then linked to the  rest  of  the
        ELF kernel.  

        ELF KERNEL PROGRAMMER'S GUIDE               Page  25
        ELF KERNEL PRIMITIVES


        IV  ELF KERNEL PRIMITIVES




             This section  describes  the  means  by  which  ELF  kernel
        primitives are invoked, and indicates the syntax used in calling
        kernel MACROs.  The primitives are listed in alphabetical order,
        and  each  primitive name corresponds to its calling name in the
        system macro library.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  26
        ELF KERNEL PRIMITIVES


        Title: $ASDEV

        Function: ASsign a DEVice to a process (or process-pair)

           $ASDEV   <device name>,<unit number>,<process A>,
                 R0            R1        MSB (R2)
            <process B>:<completion code>
             LSB (R2)          R0

        Description:

                The $ASDEV primitive assigns a  device  to  one  (in
           certain   cases,   two)  process.   Once  the  device  is
           assigned, only the  assigned  process  may  perform  $SIO
           calls  to  that  device.  The device name and unit number
           have the same conventions as $DFDEV.  Both processes must
           be  specified,  and  a  zero  PID  defaults to the active
           process.

                The primitive returns a completion code in R0  which
           is  zero  if the device was assigned successfully.  It is
           negative (unsuccessful) if the process has  a  capability
           value greater than 2.  It is a minus one if the device is
           non-existent, and it is positive if the device is already
           assigned.   If  the  device  was  previously  assigned, a
           semaphore is returned in R0, which can be  used  to  wait
           for the device to become released.

        Macro Calling Syntax:

           $ASDEV   DNAM/R0,UNIT/R1,PIDA/R2,PIDB/R2

        ELF KERNEL PROGRAMMER'S GUIDE               Page  27
        ELF KERNEL PRIMITIVES


        Title: $ASH

        Function: Arithmetic SHift

           $ASH  <shift value>,<register>

        Description:

                The specified  register  is  shifted  the  specified
           number  of places, where a positive shift value indicates
           shift left and a negative  shift  value  indicates  shift
           right.   The N, Z, and C bits are set as described in the
           description of the PDP 11/45  ASH  instruction,  but  the
           setting  of  the  V  bit  is unpredictable.  It should be
           noted that the  shift  value  must  be  a  constant.   In
           particular, an addressing mode (such as immediate) should
           not be specified.

        Macro Calling Syntax:

           $ASH  VALUE,REGISTER

                    e.g.  $ASH   3,R2
                          $ASH  -4,R3

        ELF KERNEL PROGRAMMER'S GUIDE               Page  28
        ELF KERNEL PRIMITIVES


        Title:  $ASHC

        Function:  Arithmetic SHift Combined

           $ASHC  <shift value>, <even register>

        Description:

                The specified even-odd pair of registers is  shifted
           the  specified  number  of places, where a positive shift
           value indicates shift left and  a  negative  shift  value
           indicates  shift right.  The C bit is set as described in
           the description of the PDP 11/45  ASHC  instruction,  but
           the  settings  of the N, Z, and V bits are unpredictable.
           It should be  noted  that  the  shift  value  must  be  a
           constant.   In  particular,  an  addressing mode (such as
           immediate) should not be specified.

        Macro Calling Syntax:

           $ASHC VALUE, REGISTER

                    e.g.  $ASHC   3,R2
                          $ASHC  -4,R4

        ELF KERNEL PROGRAMMER'S GUIDE               Page  29
        ELF KERNEL PRIMITIVES


        Title: $AVS

        Function: Allocate Virtual Storage

           $AVS  <#bytes>,<vsmid>:<code>,<virtual address>
                    R0     R1      R0         R2
        Description:

                The $AVS  primitive  assumes  a  byte  count  and  a
           virtual  storage  ID  in  R0  and  R1  respectively.  The
           storage is allocated within the specified virtual address
           space.   It  should be noted that storage is allocated in
           32-byte blocks.  When a request is made,  the  amount  of
           storage  allocated  is rounded up to the next multiple of
           32 bytes.

                The virtual address  of  the  allocated  storage  is
           returned  in  R2.  If no virtual storage is available for
           the request then  R0  contains  a  zero  instead  of  the
           requested  number of bytes upon return.  In this case, R2
           has a semaphore ID which may be used to wait for  storage
           to become available.

        Macro Calling Syntax:

           $AVS  BYTCNT/R0,[VSMID/R1]

        ELF KERNEL PROGRAMMER'S GUIDE               Page  30
        ELF KERNEL PRIMITIVES


        Title: $AVSPF

        Function: Allocate Virtual Storage - SPeciFic

           $AVSPF <#bytes>,<vsmid>,<virtual address>
                     R0      R1         R2

        Description:

                The $AVSPF primitive assumes a byte  count,  virtual
           address  space  ID and a virtual address in R0, R1 and R2
           respectively.   The  primitive  allocates  the  specified
           amount   of  storage  at  a  specified  location  in  the
           specified address space.  This primitive is used for  the
           purpose  of  allocating  specific  storage areas; this is
           performed during system initialization and during loading
           of   position-dependent   programs.    No  arguments  are
           returned.

        Macro Calling Syntax:

           $AVSPF  BYTCNT/R0,[VSMID/R1],VADR/R2

        ELF KERNEL PROGRAMMER'S GUIDE               Page  31
        ELF KERNEL PRIMITIVES


        Title: $AVSPG

        Function: Allocate Virtual Storage within a PaGe.

           $AVSPG  <#bytes>,<vsmid>:<code>,<virtual address>
                      R0      R1      R0         R2

        Description:

                This primitive assumes the same parameters as  $AVS.
           Storage  is  also allocated in 32-byte blocks like in the
           $AVS  primitive;  however  the   storage   allocated   is
           guaranteed to be within a page.  Thus, the largest single
           request can be 8192 bytes.

                The primitive returns the same  parameters  as  does
           the $AVS primitive.

        Macro Calling Syntax:

           $AVSPG  BYTCNT/R0,[VSMID/R1]

        ELF KERNEL PROGRAMMER'S GUIDE               Page  32
        ELF KERNEL PRIMITIVES


        Title: $CREAP

        Function: CREAte a Process

           $CREAP   <entry point>,<priority>,<vsmid>,<event op-code>
                (SP)      LSB 2(SP) MSB 2(SP)   LSB 4(SP)
            <rel capability>:<process  ID>,<completion code>
                MSB 4(SP)          R0              R1

        Description:

                The $CREAP primitive  assumes  an  entry  point,  an
           absolute   priority,   an   event   completion   code,  a
           non-negative relative capability  value,  and  a  virtual
           storage  ID.   These arguments are placed on the caller's
           stack.  If the virtual storage ID is not  specified  then
           the high byte of the second stack word is set to zero.

                $CREAP  creates  a  new  system  process  with   the
           specified  parameters  that  are passed.  If the VSMID is
           zero, then the process is  created  within  the  caller's
           address  space and with the same mode(i.e., kernel, user)
           as the  caller.   When  $CREAP  returns  control  to  the
           caller,  the  stack  is  cleared,  the  process ID of the
           newly-created process is returned in R0, and a completion
           code  in  R1.   The $CREAP primitive gives control to the
           scheduler, after allocating and formatting a new  process
           control  table for the created process.  When the created
           process is frozen, the  creator  is  signalled  with  the
           event  op-code  specified when the process was originally
           created.  the  event  data  in  this  case  contains  the
           process ID of the frozen process.

        Macro Calling Syntax:

           $CREAP   EPT,PRIO,EVNTCD,CAPABILITY [,VSMID]

        Completion Codes:

           0= Success
           2= Undefined priority value (no PRQ), assigned  to  first
              available lower priority queue.
           4= Insufficient storage for new process

                Note  that  absolute  process  priority  values  are
           assigned  such  that  the  lowest  priority  level in the
           system has a value of 1, the highest is a number equal to
           the  number of system process priority levels (determined
           when the system is generated).

        ELF KERNEL PROGRAMMER'S GUIDE               Page  33
        ELF KERNEL PRIMITIVES


        Title: $CVAS

        Function: Create a new Virtual Address Space.

           $CVAS  :<vsmid/0>
                      R1

        Description:

                The $CVAS primitive  is  used  to  allocate  in  the
           system  a  new  virtual  address space.  This can be used
           when a process needs its own  address  space  and  it  is
           necessary  to  load  the program into that address space.
           This address space is later referred to  by  its  virtual
           storage  ID  which  is  returned  in  R1.   If no virtual
           address spaces were available, then a zero is returned in
           R2.

        Macro Calling Sequence:

           $CVAS

        ELF KERNEL PROGRAMMER'S GUIDE               Page  34
        ELF KERNEL PRIMITIVES


        Title:  $DEVC

        Function:  DEVice Characteristics

           $DEVC <device name>,(unit #>,<characteristic code>,
                       R0         R1             R2
                 <characteristic value>
                          R3

        Description:

                The Device Characteristics primitive permits setting
           or  retrieving  information  from the DCT (Device Control
           Table) for a specified device.  The device  is  described
           by  registers  0  and  1  which  have the device name and
           device  unit   number,   respectively.    The   type   of
           information  and  whether the information is to be stored
           or retrieved is specified by the characteristic  code  in
           R2.   The  information  is  specified or retrieved in R3.
           Error conditions (such as non-existent devices or illegal
           characteristic code) are not reported.

                The device characteristics functions  are  currently
           supported   for   two  device  types:  character  devices
           (terminals) and inter-process ports.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  35
        ELF KERNEL PRIMITIVES


        Device Characteristics Code Assignments:

           I.  Character-oriented devices (terminals)

                0)  Set  tab  count  (value  of   0   disables   tab
                    expansion; value of 8.  enables tabs).

                1)  Set  carriage  return  fill   count   (padding).
                    (Value of 0 disables padding on CR).

                2)  Set line feed fill count (padding).  (Value of 0
                    disables padding on LF).

                Example:

                    set line-feed padding for TTY4 to 6 chars.
                    MOV    IORB,R0
                    MOV    IORB+2,R1
                    $DEVC  R0,R1,#2,#6
                    .
                    .
                    .
                IORB:
                    .RAD50 'TTY'
                    .WORD 4
                    .
                    .
                    .

                Note:  The ASCII null  character  (0)  is  used  for
                padding.


           II.  Inter-process Ports.

                0)  Obtain bytes requested (queued) on  port.   This
                    returns  the  number  of  bytes  which are being
                    requested to be read or written by a process  on
                    the  port.   If  no  read  or write requests are
                    outstanding the value is 0.   (Note  that  there
                    may  not  be  both  a  read  and a write request
                    simultaneously; matching reads and writes  cause
                    the requests to complete immediately).

        ELF KERNEL PROGRAMMER'S GUIDE               Page  36
        ELF KERNEL PRIMITIVES


         TITLE: $DFDEV

         FUNCTION: DEFINE DEVice to system.

            $DFDEV  <device name>,<unit number>:<completion code>,
                         R0            R1              R0
                    <unit number>
                         R1
         Description:

                 The $DFDEV primitive makes a device associated with
            a  device  control  table (DCT) available for doing $SIO
            requests .  The device name parameter must  point  to  a
            .RAD50  word containing the device name, or the register
            must already contain the .RAD50 device name.   The  unit
            number must be specified and must be positive or a minus
            one.  A unit number of minus one indicates a request  to
            define any unit available, and return that unit number.

                 The primitive returns a completion  code  which  is
            zero  if the device is defined successfully, negative if
            the device doesn't exist and positive if the  device  is
            already  defined.   If  it  is  positive  the  device is
            already defined and a semaphore is returned in R0  which
            can  be used to wait for the device to become undefined.
            If an arbitrary device unit number  was  requested,  the
            successfully-allocated unit number is returned in R1.

         Macro Calling Syntax:

            $DFDEV  DNAM/R0,UNIT/R1

        ELF KERNEL PROGRAMMER'S GUIDE               Page  37
        ELF KERNEL PRIMITIVES


         Title: $DIV

         Function: DIVide

            $DIV  <divisor>,<dividend (MSW)>,<dividend (LSW)>
                     R2           R0                R1
                 :<divisor>,<quotient (LSW)>,<remainder>
                     R2           R0                R1

         Description:

                 The quotient and the remainder resulting  from  the
            division  of  the  32-bit (two's complement) dividend by
            the 16-bit (two's complement) divisor are returned as  a
            pair of 16-bit (two's complement) values.

         Macro Calling Syntax:

            $DIV DIVSR/R2,HIWRD/R0,LOWWRD/R1

         Note:

                 If the macro finds it necessary to move a value  of
            the  register on the stack and restores it after the two
            locations specified for the two halves of  the  dividend
            are updated with the quotient and remainder.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  38
        ELF KERNEL PRIMITIVES


         Title:  $DIVU

         Function:  DIVide Unsigned

            $DIVU   <divisor>,<dividend(MSW)>,dividend(LSW)>
                               R2          R0             R1
                            :<divisor>,<quotient(LSW)>,<remainder>
                                R2          R0             R1

         Description:

                 The  quotient  and  remainder  resulting  from  the
            division  of  the 32-bit unsigned dividend by the 16-bit
            unsigned divisor  are  returned  as  a  pair  of  16-bit
            unsigned values.

         Macro Calling Syntax:

            $DIVU   DIVSR/R2,HIWRD/R0,LOWWRD/R1

            Note:  If the macro finds it necessary to move  a  value
            to  or  from a parameter register, it saves the previous
            value of the register on the stack and restores it after
            the  two  locations  specified for the two halves of the
            dividend  are  updated  with  the   quotient   and   the
            remainder.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  39
        ELF KERNEL PRIMITIVES


         Title: $DSABL

         Function: DiSABLe interrupts.

            $DSABL

         Description:

                 This macro generates appropriate code  to  set  the
            processor  to a priority of seven so that interrupts are
            disabled.

         Macro Calling Syntax:

            $DSABL

        ELF KERNEL PROGRAMMER'S GUIDE               Page  40
        ELF KERNEL PRIMITIVES


         Title: $DVAS

         Function: Delete Virtual Address Space

            $DVAS  <vsmid>
                     R1

         Description:

                 The $DVAS primitive deletes the  specified  virtual
            storage  address  space that is specified by the virtual
            storage ID in R1.

         Macro Calling Syntax:

            $DVAS VSMID/R1

        ELF KERNEL PROGRAMMER'S GUIDE               Page  41
        ELF KERNEL PRIMITIVES


         Title: $ENABLE

         Function: ENABLE processor for interrupts

            $ENABLE

         Description:

                 This call generates appropriate  code  to  set  the
            processor's  priority  to  zero  so  that interrupts are
            enabled.

         Macro Calling Syntax:

            $ENABLE

        ELF KERNEL PROGRAMMER'S GUIDE               Page  42
        ELF KERNEL PRIMITIVES


         Title: $ERROR

         Function: freeze active process with ERROR code.

            $ERROR  <code>
                     (SP)

         Description:

                 The $ERROR macro places an error code on the stack,
            and  transfers  control  to  the  process  error handler
            ($ERROR).  The process  then  becomes  frozen,  and  the
            creator  of  the  process  in  error  is  notified.   No
            registers are used, allowing  the  creating  process  to
            examine  the  entire  set  of registers.  The error code
            specified must be literal (e.g.  an  equated  symbol  or
            numeric value).

         Macro Calling Syntax:

            $ERROR  CODE/-(SP)

        ELF KERNEL PROGRAMMER'S GUIDE               Page  43
        ELF KERNEL PRIMITIVES


         Title: $EXV

         Function: EXhaustive V of specified semaphore.

            $EXV    <semaphore ID>
                         R0

         Description:

                 The $EXV macro assumes a semaphore ID and passes it
            in R0 to the $EXV primitive.

                 The $EXV primitive awakens all processes  that  are
            waiting  on  the  specified semaphore.  No arguments are
            returned.

         Macro Calling Syntax:

            $EXV            SEMID/R0

         Error Codes:

            $SERIVS=316     ;INVALID SEMAPHORE ID.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  44
        ELF KERNEL PRIMITIVES


         Title: $FREEP

         Function: FREEze Process

            $FREEP  <process ID>,<error code>
                        R0           R1

         Description:

                 The $FREEP macro assumes a process ID and an  error
            code,  which  it passes in R0 and R1 respectively to the
            $FREEP primitive.  If no process ID  or  error  code  is
            specified, then these arguments assume default values of
            zero.  It should be noted  that  the  normal  method  of
            process  termination  is  by freezing the active process
            with a completion code of zero  (hence,  both  arguments
            unspecified).

                 The $FREEP routine freezes the process specified in
            R0 and posts the specified error code.  If R0 contains a
            zero, then it freezes the active process.

         Macro Calling Syntax:

            $FREEP  PID/R0,ERRCD/R1

         ERROR CODES:

            INVPID=320      ;INVALID PROCESS ID ON FREEP OR ZAP

        ELF KERNEL PROGRAMMER'S GUIDE               Page  45
        ELF KERNEL PRIMITIVES


         Title: $FSEM

         Function: Free SEMaphore ID.

            $FSEM   <semaphore ID>
                         R0

         Description:

                 The $FSEM macro assumes a semaphore ID  and  passes
            it in R0 to the $FSEM primitive.

                 The $FSEM routine releases system storage used  for
            the  specified  semaphore,  and  makes  the semaphore ID
            "unknown" to the system.  No arguments are returned.

         Macro Calling Syntax:

            $FSEM   SEMID/R0

         Error Codes:

            SERIVS=316      ;INVALID SEMAPHORE ID.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  46
        ELF KERNEL PRIMITIVES


         Title: $FVS

         Function: Free Virtual Storage

            $FVS  <#bytes>,<vsmid>,<virtual address>
                     R0      R1          R2

         Description:

                 The $FVS primitive assumes the  same  arguments  as
            $AVS.   That is, the number of bytes, virtual storage ID
            and the virtual address of the storage to  be  released.
            The  primitive  releases the specified amount of storage
            and makes that storage free again.   If  the  number  of
            bytes  is  not  on  a  128-byte block boundary, then the
            primitive rounds up to the next boundary.  No  arguments
            are returned.

         Macro Calling Syntax:

            $FVS  BYTCNT/R0,[VSMID],VADR/R2

        ELF KERNEL PROGRAMMER'S GUIDE               Page  47
        ELF KERNEL PRIMITIVES


         Title: $GAPID

         Function: Get Active Process ID

            $GAPID  :<vsmid>,<process ID>
                    MSB (R0)   LSB (R0)
         Description:

                 The $GAPID primitive returns the active process  ID
            (PID)  in  the  low  byte  of  R0 and the active virtual
            storage map ID (VSMID) in the high byte.

         Macro Calling Syntax:

            $GAPID

        ELF KERNEL PROGRAMMER'S GUIDE               Page  48
        ELF KERNEL PRIMITIVES


         Title: $GETOD

         Function: GEt the Time Of Day

            $GETOD  :<time of day(MSW)>,<time of day(LSW)>
                            R0                 R1
         Description:

                 The $GETOD primitive returns the  time  of  day  in
            ticks.   Where  one  tick  is a 40 microsecond interval.
            The time is returned in R0 and R1 as a  unsigned  32-bit
            quantity,  where  R0 is the most significant word and R1
            is the least significant word.  For  example  there  are
            25000  decimal  ticks per second, which would correspond
            to an octal number of 60650 in R1.

         Macro Calling Syntax:

            $GETOD  

        ELF KERNEL PROGRAMMER'S GUIDE               Page  49
        ELF KERNEL PRIMITIVES


         Title: $GPREG

         Function: Get Process REGister

            $GPREG  <register number>,<process ID>:<value>
                        MSB (R0)        LSB (R0)       R1
         DESCRIPTION:

                 $GPREG  obtains   the   value   of   one   of   the
            general-purpose   registers   for   a  specified  frozen
            process.  A register number is assumed in the high  byte
            of  register  0,  and a process ID is assumed in the low
            byte of register 0.  The value of the specified register
            is returned in R1.

         Macro calling syntax:

            $GPREG  PID/R0,REGNR/R0

        ELF KERNEL PROGRAMMER'S GUIDE               Page  50
        ELF KERNEL PRIMITIVES


         Title: $GTIME

         Function: Get TIME left-to-go

            $GTIME  :<time left-to-go>
                           R0
         Description:

                 The $GTIME primitive returns the amount of time  in
            milliseconds   left-to-go   before  the  timer  interval
            (issued by a previous $STIME primitive) has expired.

         Macro Calling Syntax:

            $GTIME

        ELF KERNEL PROGRAMMER'S GUIDE               Page  51
        ELF KERNEL PRIMITIVES


         Title: $HIO

         Function: Halt an Input or Output request.

            $HIO    <IORB address>
                          R0
         Description:

                 The $HIO primitive discontinues any  $SIO  requests
            that  are  in  progress for the specified IORB.  Any I/O
            that is in the  middle  of  transfer  will  continue  to
            completion,  but the $SIO primitive will not signal that
            the I/O is done.

         Macro Calling Syntax:

            $HIO    IORB/R0

        ELF KERNEL PROGRAMMER'S GUIDE               Page  52
        ELF KERNEL PRIMITIVES


         Title: $ISEM

         Function: Initialize SEMaphore ID.

            $ISEM   :<semaphore ID>
                           R0

         Description:

                 The $ISEM macro assumes no arguments.

                 The  $ISEM  primitive  allocates  storage   for   a
            semaphore  process  queue, and returns a semaphore ID in
            R0.

                 The semaphore ID can  then  be  associated  with  a
            resource.   With the semaphore ID established, processes
            can make requests to use the resource with  the  $P  and
            $REQ primitives.

                 Note  that  it   is   the   initializing   process'
            responsibility  to  save  the  semaphore  ID,  making it
            accessible to the set of processes sharing the resource.

         Macro Calling Syntax:

            $ISEM

         Error Codes:

            SERSXH=317      ;SEMAPHORE STORAGE EXHAUSTED.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  53
        ELF KERNEL PRIMITIVES


         Title: $IVAS

         Function: Initialize a Virtual Address Space

            $IVAS  <vsmid>
                     R1

         Description:

                 The $IVAS primitive resets a virtual address space.
            This  involves  resetting the virtual storage allocation
            bits and purging all associated pages from main  memory.
            This primitive is called when a new image of the address
            space is to be loaded.  No arguments are returned.

         Macro Calling Syntax:

            $IVAS  VSMID/R1

        ELF KERNEL PROGRAMMER'S GUIDE               Page  54
        ELF KERNEL PRIMITIVES


         Title: $LOOP

         Function: generate LOOPing structure

            $LOOP  <register with count>,<branch address>

         Description:

                 This macro generates machine independent  code  for
            building  a  looping  structure.  The register specified
            should contain the number of times for the  loop  to  be
            executed.   The branch address should be a label defined
            before the macro call.

         Macro Calling Syntax:

            $LOOP  REG,BRADR

        ELF KERNEL PROGRAMMER'S GUIDE               Page  55
        ELF KERNEL PRIMITIVES


         Title: $MUL

         Function: Multiply

            $MUL  <multiplier>,<multiplicand>
                      R2             R0
                 :<multiplier>,<product (MSW)>,<product (LSW)>
                      R2             R0             R1

         Description:

                 The  32-bit  product  of  the  multiplier  and  the
            multiplicand   is   return  in  the  specified  pair  of
            locations.

         Macro Calling Syntax:

            $MUL  MLTPLR/R2,MLTCND/R0[,LOWWRD/R1]

         Note:

                 If the third parameter is left out the multiplicand
            is replaced by the low order 16 bits of the product.  If
            a third parameter is given, it is updated with  the  low
            order  16  bits  of  the product and the multiplicand is
            replaced by the high order 16 bits of the  product.   It
            should  be noted that if the macro finds it necessary to
            move a value to or from a parameter register, its  value
            is saved on the stack and restored after the destination
            is set.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  56
        ELF KERNEL PRIMITIVES


         Title:  $MULU

         Function:  MULtiply Unsigned

            $MULU   <multiplier>,<multiplicand>
                                 R2            R0
                            :<multiplier>,<product(MSSW)>,<product<LS
            W>>
                                 R2           R0              R1

         Description:

                 The 32-bit unsigned product of the  multiplier  and
            multiplicand  is  returned  in  the  specified  pair  of
            locations.  Both the  multiplier  and  multiplicand  are
            treated as 16-bit unsigned quantities.


         Macro Calling Syntax:

            $MULU   MLTPLR/R2,MLTCND/R0[,LOWWRD/R1]

            Note:  The presence or absence of a third  parameter  is
            interpreted in the same way as in the $MUL primitive.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  57
        ELF KERNEL PRIMITIVES


         Title: $P

         Function: P a semaphore ID.

            $P      <semaphore ID>
                          R0

         Description:

                 The $P macro assumes a semaphore  ID  argument  and
            passes it in R0 to the $P primitive.

                 The $P primitive adds the process  to  a  queue  of
            processes  that  are waiting for the resource associated
            with the semaphore ID (de-scheduled).  If  the  resource
            is not available, then the process is put to sleep until
            it becomes available.

         Macro Calling Syntax:

            $P      SEMID/R0

         Error Codes:

            SERIVS=316      ;INVALID SEMAPHORE ID

        ELF KERNEL PROGRAMMER'S GUIDE               Page  58
        ELF KERNEL PRIMITIVES


         Title:  $PMAP

         Function:  Physical page MAP

            $PMAP  <target PST index>,<source VPA>
                            R0            R1

         Description:

                 The $PMAP primitive permits a virtual address  page
            to  be  mapped  into a physical page.  The physical page
            address is described by a PST (Physical  Storage  Table)
            index   in  R0.   The  virtual  page  address  (VPA)  is
            specified in R1.  An error trap results if  the  virtual
            page  is  already  in  use,  i.e., already mapped into a
            physical page.  If the physical page is already in  use,
            the  virtual  page  is  added to a share link of virtual
            pages using the physical page.

         Macro Calling Syntax:

            $PMAP   PST/R0, VPA/R1

         Error Codes

            VMP=230          ;virtual page in use

        ELF KERNEL PROGRAMMER'S GUIDE               Page  59
        ELF KERNEL PRIMITIVES


         Title: $REMTX

         Function: Remove EMT eXit.

            $REMTX  <EMT code>
                        R0
         Description:

                 The $REMTX primitive removes an EMT exit  that  was
            previously set by a $SEMTX.

         Macro Calling Syntax:

            $REMTX  EMTCDE/R0






            NOT IMPLEMENTED YET

        ELF KERNEL PROGRAMMER'S GUIDE               Page  60
        ELF KERNEL PRIMITIVES


         Title: $REQ

         Function: REQuest a resource.

            $REQ  <semaphore ID>,<event op-code>,<event data>:
                     LSB R0          MSB R0         R1

         Description:

                 The $REQ primitive requests the resource associated
            with  the  semaphore  ID.   The requesting process gains
            control immediately after making the request (as opposed
            to  $P,  which  waits  until the resource is available).
            When the  resource  becomes  available,  the  requesting
            process  is  signalled  with  the event op-code and data
            that it specified when it made the request.

         Macro Calling Syntax:

            $REQ  SEMID/R0,EVNTCD/R0,DATA/R1

        ELF KERNEL PROGRAMMER'S GUIDE               Page  61
        ELF KERNEL PRIMITIVES


         Title: $RLDEV

         Function: ReLease a DEVice from assignment.

            $RLDEV  <device name>,<unit number>,<process A>,
                         R0            R1        MSB (R2)
                    <process B>:<completion code>
                     LSB (R2)          R0
         Description:

                 The $RLDEV primitive releases  a  device  that  had
            been  assigned  to some processes by a $ASDEV call.  The
            arguments required  are  the  same  as  for  the  $ASDEV
            primitive.

                 A completion code is returned in R0 which  is  zero
            if  the  device  was  released.   It  is negative if the
            device doesn't exist and it is positive if the device is
            not assigned to the specified process.

         Macro Calling Syntax:

            $RLDEV  DNAM/R0,UNIT/R1,PIDA/R2,PIDB/R2

        ELF KERNEL PROGRAMMER'S GUIDE               Page  62
        ELF KERNEL PRIMITIVES


         Title: $RSTRP

         Function: ReSTaRt a Process at an entry point

            $RSTRP  <process ID>,<entry point>
                         R0            R1

         Description:

                 The restart-process  primitive  allows  the  kernel
            stack  of a process to be reset, and the program counter
            of the process to be set  to  a  specified  value.   The
            restart  process  primitive  may  only be used by system
            (kernel) processes, and may only be applied to processes
            which are frozen.  Restarting a process has no effect on
            the resources which it owns (i.e., semaphores  which  it
            has $P'd) or event messages on its input queue.  It also
            has no effect on I/O requests active or pending for  the
            given process.

         Macro calling syntax:

            $RSTRP  PID/R0,EP/R1

        ELF KERNEL PROGRAMMER'S GUIDE               Page  63
        ELF KERNEL PRIMITIVES


         Title: $RTI

         Function: ReTurn from Interrupt with context switch.

            $RTI

         Description:

                 This primitive effectively does  an  RTI  from  the
            process,  but  transfers  intermediate  control  to  the
            scheduler, allowing a higher priority process to receive
            control.   Thus  the interrupted process regains control
            from the scheduler according to its scheduling priority.

                 This should be used in conjunction with $SGNLI.  It
            allows  several  processes  to  be placed on the process
            ready queue before allowing the scheduler to  perform  a
            context switch.  (Note that $SIGNL automatically returns
            control  to  the  scheduler,  allowing  the   signalling
            process  to  lose  control;  $SGNLI is generally used by
            interrupt routines which must signal  several  processes
            before relinquishing control with $RTI)

         Macro Calling Syntax:

            $RTI

        ELF KERNEL PROGRAMMER'S GUIDE               Page  64
        ELF KERNEL PRIMITIVES


         Title: $SEMTX

         Function: Set EMT eXit

            $SEMTX  <vsmid>,<capability>,<EMT code>,
                     MSB R0    MSB R1      LSB R1
                    <EMT transfer address>
                              R2
         Description:

                 The $SEMTX primitive allows a "user EMT exit" to be
            set.   When  an  EMT  instruction  is  executed with the
            specified code, control is then passed to the  specified
            transfer   address.    The   address   that  control  is
            transferred to will be  in  the  virtual  address  space
            specified  by  the  virtual storage map ID (VSMID).  The
            process that gets control will then have the  capability
            that is specified.

         Macro Calling Syntax:

            $SEMTX  VSMID/R0,CAP/R1,EMTCDE/R1,EMTXFR/R2

        ELF KERNEL PROGRAMMER'S GUIDE               Page  65
        ELF KERNEL PRIMITIVES


         Title: $SETOD

         Function: SEt Time Of Day

            $SETOD  <time of day(MSW)>,<time of day(LSW)>
                           R0                 R1
         Description:

                 The $SETOD  primitive  sets  the  time  of  day  as
            specified  by  the  32-bit  quantity  in R0 and R1.  The
            value specified is a number in ticks, where one tick  is
            40 microseconds.

         Macro Calling Syntax:

            $SETOD  MSW/R0,LSW/R1

        ELF KERNEL PROGRAMMER'S GUIDE               Page  66
        ELF KERNEL PRIMITIVES


         Title: $SGNLI

         Function: SiGNaL a process with an Immediate return.

            $SGNLI  <process ID>,<event op-code>,<event data>
                      LSB (R0)      MSB (R0)          R1
         Description:

                 THE $SGNLI primitive assumes the same arguments  as
            $SIGNL.    The  primitive  places  the  specified  event
            op-code and data on the specified process' event message
            queue  and  places  the  specified  process in the ready
            queue if it is  not  there  already.   It  then  returns
            immediately  to  the calling process without considering
            whether a higher priority process should  be  scheduled.
            This  allows a process to signal several other processes
            before relinquishing control.

         Macro Calling Syntax:

            $SGNLI  PID/R0,EVENTCD/R0,DATA/R1

         Error Codes:

            INVSIG=322      ;INVALID SIGNAL PARAMETER

                 an invalid PID probably was specified.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  67
        ELF KERNEL PRIMITIVES


         Title: $SIGNL

         Function: SIGNaL a process.

            $SIGNL  <process ID>,<event op-code>,<event data>
                      LSB (R0)      MSB (R0)           R1

         Description:

                 The $SIGNL  macro  assumes  an  event  op-code  and
            process  ID which are passed in the high and low byte of
            R0.  A data word is also assumed and passed in R1.

                 The $SIGNL primitive takes the  event  op-code  and
            data  word and adds it to the specified processes' event
            message queue.

                 If the process that is being  signalled  is  asleep
            (i.e.   it  has  issued  a $WAIT), it will be made ready
            again.  In the case where the process had done a $WAITS,
            it  will  only  be  made  ready if you signal it with an
            event op-code that it was waiting on.

                 If the process being signalled is not asleep,  then
            the  event  descriptor  is  essentially queued up on the
            processes' event message queue.   The  $SIGNL  primitive
            then  returns  to the scheduler and the highest priority
            process receives control.

         Macro Calling Syntax:

            $SIGNL  PID/R0,EVNTCD/R0,EVNDTA/R1 EVNDTA/R1

         Error Codes:

            INVSIG=322      ;INVALID $SIGNAL PARAMETER

        ELF KERNEL PROGRAMMER'S GUIDE               Page  68
        ELF KERNEL PRIMITIVES


         Title: $SIO

         Function: Start Input or Output to a device.

            $SIO    <IORB address>
                          R0
         Description:

                 The $SIO is used for initiating I/O to devices  and
            also  to  other  processes  (using inter-process ports).
            The address of the I/O request block (IORB) is passed in
            R0.   This  block  is set up, previous to the $SIO call,
            with the neccessary information  to  do  the  I/O.   The
            basic requirement for doing I/O is the device name, unit
            number, buffer address, number of  bytes  for  transfer,
            and  the  function  to be performed (read or write).  An
            event op-code is also specified, which is  used  by  the
            primitive  to signal the calling process when the I/O is
            complete.

                 When a $SIO call is  made,  control  is  immediatly
            returned  to the caller once the I/O has been initiated.
            When the I/O is complete, the system signals the calling
            process  with  the  event op-code specified in the IORB.
            An event data word is also passed,  which  contains  the
            address  of the IORB(refer to $SIGNL).  A status word is
            returned in the IORB when the I/O is  complete.   If  an
            error  has  occured  bit  15  is  on  and  an error type
            returned in the low 7 bits.  Bit 8 is the done  bit  and
            is turned on when the I/O is complete.  A status code is
            returned in bits 9-14, which is device dependent.

            Error Types:
                    0= not used
                    2= user error
                    4= device error

                 The error types have an even number  code  so  that
            they can be used as an index to a branch table.

            Status Codes:

                 Status codes may be found in KTBL.SML under  $DFIST
            and in device driver documentation.

         Macro Calling Syntax:

            $SIO    IORB/R0

        ELF KERNEL PROGRAMMER'S GUIDE               Page  69
        ELF KERNEL PRIMITIVES


                 To perform  I/O  into  another  address  space  the
            calling  process  must have a capability value less than
            or equal to 2.  A capability value less than or equal to
            3  is required to initiate I/O into the calling process'
            own address space.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  70
        ELF KERNEL PRIMITIVES


         Title: $SPREG

         Function: Set Process REGister

            $SPREG  <Register number>,<Process ID>,<Value>
                        MSB (R0)       LSB (R0)       R1

         Description:

                 The $SPREG primitive sets the value of one  of  the
            general-purpose   registers  belonging  to  a  specified
            process.  A register number is assumed in the high  byte
            of  register 0, a Process ID is assumed in the low byte.
            The value of the specified register is returned in R1.

         Macro calling syntax:

            $SPREG  PID/R0,REGNR/R0,VALUE/R1

        ELF KERNEL PROGRAMMER'S GUIDE               Page  71
        ELF KERNEL PRIMITIVES


         Title: $STIME

         Function: Set TIMEr for a specified interval.

            $STIME  <event op-code>,<time interval>
                            R0            R1

         Description:

                 The $STIME macro assumes an  event  op-code  and  a
            time   interval,   which   are   passed  in  R0  and  R1
            respectively to the $STIME primitive.  The time must  be
            specified in milliseconds, allowing a range of between 1
            and 65535 ms.

                 The $STIME routine does not return  any  arguments.
            When  the  specified  time  interval  has  elapsed,  the
            originating process is signalled with the event  op-code
            that  was  passed  originally, and with event data of 0.
            This allows  the  process  to  await  reception  of  the
            specified   event   op-code,   associating   that   with
            expiration of its timer.

         Macro Calling Syntax:

            $STIME  EVNTCD/R0,INTRVL/R0

         Error Codes:

            STQERR=314      ;TIMER QUEUE ELEMENTS EXHAUSTED

        ELF KERNEL PROGRAMMER'S GUIDE               Page  72
        ELF KERNEL PRIMITIVES


         Title:  $SUSPR

         Function:  Suspend a Process' Esecution

            $SUSPR  <process ID>

         Description:

                 The  $SUSPR  primitive  suspends  execution  of   a
            process,  placing  the  process  in  the "frozen" state.
            This is  similar  to  the  effect  of  $FREEP  with  the
            exception  that  there is no signal of a creator process
            of the fact that the process has been  frozen.   Once  a
            process  is suspended using $SUSPR, it may be resumed by
            means of the thaw-process ($THAWP) primitive.

                 $SUSPR is useful for debugging processes, where  it
            is  desirable  to  place the process in the frozen state
            for examination or modification of its registers.

         Macro Calling Syntax:

            $SUSPR  PID/R0

         Error Codes:

            INVPID=320      ;INVALID PROCESS ID ON FREEP OR ZAP

        ELF KERNEL PROGRAMMER'S GUIDE               Page  73
        ELF KERNEL PRIMITIVES


         Title: $THAWP

         Function: THAW a Process.

            $THAWP  <Process ID>
                        R0

         Description:

                 The  THAW-PROCESS  primitive  restores  life  to  a
            frozen process (thaws it) and allows it to continue from
            the state at which it was frozen.  (Note that a  process
            may  be  frozen,  its  general-purpose  registers may be
            examined, and it may then continue; in some sense,  this
            mimics a PDP-11 processor, which may be halted, have its
            registers examined, and continue.)

                 While a process is frozen, event messages  continue
            to  be placed on its event message queue; upon awakening
            (from a thaw) it obtains these  messages  by  performing
            the $WAIT primitive.

         Macro calling syntax:

            $THAWP          PID/R0

        ELF KERNEL PROGRAMMER'S GUIDE               Page  74
        ELF KERNEL PRIMITIVES


         Title: $UDDEV

         Function: UnDefine a DEVice.

            $UDDEV  <device name>,<unit number>:<completion code>
                          R0           R1              R0
         Description:

                 The $UDDEV primitive requires the same arguments as
            $DFDEV  except  the  unit number may not be a minus one.
            This primitive makes the  specified  device  unavailable
            for start I/O's .

                 The primitive returns a completion code in R0 which
            is zero if completed successfully, negative if no device
            exists, and positive if the  device  is  assigned  to  a
            process or the device is already undefined

         Macro Calling Syntax:

            $UDDEV  DNAM/R0,UNIT/R1

        ELF KERNEL PROGRAMMER'S GUIDE               Page  75
        ELF KERNEL PRIMITIVES


         Title: $V

         Function: V a semaphore ID.

            $V      <semaphore ID>
                          R0

         Description:

                 The $V macro assumes a semaphore ID and  passes  it
            in R0 to the $V primitive.

                 The $V primitive then takes the calling process off
            the  queue for that semaphore.  If any other process was
            waiting for that semaphore, then the head process of the
            queue  is  signalled  that  the resource associated with
            that semaphore has been released.

         Macro Calling Syntax:

            $V      SEMID/R0

         Error Codes:

            SERIVS=316      ;INVALID SEMAPHORE ID.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  76
        ELF KERNEL PRIMITIVES


         Title:  $VMAP

         Function:  Virtual page MAP

            $VMAP <destination VPA>,<source VPA>
                        R0              R1

         Description:

                 The $VMAP primitive permits  a  source  page  in  a
            virtual  address  space  to be mapped into a destination
            page in another address space.  The destination  virtual
            page  address is specified in R0, and the source virtual
            page address is in R1.

         Macro Calling Syntax:

            $VMAP  DSTN-VPA/R0,SRC-VPA/R0

         Error Codes

            VMP=230      ;source virtual page already in use

        ELF KERNEL PROGRAMMER'S GUIDE               Page  77
        ELF KERNEL PRIMITIVES


         Title: $VMOV/B

         Function: Virtual storage MOVe word/Byte

            $VMOV/B  <source vsmid>,<dest. vsmid>,<source virt adr>,
                       MSB  R0        LSB  R0            R1

                     <dest. virt. adr.>,<word/byte count>
                             R2                R3

         Description:

                 The virtual move primitive is  used  to  move  data
            between  virtual  storage  address spaces.  A source and
            destination VSMID and virtual  address  are  passed.   A
            word or byte count is passed depending on the macro call
            used, i.e.  $VMOV or $VMOVB.  Data can be  moved  to  or
            from  your  own  address space.  If you are in user mode
            you must be privileged  to  move  into  another  address
            space.

         Macro Calling Syntax:

            $VMOV/B  SRCVSM/R0,DSTVSM/R0,SRCVA/R1,DSTVA/R2,CNT/R3

         Error Codes:

            VM1=210 ;UNPRIVILEGED VMOV
                     This occurs when a user process does a $VMOV
                     into another virtual address space and did
                     not have a high enough capability.

            VM2=240 ;VMOV TO READ ONLY PAGE

        ELF KERNEL PROGRAMMER'S GUIDE               Page  78
        ELF KERNEL PRIMITIVES


         Title:  $VTRAP

         Description:

                 $VTRAP is a primitive which  allows  a  process  to
            switch  address  spaces.   (This is only used in systems
            having the memory management option.) An  address  space
            switch  might  occur  when an EMT call is made by a user
            process in one address space  and  the  EMT  interpreter
            resides  in  another  address  space.  $VTRAP causes the
            storage map associated with the process to be changed.

                 $VTRAP assumes a new VSM ID, Processor status,  and
            program  counter on the caller's stack.  The caller must
            reside in  kernel  mode.   At  the  time  of  call,  the
            caller's stack must be formatted as follows:



                            +-----------+
                    SP ---> !  NEW PC   !
                            !-----------!
                            ! NEW ! CAP !
                            ! VSM !     !
                            +-----------+



                       Figure 4.  Caller's Stack




            where NEW PC is the new value of the program counter for
            the  process,  NEW VSM is the new address space, and CAP
            is the new capability value for the Process.  If the NEW
            VSM  is  non-zero,  control  is  transferred  to the new
            address space in user mode; if the value of NEW  VSM  is
            zero, control is passed to a procedure in kernel address
            space (with the processor in kernel  mode).   Note  that
            the update of the process' capability value (CAP) allows
            capability of the process  to  increase  when  making  a
            system  call  (EMT);  likewise,  capability  values  are
            restored when the process returns to the calling address
            space.   Of course, the source and target address spaces
            may be identical.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  79
        ELF KERNEL PRIMITIVES


                 $VTRAP saves  the  old  value  of  the  user  stack
            pointer  on  the  kernel  stack and allocates a new user
            stack in the target address  space.   Upon  transfer  of
            control  into  the destination address space, the kernel
            stack is formatted as follows:



                             +-----------+
                    KSP ---> !  OLD USP  !
                             !-----------!
                             ! OLD ! OLD !
                             ! VSM ! CAP !
                             !-----------!
                             !  OLD PC   !
                             !  OLD PS   !
                             +-----------+



                         Figure 5.  Kernel Stack


        ELF KERNEL PROGRAMMER'S GUIDE               Page  80
        ELF KERNEL PRIMITIVES


         Title:  $VRTI

         Description:

                 $VRTI is a primitive used to return  control  to  a
            calling   address  space.   This  primitive  assumes  no
            arguments (either in registers or on the caller's stack)
            and  may be used to return from a primitive (EMT) issued
            in another address space.  $VRTI releases the user stack
            space which was allocated by $VTRAP.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  81
        ELF KERNEL PRIMITIVES


         Title: $WAIT

         Function: WAIT for an event.

            $WAIT   :<process ID>,<event op-code>,<event data>
                       MSB (R0)        LSB (R0)        R1

         Description:

                 The $WAIT primitive is used to fetch the next event
            message from the process' message queue; if there are no
            entries on it's queue, the process is removed  from  the
            scheduler's  ready queue, causing the process to "sleep"
            until another process wakes it up by issuing the  signal
            primitive.   $WAIT  then returns to the process with the
            event message in registers R0 and R1 (i.e.  the  PID  is
            in the high byte, event op-code in the low byte, and the
            data word in R1).

         MACRO CALLING SYNTAX:

            $WAIT

        ELF KERNEL PROGRAMMER'S GUIDE               Page  82
        ELF KERNEL PRIMITIVES


         Title: $WAITS

         FUNCTION: WAIT for a Specific event op-code.

            $WAITS  <event op-code>:<process ID>,<event op-code>
                       LSB (R0)       MSB (R0)      LSB (R0)
                    <event data>
                         R1
         Description:

                 The $WAITS primitive is used to wait for a specific
            event  (as  opposed  to  $WAIT  which  waits until it is
            signalled by any event).  The event  op-code,  which  is
            passed  in  the  low byte of R0, denotes the event to be
            awaited.  Other events are left on  the  process'  event
            message  queue,  and are retrieved by a subsequent $WAIT
            or $WAITS.

                 As an example,  $WAITS  may  be  used  to  await  a
            specific I/O completion.

         Macro Calling Syntax:

            $WAITS  EVNTCD/R0

        ELF KERNEL PROGRAMMER'S GUIDE               Page  83
        ELF KERNEL PRIMITIVES


         Title: $XOR

         Function: eXclusive OR

            $XOR  <register>,<destination>

         Description:

                 The exclusive OR of the  register  and  destination
            operand  is stored in the destination address.  Contents
            of the register are unaffected.  The addressing mode  of
            the   destination   may   NOT   be   auto-increment   or
            auto-decrement.  The addressing mode of the  destination
            may   be   register,  register  deferred,  relative,  or
            relative deferred, with the exception that only register
            deferred mode may be used with R6.

         Macro Calling Syntax

            $XOR  REGISTER, DESTINATION       e.g.  $XOR   R2,R1

        ELF KERNEL PROGRAMMER'S GUIDE               Page  84
        ELF KERNEL PRIMITIVES


         Title: $ZAP

         Function: ZAP a process.

            $ZAP    <process ID>
                         R0

         description:

                 The $ZAP macro assumes a process  ID  argument  and
            passes it in R0 to the $ZAP primitive.

                 The $ZAP routine then releases  all  PCT's  at  the
            specified  level  and  below.   If the process ID is the
            active process or a zero, then an error occurs.

         Macro Calling Syntax:

            $ZAP            PID/R0

         Error Codes:

            INVZAP=321      ;SUICIDE NOT LEGAL ON $ZAP

        ELF KERNEL PROGRAMMER'S GUIDE               Page  85
        ELF KERNEL PRIMITIVES



            $ASDEV . . . . . . . . . . . 26
            $ASH . . . . . . . . . . . . 27
            $ASHC  . . . . . . . . . . . 28
            $AVS . . . . . . . . . . . . 29, 31, 46
            $AVSPF . . . . . . . . . . . 30
            $AVSPG . . . . . . . . . . . 31
            $CREAP . . . . . . . . . . . 32
            $CVAS  . . . . . . . . . . . 33
            $DEVC  . . . . . . . . . . . 34
            $DFDEV . . . . . . . . . . . 26, 36, 74
            $DIV . . . . . . . . . . . . 37
            $DIVU  . . . . . . . . . . . 38
            $DSABL . . . . . . . . . . . 39
            $DVAS  . . . . . . . . . . . 40
            $ENABLE  . . . . . . . . . . 41
            $ERROR . . . . . . . . . . . 42
            $EXV . . . . . . . . . . . . 43
            $FREEP . . . . . . . . . . . 44
            $FSEM  . . . . . . . . . . . 45
            $FVS . . . . . . . . . . . . 46
            $GAPID . . . . . . . . . . . 47
            $GETOD . . . . . . . . . . . 48
            $GPREG . . . . . . . . . . . 49
            $GTIME . . . . . . . . . . . 50
            $HIO . . . . . . . . . . . . 51
            $ISEM  . . . . . . . . . . . 52
            $IVAS  . . . . . . . . . . . 53
            $LOOP  . . . . . . . . . . . 54
            $MUL . . . . . . . . . . . . 55
            $MULU  . . . . . . . . . . . 56
            $P (semaphore) . . . . . . . 57, 60
            $PMAP  . . . . . . . . . . . 58
            $REMTX . . . . . . . . . . . 59
            $REQ . . . . . . . . . . . . 60
            $RLDEV . . . . . . . . . . . 61
            $RSTRP . . . . . . . . . . . 62
            $RTI . . . . . . . . . . . . 63
            $SEMTX . . . . . . . . . . . 64
            $SETOD . . . . . . . . . . . 65
            $SGNLI . . . . . . . . . . . 63, 66
            $SIGNL . . . . . . . . . . . 67
            $SIO . . . . . . . . . . . . 26, 36, 51, 68
            $SPREG . . . . . . . . . . . 70
            $STIME . . . . . . . . . . . 50, 71
            $SUSPR . . . . . . . . . . . 72
            $THAWP . . . . . . . . . . . 73
            $UDDEV . . . . . . . . . . . 74
            $V (semaphore) . . . . . . . 75
            $VMAP  . . . . . . . . . . . 76
            $VMOV/B  . . . . . . . . . . 77
            $VRTI  . . . . . . . . . . . 80
            $VTRAP . . . . . . . . . . . 78

        ELF KERNEL PROGRAMMER'S GUIDE               Page  86
        ELF KERNEL PRIMITIVES


            $WAIT  . . . . . . . . . . . 81, 82
            $WAITS . . . . . . . . . . . 82
            $XOR . . . . . . . . . . . . 83
            $ZAP . . . . . . . . . . . . 84

            .RAD50 . . . . . . . . . . . 36

            Address Space  . . . . . . . 33, 40, 53, 77
            Assign a device  . . . . . . 26

            Capability . . . . . . . . . 26, 32, 64, 68, 77
            Completion code  . . . . . . 26, 36, 61, 74
            Completion codes . . . . . . 32

            Define a device  . . . . . . 36
            Device Characteristics code assignments 35
            Device control table . . . . 36
            Device name  . . . . . . . . 26, 36, 61, 74

            EMT code . . . . . . . . . . 59
            EMT exit . . . . . . . . . . 64
            Entry point  . . . . . . . . 32
            Error codes  . . . . . . . . 42, 44
            Event data . . . . . . . . . 66, 81
            Event Data . . . . . . . . . 60
            Event descriptor . . . . . . 67
            Event message  . . . . . . . 81
            Event message queue  . . . . 67, 81, 82
            Event op-code  . . . . . . . 66, 67, 68, 71, 81, 82
            Event Op-code  . . . . . . . 60
            Event op-code  . . . . . . . 32

            Free a semaphore . . . . . . 45
            Freeze process . . . . . . . 44
            Frozen processes . . . . . . 62, 73

            Get process register . . . . 49

            Halt I/O . . . . . . . . . . 51

            I/O request block  . . . . . 68
            Initialize semaphore . . . . 52
            Inter process ports  . . . . 68
            Interrupts . . . . . . . . . 39, 41
            INVPID . . . . . . . . . . . 44
            INVSIG . . . . . . . . . . . 67
            INVZAP . . . . . . . . . . . 84
            IORB . . . . . . . . . . . . 51, 68

            PID  . . . . . . . . . . . . 26, 44, 66, 67, 81, 84
            Priority . . . . . . . . . . 32
            Process ID . . . . . . . . . 32, 44, 47, 67, 84


        ELF KERNEL PROGRAMMER'S GUIDE               Page  87
        ELF KERNEL PRIMITIVES


            Release a device . . . . . . 61
            Resources  . . . . . . . . . 52, 57, 75
            Restarting a process . . . . 62
            Return from interrupt  . . . 63

            Scheduler  . . . . . . . . . 63
            Semaphore  . . . . . . . . . 29, 36, 43, 45, 52, 57, 60, 75
            SERIVS . . . . . . . . . . . 43, 45, 57, 75
            SERSXH . . . . . . . . . . . 52
            Set process register . . . . 70
            Set timer  . . . . . . . . . 71
            Signal a process . . . . . . 67
            Signal process immediate . . 66
            Start I/O  . . . . . . . . . 68
            STQERR . . . . . . . . . . . 71

            Thaw process . . . . . . . . 73
            Ticks  . . . . . . . . . . . 48, 65
            Time of day  . . . . . . . . 48
            Timer interval . . . . . . . 50, 71

            Undefine device  . . . . . . 74
            Unit number  . . . . . . . . 26, 36, 61, 74

            VSMID  . . . . . . . . . . . 29, 30, 31, 32, 33, 40, 46, 47, 53, 64, 77

            Wait for event . . . . . . . 81
            Wait for specific event  . . 82

            Zap a process  . . . . . . . 84

        ELF KERNEL PROGRAMMER'S GUIDE               Page  88
        SYSTEM TABLES AND DATA STRUCTURES


        V  System Tables and Data Structures


        V.1  DCT - Device Control Table

             For each I/O device there exists  a  device  control  table
        which  is  accessed by the IOX process on behalf of the user and
        by the I/O driver on behalf of the device.

             There are five types of DCTs corresponding to  character-in
        devices,  character-out devices, block addressable devices, byte
        addressable devices and inter-process ports.  These  five  types
        of   DCTs  are  illustrated  in  figures  1.1,  1.2,  1.3,  1.4.
        Following is a description of the DCT entries:


         DCTW0-N:    Device  Work  Words.   (Dynamic,  modified  by  the
                     device  driver).   Words  used  by  the  driver for
                     storage   to   allow   segmented   and    reentrant
                     operations.  This allows the same driver to be used
                     for a set of identical devices.

         DCTQH:      Device Queue Head.  (Dynamic, modified by $SIO  and
                     IOX).   A word which points to the head I/O request
                     queue element.  Zero implies the queue is empty.

         DCTQT:      Device Queue Tail.  (Dynamic, modified by $SIO  and
                     IOX).   A word which points to the tail I/O request
                     queue element.

         DCTNAM:     Device Name.   (Static).   A  word  containing  the
                     RAD50 code for the 3-character device name.

         DCTUN:      Device Unit Number.  (Static).  A  word  containing
                     the  device  unit number, which may range from 0 to
                     65,534 (radix 10).

         DCTCSR:     Device   Unibus   Address.    (Static).    A   word
                     containing  the unibus address of the device status
                     register.  This address is periodically  referenced
                     by  the  system  to  determine  if  the  device  is
                     on-line.

         DCTWST:     DCT Wait State.  (Dynamic,  modified  by  IOX).   A
                     byte used to indicate the op-code requested for the
                     DCT at the time the IOX issues the $WAIT primitive.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  89
        SYSTEM TABLES AND DATA STRUCTURES


         DCTCSI:     Channel Semaphore ID.  (Dynamic,  modified  by  IOX
                     and  the  device  driver).   A  byte containing the
                     semaphore ID associated  with  any  shared  channel
                     currently  allocated  to  the  device.   The device
                     driver may optionally release the channel and clear
                     the  byte;  e.g.  releasing the mag tape controller
                     after a rewind has been initiated  on  one  of  the
                     tape drives.

         DCTPC:      DCT Program Counter.  (Dynamic, modified  by  IOX).
                     A  word  containing the continuation address of the
                     IOX  procedure   to   which   control   should   be
                     transferred  when the op-code requested for the DCT
                     is received.

         DCTICT:     ICT  Vector  Table  Address.   (Static).   A   word
                     containing the address of the associated ICT vector
                     table.  The ICT vector table connects  the  DCT  to
                     all associated ICTs.

         DCTSTT:     Device State.  (Dynamic, modified by $SIO and IOX).
                     A  byte containing the current state of the device.
                     Bit 7, when 'ON' indicates the device  is  on-line.
                     Bit 6, when 'ON' indicates the device is initiated.
                     Bit 5, when 'ON' indicates the device  is  disabled
                     by the system.

         DCTIXC:     IOX Procedure Code.  (Static).  A  byte  containing
                     the  code  of  the  IOX  procedure  associated with
                     particular DCT.  Only one IOX  process  exists  for
                     all DCTs.

         DCTMPA:     Master process A.  (Dynamic, modified by $SIO).   A
                     byte  containing  the  process ID of one of the two
                     possible processes which may own (i.e., be assigned
                     to)  a  device.   A  content  of zero indicates the
                     device is currently unassigned.

         DCTMPB:     Master Process B.  (Dynamic, modified by $SIO).   A
                     byte  containing  the  process ID of one of the two
                     possible processes  which  may  own  a  device.   A
                     content  of  zero indicates the device is currently
                     unassigned.

         DCTIQA:     Active IORQE-A.  (Dynamic,  modified  by  IOX).   A
                     word,  containing  the address of the primary IORQE
                     currently  being  processed  by  the   IOX.    Upon
                     processing  an  IORQE,  the IOX removes the element
                     from the device queue and sets the element  address
                     in the DCTIQA word.  No active I/O request upon the
                     device is indicated when the content of  DCTIQA  is
                     zero.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  90
        SYSTEM TABLES AND DATA STRUCTURES


         DCTIQB:     Active IORQE-B.  (Dynamic,  modified  by  IOX).   A
                     word  containing the address of the secondary IORQE
                     currently being processed by the Inter-Process Port
                     IOX procedure.

         DCTABA:     Auxilliary Buffer Address.  (Dynamic,  modified  by
                     IOX).    A   word  containing  the  address  of  an
                     auxiliary buffer which is allocated to  the  device
                     by the IOX process.

         DCTABX:     Auxilliary Buffer Page Index.   (Dynamic,  modified
                     by  IOX).   A  byte  containing the page index of a
                     locked page which is allocated to the device by the
                     IOX process.

         DCTCHI:     Channel Index.  (Static).   A  byte  containing  an
                     index  into  the  logical  channel  table of shared
                     channel semaphore IDs.  A content  of  0  indicates
                     that  the  device  does not use a shared channel or
                     controller.

         DCTCAP:     Device Capabilities.  (Static).  A word  containing
                     a   description   of   the   device   capabilities.
                     Currently for character type  devices,  bit  15  is
                     used to indicate input only (0) or output only (1).

         DCTABS:     Auxilliary Buffer Maximum Size.  (Static).  A  word
                     containing  the maximum byte size of the auxilliary
                     buffer which the IOX may allocate to the device.

         DCTDVA:      Device  Driver   Address.    (Static).    A   word
                     containing  the  entry  point  of the device driver
                     procedure used to initiate I/O operations.

         DCTFCN:     Device Function.  (Dynamic, modified  by  IOX).   A
                     word  containing  the  requested I/O function.  The
                     lo-order byte contains the specified  I/O  function
                     code;   the   hi-order  byte  contains  the  device
                     dependent parameters.

         DCTSTA:     Device Status.  (Dynamic, modified by IOX  and  the
                     device  driver).   A  word containing the status of
                     the device and I/O operation.   The  hi-order  byte
                     contains  the  status  code and error bit (bit 15);
                     the lo-order byte contains the error  category  and
                     I/O completion bit (bit 7).

         DCTBR:      Bytes Requested.  (Dynamic, modified  by  IOX).   A
                     word   containing   the   number  of  bytes  to  be
                     transferred or operations to be performed  for  the
                     specified function.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  91
        SYSTEM TABLES AND DATA STRUCTURES


         DCTBX:      Bytes Transferred.  (Dynamic, modified by  IOX  and
                     the  device  driver).  A word containing the number
                     of bytes transferred or  operations  performed  for
                     the completed I/O request.

         DCTECT:     Device Error Count.  (Dynamic, modified by IOX  and
                     the device driver).  A byte provided for use by the
                     device driver to maintain the I/O  operation  error
                     count.  May be used for all types of devices.

         DCTXRT:     Transfer Rate.  (Dynamic,  modified  by  $SIO).   A
                     byte  containing  the  transfer  rate for character
                     type devices.

         DCTMA:      Mate DCT.  (Static).  A word containing the address
                     of  the mate DCT for 'TTY' terminals.  A content of
                     zero indicates no mate exists.

         DCTA:       Active Transfer Address.  (Dynamic, modified by IOX
                     and  the  device  driver).   A  word containing the
                     address for the destination of the  next  character
                     input or the source of the next character output.

         DCTCNT:     Character Count.  (Dynamic, modified by IOX and the
                     device  driver).   A  word  containing  the current
                     number of output buffer characters  or  input  ring
                     buffer characters.

         DCTO:       Oldest  Input  Character.   (Dynamic,  modified  by
                     IOX).   A  word  containing  the  address of oldest
                     character in the input ring buffer.

         DCTS:       Ring  Buffer  Start  Address.   (Static).   A  word
                     containing the start address of the character input
                     ring buffer.

         DCTE:       Ring  Buffer  End  Address.   (Static).    A   word
                     containing the address of the first cell beyond the
                     character input ring buffer.

         DCTFCT:     Fill  Count.   (Dynamic,  modified  by  the  device
                     driver).   A  byte  containing  the  number of fill
                     characters currently needed for character output.

         DCTTCT:     Tab  Count.   (Dynamic,  modified  by  the   device
                     driver).    A   byte   containing   the  number  of
                     characters to the next tab stop.

         DCTPAH:     Physical Address High.  (Dynamic, modified by IOX).
                     A byte containing the hi-order 2 bits of the 18 bit
                     buffer address as right-justified information.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  92
        SYSTEM TABLES AND DATA STRUCTURES


         DCTPAL:     Physical Address Low.  (Dynamic, modified by  IOX).
                     A  word  containing  the lo-order 16 bits of the 18
                     bit buffer address.

         DCTBSZ:     Block  Size.   (Static).   A  word  containing  the
                     number  of  bytes per data block of the device.  An
                     entry of zero is illegal.

         DCTBHA:     Device Byte/Block Address High.  (Dynamic, modified
                     by  IOX).  A word containing the high order 16 bits
                     of the 32 bit block or byte address of the  device.
                     For  block  addressable  devices this is the device
                     block address, where the block length is defined by
                     the  DCTBSZ  field.   For  byte-addressable devices
                     this is the device byte address.

         DCTBLA:     Device Byte/Block Address Low.  (Dynamic,  modified
                     by IOX).  A word containing the lo-order 16 bits of
                     the 32 bit block or byte  address  of  the  device.
                     For  block  addressable  devices this is the device
                     block address, where the block length is defined by
                     the  DCTBSZ  field.   For  byte-addressable devices
                     this is the device byte address.

         DCTMBX:     Maximum   byte   transfer.    (Static).    A   word
                     containing the maximum number of bytes which may be
                     transferred by the device  in  one  operation.   An
                     entry of zero is illegal.

         DCTNBH:     Number  of  Blocks   High.    (Static).    A   word
                     containing  the  hi-order  16  bits  of  the 32 bit
                     number of device data blocks.   This  parameter  is
                     not necessary for byte addressable devices.

         DCTNBL:     Number of Blocks Low.  (Static).  A word containing
                     the lo-order 16 bits of the 32 bit number of device
                     data blocks.  This parameter is not  necessary  for
                     byte addressable devices.

        ELF KERNEL PROGRAMMER'S GUIDE               Page  93
        SYSTEM TABLES AND DATA STRUCTURES


        Figure 6.  Character Out DCT; front, middle, and tail sections.


                 CHARACTER OUT DCT

                  -FRONT SECTION-

                +-----------------+
        DCT:  0 !      DCTQH      !
                !-----------------!
              2 !      DCTQT      !
                !-----------------!
              4 !      DCTNAM     !
                !-----------------!
              6 !      DCTUN      !
                !-----------------!
             10 !      DCTCSR     !
                !-----------------!
             12 ! DCTCSI ! DCTWST !
                !-----------------!
             14 !      DCTPC      !
                !-----------------!
             16 !      DCTICT     !
                !-----------------!
             20 ! DCTIXC ! DCTSTT !
                !-----------------!
             22 ! DCTMPB ! DCTMPA !
                !-----------------!
             24 !      DCTIQA     !
                !-----------------!
             26 !      DCTIQB     !
                !-----------------!
             30 !      DCTABA     !
                !-----------------!
             32          ! DCTPRM !
                         +--------+

        ELF KERNEL PROGRAMMER'S GUIDE               Page  94
        SYSTEM TABLES AND DATA STRUCTURES


                 CHARACTER OUT DCT

                 -MIDDLE SECTION-

                +--------+
             32 ! DCTCHI !
                !-----------------!
             34 !      DCTCAP     !
                !-----------------!
             36 !      DCTABS     !
                !-----------------!
             40 !      DCTDVA     !
                !-----------------!
             42 !      DCTFCN     !
                !-----------------!
             44 !      DCTSTA     !
                !-----------------!
             46 !      DCTBR      !
                !-----------------!
             50 !      DCTBX      !
                +-----------------!
             52          ! DCTECT !
                         +--------+


                  -TAIL SECTION-

                +--------+
             52 ! DCTNTB !
                !-----------------+
             54 ! DCTCRF ! DCTLFF !
                !-----------------!
             56 !      DCTMA      !
                !-----------------!
             60 !      DCTA       !
                !-----------------!
             62 !      DCTCNT     !
                !-----------------!
             64 ! DCTTCT ! DCTFIL !
                !-----------------!
             66 !      DCTS       !
                !-----------------!
            100 !      DCTE       !
                !-----------------!
            102 !     DCT-OUT     !
                !      RING       !
                !     BUFFER      !
                +-----------------+

        ELF KERNEL PROGRAMMER'S GUIDE               Page  95
        SYSTEM TABLES AND DATA STRUCTURES


        Figure 7.  Character In DCT; front, middle, and tail sections.


                 CHARACTER IN DCT

                  -FRONT SECTION-

                +-----------------+
        DCT:  0 !      DCTQH      !
                !-----------------!
              2 !      DCTQT      !
                !-----------------!
              4 !      DCTNAM     !
                !-----------------!
              6 !      DCTUN      !
                !-----------------!
             10 !      DCTCSR     !
                !-----------------!
             12 ! DCTCSI ! DCTWST !
                !-----------------!
             14 !      DCTPC      !
                !-----------------!
             16 !      DCTICT     !
                !-----------------!
             20 ! DCTIXC ! DCTSTT !
                !-----------------!
             22 ! DCTMPB ! DCTMPA !
                !-----------------!
             24 !      DCTIQA     !
                !-----------------!
             26 !      DCTIQB     !
                !-----------------!
             30 !      DCTABA     !
                !-----------------!
             32          ! DCTPRM !
                         +--------+

        ELF KERNEL PROGRAMMER'S GUIDE               Page  96
        SYSTEM TABLES AND DATA STRUCTURES


                 CHARACTER IN DCT

                 -MIDDLE SECTION-

                +--------+
             32 ! DCTCHI !
                !-----------------!
             34 !      DCTCAP     !
                !-----------------!
             36 !      DCTABS     !
                !-----------------!
             40 !      DCTDVA     !
                !-----------------!
             42 !      DCTFCN     !
                !-----------------!
             44 !      DCTSTA     !
                !-----------------!
             46 !      DCTBR      !
                !-----------------!
             50 !      DCTBX      !
                +-----------------!
             52          ! DCTECT !
                         +--------+


                  -TAIL SECTION-

                +--------+
             52 !   0    !
                !-----------------+
             54 !        0        !
                !-----------------!
             56 !      DCTMA      !
                !-----------------!
             60 !      DCTA       !
                !-----------------!
             62 !      DCTCNT     !
                !-----------------!
            64  !      DCTO       !
                !-----------------!
            66  !      DCTS       !
                !-----------------!
           100  !      DCTE       !
                !-----------------!
            102 !     DCT-IN      !
                !      RING       !
                !     BUFFER      !
                +-----------------+

        ELF KERNEL PROGRAMMER'S GUIDE               Page  97
        SYSTEM TABLES AND DATA STRUCTURES


        Figure 8.  Block/Byte Addressable DCT; front, middle,
          and tail sections.


              BLOCK/BYTE ADDRESSABLE DCT

                  -FRONT SECTION-

                +-----------------+
        DCT:  0 !      DCTQH      !
                !-----------------!
              2 !      DCTQT      !
                !-----------------!
              4 !      DCTNAM     !
                !-----------------!
              6 !      DCTUN      !
                !-----------------!
             10 !      DCTCSR     !
                !-----------------!
             12 ! DCTCSI ! DCTWST !
                !-----------------!
             14 !      DCTPC      !
                !-----------------!
             16 !      DCTICT     !
                !-----------------!
             20 ! DCTIXC ! DCTSTT !
                !-----------------!
             22 ! DCTMPB ! DCTMPA !
                !-----------------!
             24 !      DCTIQA     !
                !-----------------!
             26 !      DCTIQB     !
                !-----------------!
             30 !      DCTABA     !
                !-----------------!
             32          ! DCTPRM !
                         +--------+

        ELF KERNEL PROGRAMMER'S GUIDE               Page  98
        SYSTEM TABLES AND DATA STRUCTURES


               BLOCK/BYTE ADDRESSABLE    DCT

                 -MIDDLE SECTION-
                +--------+
             32 ! DCTCHI !
                !-----------------!
             34 !      DCTCAP     !
                !-----------------!
             36 !      DCTABS     !
                !-----------------!
             40 !      DCTDVA     !
                !-----------------!
             42 !      DCTFCN     !
                !-----------------!
             44 !      DCTSTA     !
                !-----------------!
             46 !      DCTBR      !
                !-----------------!
             50 !      DCTBX      !
                +-----------------!
             52          ! DCTECT !
                         +--------+


                  -TAIL SECTION-
                +--------+
             52 ! DCTPAH !        
                !-----------------!
             54 !      DCTPAL     !
                !-----------------!
             56 !      DCTBSZ     !
                !-----------------!
             60 !      DCTBHA     !
                !-----------------!
            62  !      DCTBLA     !
                !-----------------!
            64  !      DCTMBX     !
                !-----------------!
            66  !      DCTNBH     !
                !-----------------!
            70  !      DCTNBL     !
                +-----------------+

        ELF KERNEL PROGRAMMER'S GUIDE               Page  99
        SYSTEM TABLES AND DATA STRUCTURES


        Figure 9.  Inter Process Port DCTs; front and tail sections.


              INTER PROCESS PORT DCTS

                  -FRONT SECTION-

                +-----------------+
        DCT:  0 !      DCTQH      !
                !-----------------!
              2 !      DCTQT      !
                !-----------------!
              4 !      DCTNAM     !
                !-----------------!
              6 !      DCTUN      !
                !-----------------!
             10 !      DCTCSR     !
                !-----------------!
             12 ! DCTCSI ! DCTWST !
                !-----------------!
             14 !      DCTPC     !
                !-----------------!
             16 !      DCTICT     !
                !-----------------!
             20 ! DCTIXC ! DCTSTT !
                !-----------------!
             22 ! DCTMPB ! DCTMPA !
                !-----------------!
             24 !      DCTIQA     !
                !-----------------!
             26 !      DCTIQB     !
                !-----------------!
             30 !      DCTABA     !
                !-----------------!
             32          ! DCTPRM !
                         +--------+


                 -TAIL SECTION-

                +--------+
             32 !   0    !
                !-----------------!
             34 !      DCTWQH     !
                !-----------------!
             36 !      DCTWQT     !
                !-----------------!
             40 !      DCTRQH     !
                !-----------------!
             42 !      DCTRQT     !
                +-----------------+

        ELF KERNEL PROGRAMMER'S GUIDE               Page 100
        SYSTEM TABLES AND DATA STRUCTURES


        V.2  ICT - Interrupt Control Table


             Each interrupt is  associated  with  an  Interrupt  Control
        Table.   This  organization  of  ICTs  and  DCTs  permits direct
        handling of the cases of  multiple  devices  per  interrupt  and
        multiple interrupts per device.

             Following is a description of the ICT entries:


         ICTIHX:     Interrupt Handler Transfer.  A  word  containing  a
                     "JSR  R0,  @(PC) plus" instruction which is used to
                     transfer control to the interrupt handler with  the
                     address of the ICT in 'R0'; ICTIHX is the target of
                     the associated interrupt vector.

         ICTIHA:     Interrupt Handler Address.  A word  containing  the
                     address of the associated interrupt handler.

         ICTIVA:     Interrupt Vector Address.  A  byte  containing  the
                     address  of  the  associated  interrupt  vector.  A
                     content of zero indicates a null vector.

         ICTIVP:     Interrupt Vector Priority.  A byte  containing  the
                     priority of the associated interrupt vector.

         ICTCSR:     Interrupt  Bus  Address.   A  word  containing  the
                     unibus  address  of  the interrupt status register.
                     This address is referenced by the IOX to  determine
                     if the interrupt is on-line.

         ICTINA:     Interrupt Initialize Address.   A  word  containing
                     the address of the procedure used to initialize the
                     interrupt.

         ICTDCT:     DCT Vector Table Address.  A  word  containing  the
                     address  of  the  associated DCT vector table.  The
                     DCT vector table connects the ICT  to  all  related
                     DCTs.

        ELF KERNEL PROGRAMMER'S GUIDE               Page 101
        SYSTEM TABLES AND DATA STRUCTURES


           

                +-----------------!
             -4 !      ICTIHX     !
                !-----------------!
             -2 !      ICTIHA     !
                !-----------------!
              0 ! ICTIVP ! ICTIVA !
                +-----------------!
              2 !      ICTCSR     !
                !-----------------!
              4 !      ICTINA     !
                !-----------------!
              6 !      ICTDCT     !
                +-----------------+



        Figure 10.  Interrupt Control Table

        ELF KERNEL PROGRAMMER'S GUIDE               Page 102
        SYSTEM TABLES AND DATA STRUCTURES


        V.3  IORB - I/O Request Block


             Each I/O request by a user process must be accompanied by a
        user defined I/O Request Block.

             Following is a description of IORB entries:


         IRNAM:      Device Name.  A word set to the RAD50  device  name
                     code by the user prior to issuing the $SIO request.

         IRUNIT:     Device Unit Number.  A word set to the  device-unit
                     number  by  the  user  prior  to  issuing  the $SIO
                     request.  The maximum allowed unit number is 65,534
                     (radix 10).

         IROPC:      I/O Op-Code.  A byte set to a  desired  op-code  by
                     the  user  prior to issuing the $SIO request.  Upon
                     completion of the I/O request the user is signalled
                     with the specified op-code in R0 and the address of
                     the IORB in R1.

         IRUVI:      User Buffer Virtual Address Space ID.  A byte,  set
                     to  the  address  space  ID  of the associated data
                     buffer by  the  user  prior  to  issuing  the  $SIO
                     request.   A  value of zero results in a default to
                     the current address space ID of the caller.

         IRUVA:      User Buffer Virtual Address.  A  word  set  to  the
                     address  of  the  data  buffer by the user prior to
                     issuing the $SIO request.

         IRFCN:      I/O Function.  A word set to the requested function
                     code by the user prior to issuing the $SIO request.
                     The lo-order byte is the  function  code;  requests
                     are placed at the head of the device queue if bit 7
                     is  'ON'.   The  hi-order  byte   contains   device
                     dependent  information;  requests  on 'TTY' devices
                     require that the input (0) or output (1) device  be
                     specified via bit 15.

         IRBR:       Bytes Requested.   A  word  set  to  the  requested
                     number of bytes or I/O operations by the user prior
                     to issuing the $SIO request.

        ELF KERNEL PROGRAMMER'S GUIDE               Page 103
        SYSTEM TABLES AND DATA STRUCTURES


         IRSTA:      I/O Status.  A  word  set  to  the  status  of  the
                     requested   I/O   operation  at  the  time  of  I/O
                     completion.   Until  completion,  the  status  word
                     remains  unchanged  and  must be initialized by the
                     user if required.  The hi-order byte  contains  the
                     status  code  and  error bit (bit 15); the lo-order
                     byte contains the error category and completion bit
                     (bit 7).

         IRBX:       Bytes Transferred.  A word set at  completion  time
                     to  the  number  of  bytes transferred or number of
                     operations performed.  Until  completion  the  word
                     remains  unchanged  and  must be initialized by the
                     user if required.

         IRBHA:      Device Byte  Address  High.   A  word  set  to  the
                     hi-order  16 bits of the 32 bit device byte address
                     by the user prior to issuing the $SIO request.  For
                     non-addressable,  this  entry  should be zero.  For
                     block oriented devices a "device address error"  is
                     returned  to  the user if the byte address does not
                     lie in a block boundary.

         IRBLA:      Block Address Low.  A word set to the  lo-order  16
                     bits  of the 32 bit block address by the user prior
                     to issuing the $SIO request.   For  non-addressable
                     devices, this entry should be zero.

        ELF KERNEL PROGRAMMER'S GUIDE               Page 104
        SYSTEM TABLES AND DATA STRUCTURES


            


                +-----------------+
              0 !      IRNAM      !
                !-----------------!
              2 !      IRUNIT     !
                !-----------------!
              4 ! IRUVI  ! IROPC  !
                !-----------------!
              6 !      IRUVA      !
                !-----------------!
             10 !      IRFCN      !
                !-----------------!
             12 !      IRBR       !
                !-----------------!
             14 !      IRSTA      !
                !-----------------!
             16 !      IRBX       !
                !-----------------!
             20 !      IRBHA      !
                !-----------------!
             22 !      IRBLA      !
                +-----------------+



        Figure 11.  IORB I/O Request Block

        ELF KERNEL PROGRAMMER'S GUIDE               Page 105
        SYSTEM TABLES AND DATA STRUCTURES


        V.4  IORQE - I/O Request Queue Element


             Each I/O request is queued up by the $SIO primitive on  the
        device  queue  of  the appropriate DCT.  The format of the queue
        element  is  basically  the  originating  IORB  prefaced  by   a
        descriptor of the IORB.

             Following is a description of IORQE entries.


         IQLNK:      Queue Element Link.  A word containing the  address
                     of  the  next IORQE in the device queue.  A content
                     of zero indicates the current element is  the  tail
                     element.

         IWRSET:     I/O Reset.  A word set  to  non-zero  when  an  I/O
                     request  is  nulled in which case the I/O operation
                     is not initiated and the user is not signalled.  An
                     I/O  operation  in progress for a nulled request is
                     carried to completion.

         IQIPI:      IORB Process ID.  A byte containing the ID  of  the
                     user  process  which generated the $SIO request for
                     the associated IORB.

         IQIVI:      IORB Virtual Address Space ID.  A  byte  containing
                     the address space ID of the associated IORB.

         IQIVA:      IORB  Virtual  Address.   A  word  containing   the
                     address of the associated IORB.

         IQNAM:      Device Name.  A word containing  the  RAD50  device
                     name code.

         IQUNIT:     Unit Number.  A word  containing  the  device  unit
                     number.

         IQOPC:      I/O Op-code.  A byte containing the user  specified
                     op-code  to  be  issued  upon  the  I/O  completion
                     signal.

         IQUVI:      User Buffer  Virtual  Address  Space  ID.   A  byte
                     containing    the   address   space   ID   of   the
                     user-specified data buffer.

         IQUVA:      User Buffer Virtual Address.  A word containing the
                     virtual  address of the user specified data buffer.
                     This  word  is   updated   during   segmented   I/O
                     operations.

        ELF KERNEL PROGRAMMER'S GUIDE               Page 106
        SYSTEM TABLES AND DATA STRUCTURES


         IQFCN:      I/O Function.  A word containing the requested  I/O
                     function.  The lo-order byte contains the specified
                     I/O function code; the hi-order byte  contains  the
                     device dependent parameters.

         IQBR:       Bytes Requested.  A word containing the  number  of
                     bytes   to  be  transferred  or  operations  to  be
                     performed for the specified function.  This word is
                     updated during segmented I/O operations.

         IQSTA:      Status.  A word containing the status  of  the  I/O
                     operation.   IQSTA  is  only  set  for IOX detected
                     errors, at which time the I/O request is aborted.

         IQBX:       Bytes transferred.  A word containing the number of
                     bytes  transferred  or I/O operations performed for
                     the specified I/O request.  This  word  is  updated
                     for segmented I/O.

         IQBHA:      Device Byte Address High.  A  word  containing  the
                     hi-order 16 bits of the 32 bit device byte address.
                     This word is updated for segmented I/O.

         IQBLA:      Device Byte Address Low.   A  word  containing  the
                     lo-order 16 bits of the 32 bit device byte address.
                     This word is updated for segmented I/O.

        ELF KERNEL PROGRAMMER'S GUIDE               Page 107
        SYSTEM TABLES AND DATA STRUCTURES


           


                +-----------------+
              0 !      IQLNK      !
                !-----------------!
              2 !      IQRSET     !
                !-----------------!
              4 ! IQIVI  ! IQIPI  !
                !-----------------!
              6 !      IQIVA      !
                !-----------------!
             10 !      IQNAM      !
                !-----------------!
             12 !      IQUNIT     !
                !-----------------!
             14 ! IQUVI  ! IQOPC  !
                !-----------------!
             16 !      IQUVA      !
                !-----------------!
             20 !      IQFCN      !
                !-----------------!
             22 !      IQBR       !
                !-----------------!
             24 !      IQSTA      !
                !-----------------!
             26 !      IQBX       !
                !-----------------!
             30 !      IQBHA      !
                !-----------------!
             32 !      IQBLA      !
                !-----------------!
             34 !        ! IQPGN  !
                !-----------------!
             36 !        !        !
                !-----------------!
             40 !        !        !
                !-----------------!
             42 !        !        !
                +-----------------+



        Figure 12.  IORQE I/O Request Queue Element.

        ELF KERNEL PROGRAMMER'S GUIDE               Page 108
        SYSTEM TABLES AND DATA STRUCTURES


        V.5  DCTNT - Device Name Table


             The device  name  table  is  used  by  the  I/O  management
        primitives  to  map a user specified device name and device unit
        number into a DCT address.  The table is accessed via the global
        '$DCTNT'.

             The first word of the device name table contains the number
        of  device name entries.  The remainder of the table consists of
        two word device name entries.  The  first  word  of  each  entry
        contains  the  device  name  RAD50 code; the second word of each
        entry contains the address of the associated device unit  table.




                +-----------------+
        $DCTNT: !    # ENTRIES    !
                !-----------------!
                !    RAD50 NAME   !
                !-----------------!
                !  UNIT TBL ADR   !
                !-----------------!
                !    RAD50 NAME   !
                !-----------------!
                !  UNIT TBL ADR   !
                !-----------------!
                !       ETC.      !
                .                 .
                .                 .
                .                 .



        Figure 13.  Device Name Table.

        ELF KERNEL PROGRAMMER'S GUIDE               Page 109
        SYSTEM TABLES AND DATA STRUCTURES


        V.6  DCTUT - Device Unit Table


             For each device name there exists a device unit table which
        contains the DCT address for each of the device units.


            Word 0:     Maximum unit for which a DCT address exists.

            Word 1:     Device name semaphore ID.

            Word 2,...,N:  The remaining words contain the DCT addresses
                        for  the  relative  unit  number  positions.   A
                        content of zero indicates no DCT exists for  the
                        given unit number.  An odd address indicates the
                        DCT has not been  defined  for  the  given  unit
                        number.




                +-----------------+
        $DCTUT: !     # UNITS     !
                !-----------------!
                ! DEV NAME SEM ID !
                !-----------------!
                ! UNIT 0 DCT ADR  !
                !-----------------!
                .                 .
                .                 .
                .                 .
                !-----------------!
                ! UNIT N DCT ADR  !
                +-----------------+



        Figure 14.  Device Unit Table.

        ELF KERNEL PROGRAMMER'S GUIDE               Page 110
        SYSTEM TABLES AND DATA STRUCTURES


        V.7  DCTCT - Device Channel Table


             The  device  channel  table  is  used  to  coordinate   I/O
        operations  within  the  context  of  shared channels and shared
        controllers.  A set of logical  channels  are  declared  at  DCT
        generation time, and at run time a semaphore is assigned to each
        of the logical channels.


            Word 0:     Number of logical channels.  Channel  0  is  not
                        used.

            Bytes  3,...,N:   These  bytes  correspond  to  the  logical
                        channels,  each  byte  contains the semaphore ID
                        assigned to the associated channel.  




                +-----------------+
        $DCTCT: !  # CHANNELS     !
                !-----------------!
                ! CHNL 1 !        !
                ! SEMID1 !   0    !     
                !-----------------!
                ! CHNL 3 ! CHNL 2 !
                ! SEMID  ! SEMID  !
                !-----------------!    
                .                 .
                .                 .
                .                 .
                !-----------------!
                ! CHNL N !CHNL N-1!
                ! SEMID  ! SEMID  !
                +-----------------+



        Figure 15.  Device Channel Table.

        ELF KERNEL PROGRAMMER'S GUIDE               Page 111
        SYSTEM TABLES AND DATA STRUCTURES


        V.8  DCTVT - DCT Vector Table



             Each ICT is connected to a group of zero or  more  DCTs  by
        means  of  a  list of DCT addresses.  The address of the list is
        contained in the ICT word labelled ICTDCT.

             The first word of the DCTVT Table contains  the  number  of
        related DCTs; the remaining words contain the DCT addresses.  




                +-----------------+
        $DCTVT: !    # ENTRIES    !
                !-----------------!
                !     DCT ADR     !
                !-----------------!
                .                 .
                .                 .
                .                 .
                !-----------------!
                !     DCT ADR     !
                +-----------------+



        Figure 16.  DCT Vector Table

        ELF KERNEL PROGRAMMER'S GUIDE               Page 112
        SYSTEM TABLES AND DATA STRUCTURES


        V.9  ICTVT - ICT Vector Table


             Each DCT is connected to a group of zero or  more  ICTs  by
        means of a list of ICT addresses.  The address of the ICT vector
        table is specified by the DCT word labelled DCTICT.

             The first word of ICTVT contains the  number  of  specified
        ICTs; the remaining words contain the ICT addresses.  




                +-----------------+
        $ICTVT: !    # ENTRIES    !
                !-----------------!
                !     ICT ADR     !
                !-----------------!
                .                 .
                .                 .
                .                 .
                !-----------------!
                !     ICT ADR     !
                +-----------------+



        Figure 17.  ICT Vector Table.

        ELF KERNEL PROGRAMMER'S GUIDE               Page 113
        SYSTEM TABLES AND DATA STRUCTURES


                +-----------------+
                !      LINK *-------------->  NEXT ELEMENT      
                !-----------------!
                !   OP   !  PID   !             
                !-----------------!
                !      DATA       !
                +-----------------+


        Figure 18.  Process Message Queue Elements.








                 +-----------------+
        $FRSEM:  !      HEAD       ! ;POINTER TO FIRST FREE
                 !                 !  ELEMENT
                 !-----------------!
                 !      NFSEM      ! ;NUMBER OF FREE ELEMENTS
                 !-----------------!
                 !      PNTR       ! ;POINTER TO NEXT FREE
                 !                 !  ELEMENT
                 !-----------------!
                 !      PCTID      !
                 !-----------------!
                 !      DATA       !
                 !-----------------!
                 !      PNTR       !
                 !-----------------!
                 !      PCTID      !
                 !-----------------!
                 !      DATA       !
                 !-----------------!
                 !      ETC.       !


        Figure 19.  Free Semaphore Elements

        ELF KERNEL PROGRAMMER'S GUIDE               Page 114
        SYSTEM TABLES AND DATA STRUCTURES


                 +-----------------+
        $SIDTB:  !      NSEMS      !
                 !-----------------!
                 !      000001     ! ;A ONE INDICATES A FREE
                 !                 !  SEMAPHORE
                 !-----------------!
                 !      000000     ! ;RESERVE STORAGE FOR
                 !                 !  SEMAPHORE
                 !-----------------!
                 !      000001     !
                 !-----------------!
                 !      000000     !
                 !-----------------!
                 !      ETC.       !


        Figure 20.  Semaphore Storage Allocation.








                 +-----------------+
              0  !      HEAD       ! ;POINTER TO FIRST QUEUED
                 !                 !  ELEMENT
                 !-----------------!
              2  !      TAIL       ! ;POINTER TO LAST QUEUED
                 !                 !  ELEMENT
                 +-----------------+


        Figure 21.  Semaphore ID.

        ELF KERNEL PROGRAMMER'S GUIDE               Page 115
        SYSTEM TABLES AND DATA STRUCTURES


                 +-----------------+
              0  !        !   PID  !
                 !-----------------!
              2  !    TIME VALUE   !
                 !-----------------!
              4  !       LINK      ! ;LINK TO NEXT QUEUE
                 !                 !  ELEMENT
                 +-----------------+


        Figure 22.  Timer Queue Element.








                 +-----------------+
        PRQ:  0  !     PRQNXT      ! ;POINTER TO NEXT PRQ+2
                 !-----------------!
              2  !      PRQHD      ! ;POINTER TO HEAD PCT
                 !-----------------!
              4  !      PRQTL      ! ;POINTER TO TAIL PCT
                 !-----------------!
              6  !        ! PRQID  !
                 +-----------------+


        Figure 23.  Process Ready Queue.

        ELF KERNEL PROGRAMMER'S GUIDE               Page 116
        SYSTEM TABLES AND DATA STRUCTURES


                 +-----------------+
        PCT:  0  !      PCTNXT     !
                 !-----------------!     Kernel Stack
              2  ! PCTWT  ! PCTCAP !
                 !-----------------!       +------+
              4  !      PCTKSP  *--------> !  R0  !
                 !-----------------!       !------!
              6  !      PCTPRQ     !       !  R1  !
                 !-----------------!       !------!
             10  ! PCTVID ! PCTPID !       !  R2  !
                 !-----------------!       !------!
             12  !      PCTCP0     !       !  R3  !
                 !-----------------!       !------!
             14  !                 !       !  R4  !
                 !      PCTTIM     !       !------!
             16  !                 !       !  R5  !
                 !-----------------!       !------!
             20  !      PCTPGF     !       !  UR6 !
                 !-----------------!       !------!
             22  !      PCTPRI     !       !  PC  !
                 !-----------------!       !------!
             24  ! PCTSL  ! PCTCL  !       !  PS  !
                 !-----------------!       !------!
             26  ! PCTCOP ! PCTCID !       !      !
                 !-----------------!
             30  !      PCTMQH     !
                 !-----------------!
             32  !      PCTMQT     !
                 !-----------------!
             34  !      PCTPRV     !
                 !-----------------!
             36  !      PCTTAG     !
                 !-----------------!
             40  !                 !
                 !      PCTIOT     !
             42  !                 !
                 !-----------------!
             44  !                 !
                 !      PCTTRP     !
             46  !                 !
                 !-----------------!
             50  !                 !
                 !      PCTFPU     !
             52  !                 !
                 !-----------------!
             54  !      70707      !
                 +-----------------+


        Figure 24.  Process Control Table

        ELF KERNEL PROGRAMMER'S GUIDE               Page 117
        SYSTEM TABLES AND DATA STRUCTURES


        +--------+                 +------+
        ! PCTKSP ---------->     0 !  R0  !
        +--------+                 !------!
                                 2 !  R1  !
                                   !------!
                                 4 !  R2  !
                                   !------!
                                 6 !  R3  !
                                   !------!
                                10 !  R4  !
                                   !------!
                                12 !  R5  !
                                   !------!
                                14 !  UR6 !
                                   !------!
                                16 !  PC  !
                                   !------!
                                18 !  PS  !
                                   !------!    ---
                                   !//////!     ^
                                   !------!     !
                                   !//////!     !
                                   !------!    Saved stack information
                                               (process-dependent)


        Figure 25.  Process Control Table; Kernel Stack Formats 
           for descheduled or interrupted processes.

        ELF KERNEL PROGRAMMER'S GUIDE               Page 118
        SYSTEM TABLES AND DATA STRUCTURES


        VI  KERNEL PROCESS ERROR CODES

        STORAGE MANAGEMENT ERROR CODES 200-247


        PRG     =       206     PURGE LOCKED PAGE
        KAC     =       207     ATTEMPT TO ACCESS KRWL
                                  ADR SPACE
        UPV     =       210     UNPRIVILEGED CALLER
        LK      =       211     TRIED TO LOCK AVAILABLE PAGE
        SHR     =       215     SHARE LINK ERROR
        VSM     =       216     UNDEFINED VIRTUAL STORAGE MAP
        PST     =       217     BAD PHYSICAL STORAGE TABLE INDEX
        KSP     =       220     KERNEL STACK POINTER 
                                UPDATED ON PAGE FAULT
        VPG     =       221     UNDEFINED OR UNALLOCATED
                                  VIRTUAL PAGE
        PLF     =       222     PAGE LENGTH FAULT
        UKF     =       223     UNKNOWN PAGE FAULT CAUSE
        SFQ     =       224     ALL SFD Q ELEMENTS IN USE
        SSA     =       225     BAD SFD OR SSA
        SDV     =       226     SWAP FILE DEVICE ERROR
        PMP     =       227     PMAP OF UNAVAILABLE PST
        VMP     =       230     VMAP OF IN USE VPA
        SFD     =       231     BAD SWAP FILE ID
        DPG     =       232     VPA ALREADY DEFINED
        VPA     =       233     BAD VIRTUAL PAGE NUMBER
        NRF     =       234     NON-RESIDENT FLT ON
                                  RESIDENT PAGE
        VID     =       237     BAD VSM ID NUMBER
        WP      =       240     WRITE TO READ ONLY PAGE
        PF      =       241     ILLEGAL MEMORY MANAGEMENT
                                  TRAP

        ELF KERNEL PROGRAMMER'S GUIDE               Page 119
        KERNEL ERROR CODES


        VIRTUAL STORAGE ALOCATION ERROR CODES 250-257


        AVSERC  =       250     INVALID ALLOCATION COUNT
                                 SPECIFIED
        DVSER   =       251     ILLEGAL VSM SPEC. IN DELETE VSM
        FVSER   =       252     ATTEMPT ALOC/FREE VIRTUAL
                                 MORE THAN 32K



        PROCESSOR MANAGEMENT ERROR CODES 300-337


        SYSFRZ  =       300     SYSTEM TOP-LEVEL PROCESS FROZEN.
        SMQERR  =       301     SYSTEM MQE STORAGE EXHAUSTED.
        REGERR  =       302     REGISTER CODE INVALID IN $SPREG
        SXSERR  =       303     CAN'T $SEXIT SELF
        INVTID  =       304     INVALID TRAP IDENTIFIER
        TSTERR  =       305     TRAP EXIT ALREADY SET
        TNSERR  =       306     CAN'T RESET UNSET TRAP EXIT
        STQERR  =       314     TIMER QUEUE ELEMENTS EXHAUSTED
        IVEMT   =       315     ERROR CODE FOR INVALID EMT
        SERIVS  =       316     INVALID SEMAPHORE ID
        SERSXH  =       317     SEMAPHORE STORAGE EXHAUSTED
        INVPID  =       320     INVALID PROCESS ID
                                 ON FREEP OR ZAP
        INVZAP  =       321     SUICIDE NOT LEGAL ON $ZAP
        INVSIG  =       322     INVALID $SIGNAL PARAMETER
        INVTHP  =       333     INVALID THAW - PROCESS
                                 NOT FROZEN



        SYSTEM INITIALIZE ERROR CODES 350-357


        PFERR   =       350     POWER FAILURE



        SYSTEM UTILITY ERROR CODES 340-357


        ERRNIM  =       340     UNIMPLEMENTED KERNEL EMT CALL
        ERRTRP  =       342     BUS ERROR
        ERRILL  =       344     ILLEGAL INSTRUCTION
        ERRUIO  =       346     UN-IMPLEMENTED USER EMT CALL

        ELF KERNEL PROGRAMMER'S GUIDE               Page 120
        KERNEL ERROR CODES


        I/O AUXILARY ERROR CODES 260-267


        RGBFE   =       261     RING BUFFER ERROR



        I/O MANAGER ERROR CODES 270-277


        SYSOL   =       272     SYSTEM UNABLE TO CREATE IOX
        DCTERR  =       273     DCT FORMAT ERROR
        IXNFZ   =       270     ERRONEOUS IOX FROZE OP-CODE
        IOXFE   =       271     IOX FROZE BUT NO ACTIVE DCT




        ELF KERNEL PROGRAMMER'S GUIDE               Page 121
       Appendix A


                                APPENDIX A
                 PDP-11 Storage Management Register Formats




                   Table A1.  PAR/PDR Address Assignments

        -----------------------------------------------------------
         Kernal Active Page Registers ! User Active Page Registers
        -----------------------------------------------------------
          No.      PAR        PDR     ! No.      PAR        PDR     
        -----------------------------------------------------------
           0     772340    772300     ! 0      777640    777600
           1     772342    772302     ! 0      777640    777602
           2     772344    772304     ! 2      777644    777604
           3     772346    772306     ! 3      777646    777606
           4     772350    772310     ! 4      777650    777610
           5     772352    772312     ! 5      777652    777612
           6     772354    772314     ! 6      777654    777614
           7     772356    772316     ! 7      777656    777616
        -----------------------------------------------------------






                  !              !                    !       NDX      !
         15     12!11           7!   6               0!                !
        +---------!--------------!--------------------!                !
        !/////////!              ! PAF                !                !
        +--!------!--!--!--!--!--!--!--!--!--!--!--!--!  !  !  !  !  ! +

                  !                                                    !
                  +----------------------------------------------------+
                                             !
                                             +-- 18 BIT ADDRESS

             Figure A1.  Page Address Register






         15 14                 8  7  6  5  4  3  2  1  0
        +-----------------------------------------------+
        !  !          PAF       !//! W!/////!ED! ACF !//!
        +--!--!--!--!--!--!--!--!--!--!--!--!--!--!--!--+

                    Figure A2.  Page Descriptor Register

        ELF KERNEL PROGRAMMER'S GUIDE               Page 122
       Appendix A


                               UNIBUS #777572

         15 14 13 12        9  8  7  6  5  4  3     1  0
        +-----------------------------------------------+
        !  !  !  !///////////!  !//!/////!//!////////!//!
        +-----------------------------------------------+
          ^  ^  ^              ^    !   !   !        ! ^
          !  !  !              !    +---+   +--------+ !
          !  !  !              !      !          !     ENABLE MANAGEMENT
          !  !  !              !      !          +-----------PAGE NUMBER
             
          !  !  !              !      +-----------------------------MODE
          !  !  !              +------------------------ACCESS VIOLATION
          !  !  !                                     MAINTENANCE MODE
          !  !  +----------------------------------------ABORT-READ ONLY
          !  +-----------------------------------ABORT-PAGE LENGTH ERROR
          +-------------------------------------------ABORT-NON-RESIDENT


                Figure A3.  Format of Status Register #0 (SRO)







                    Table A2.  Access Control Field Keys


        ----------------------------------------------------------------
        AFC    KEY        DESCRIPTION               FUNCTION
        ----------------------------------------------------------------
         00     0     Non-resident           Abort any attempt to access
                                              this non-resident page
         01     2     Resident read-only     Abort any attempt to write
                                              into this page
         10     4     (unused)               Abort all Accesses.
         11     6     Resident read/write    Read or Write allowed.  No
                                              trap or abort occurs.
        ----------------------------------------------------------------

        ELF KERNEL PROGRAMMER'S GUIDE               Page 123
       Appendix A


                               UNIBUS #777576

         15                                            0
        +-----------------------------------------------+
        !             16-BIT VIRTUAL ADDRESS            ! ADDRESS
        +-----------------------------------------------+ 777576


           Figure A4.  Format of Status Register #2 (SR2)






         15!14      !        ! 8! 7  6! 5  4  3! 2     0
        +--!--!--!--!--!--!--!--!-----!--------!--------+
        !//!        !PLF     !  ! A! W!/////!ED!  ACF   !
        +--!--------!--------!--!-----!--------!--------+
           !        !        !  !     !        !


               Figure A5.  Page Description Register






        The modes of access control are as follows:

        000     non-resident      abort all accesses

        001     read-only         abort on write attempt memory
                                  management trap on read

        010     read-only         abort on write attempt

        011     unused            abort all accesses--reserved for
                                  future use

        100     read/write        memory management trap upon
                                  completion of a read or write

        101     read/write        memory management trap upon
                                  completion of a write

        110     read/write        no system trap/abort action

        111     unused            abort all accesses--reserved for
                                  future use

        ELF KERNEL PROGRAMMER'S GUIDE               Page 124
       Appendix A


                               UNIBUS #777572

          1  1  0  0  0  0  0  0  0  1  1  0  1  0  1  1
         15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
        +-----------------------------------------------+
        !  !  !  !  !//!//!  !  !  !  !  !I/D! !  !  !  !
        +-----------------------------------------------+
          ^  ^  ^  ^  ^  ^  ^  ^  ^!     ! ^!        ! ^
          !  !  !  !  !  !  !  !  !+-----+ !+--------+ !
          !  !  !  !  !  !  !  !  !   !    !     !     ENABLE RELOCATION
          !  !  !  !  !  !  !  !  !   !    !     +-----------PAGE NUMBER
          !  !  !  !  !  !  !  !  !   !    +------PAGE ADDRESS SPACE I/D
          !  !  !  !  !  !  !  !  !   +------------------------PAGE MODE
          !  !  !  !  !  !  !  !  +----------------INSTRUCTION COMPLETED
          !  !  !  !  !  !  !  +------------------------MAINTENANCE MODE
          !  !  !  !  !  !  +--------------ENABLE MEMORY MANAGEMENT TRAP
          !  !  !  !  !  +--------------------------------------NOT USED
          !  !  !  !  +-----------------------------------------NOT USED
          !  !  !  +------------------------------TRAP-MEMORY MANAGEMENT
          !  !  +-----------------------ABORT-READ ONLY ACCESS VIOLATION
          !  +-----------------------------------ABORT-PAGE LENGTH ERROR
          +-------------------------------------------ABORT-NON RESIDENT


                 Figure A6.  Format of Status Register #0 (SRO)







                               UNIBUS #777574


         15          11 10     8  7           3  2     0
        +-----------------------------------------------+
        !              !        !              !        !
        +-----------------------------------------------+
         AMT. CHANGED   REGISTER  AMT. CHANGED   REGISTER
        (2'S COMPLEMENT)  NO.    (2'S COMPLEMENT)   NO.

                                      777576 SR2 (VA)


          Figure A7.  Format of Status Register #1 (SR1)

        ELF KERNEL PROGRAMMER'S GUIDE               Page 125
       Appendix A


         15                                   3  2  1  0
        +-----------------------------------------------+
        !//////////////////////////////////////!  !  !  !
        +-----------------------------------------------+
                                                 ^  ^  ^
                                                 !  !  +--------USER
                                                 !  +-----SUPERVISOR
                                                 +------------KERNEL


              Figure A8.  Format of Status Register #3 (SR3)
 