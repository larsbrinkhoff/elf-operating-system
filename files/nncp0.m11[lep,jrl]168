;	ELF75C.2
	.TITLE	NNCP0	ELF NCP PROCEDURES
	.LIST	ME
	.NLIST	CND


	$CNFIG
	$NPARM		;NCP PARAMETER DEFINITIONS.
	$DFREG
	$DFHTE		;DEFINE HOST TABLE ENTRIES
	$DFCT		;DEFINE CONNECTION TBL ENT
	$NSDEF


	.GLOBL	$SHL,$HTRST,$BLDCT,$ICT,$GLINK,$FLINK,$HLIST
	.GLOBL	$ENQ,$DEQ,$ALOCW
	.GLOBL	$FCTBL,$MATSK,$MALCL,$ETCST
	.GLOBL	$GFMQE,$FMQE,$MQFMT,$DISMQ,$IQF,$HIQ,$IHQ
	.GLOBL	$RLSCT
	.GLOBL	$LLDEL,$QDEL
	.GLOBL	$INCAL,$DECAL
	.GLOBL	$EXMCH,$SLL,$LSLST
	.GLOBL	$NEROR
	.GLOBL	$ALOCB,$FREEB
	.GLOBL	$NSEM

CTPOOL = 2		;BUFFER POOL ID FOR CONN TBL
OPNSIO	=	3	;OP ID FOR NCP SIO COMPL (IPP)


	.NLIST	ME
	.LIST	MEB
	.PAGE
	.SBTTL	$SHL -- SEARCH HOST-LIST

	.CSECT	$NNCP0
;			*** $SHL *** 
;			***    SEARCH HOST-LIST
;			***  FOR <HOSTID>
;			***  IN R0

$SHL:	MOV	#$HLIST,R1	;BASE OF HOSTLIST TO R1
	MOV	(R1)+,R4	;ENTRY LENGTH
	MOV	(R1)+,R2	;NUMBER OF ENTRIES
SRCHC:	CMPB	R0,(R1)		;IS HOSTID THAT SPECIFIED?
	BEQ	SRCHR		;FOUND HOSTID
	ADD	R4,R1		;BUMP BY ENTRY LENGTH
	DEC	R2		;AND TALLY ON NR ENTRIES
	BGT	SRCHC		;BACK TILL FOUND

;			REQUESTED HTE NOT LOCATED; ATTEMPT TO
;			FIND UNUSED SLOT.

	MOV	#$HLIST+2,R1	; ADDRX OF NR ENTRIES
	MOV	(R1)+,R2	; COUNTER TO R2
1$:	TST	(R1)		; IS IT NULL ENTRY ?
	BEQ	2$		; YES, ALLOCATE IT
	ADD	R4,R1		; ELSE KEEP SEARCHING
	DEC	R2		; FOR A NULL ONE
	BGT	1$		; UNTIL THEY'RE ALLGONE
	RTS	PC		;RETURN UNSUCCESSFUL, CC = 0
2$:	MOV	R0,(R1)		; IF ONE FOUND, THEN SET HOST ADDR
	JSR	PC,$HTRST	; AND INIT THE HOST TABLE.
SRCHR:	CLZ			;SET COMPLETION CODE
	RTS	PC		;AND HAPPILY RETURN

	.SBTTL	$HTRST - RESET HOST TABLE ENTRY

;			***  $HTRST  ***

;			ASSUME R1 = ADDRESS OF HTE

$HTRST:	$PUSH	R1,R3	; SAVE CALLER REGISTERS
	TST	(R1)+		; LEAVE HOST ADR INTACT
	CLR	(R1)+		; CLEAR CONNX LIST POINTERS
	CLR	(R1)+
	MOVB	#374,(R1)+	; INITIALIZE LINK ALLOCATION
	MOV	#10,R3		; BIT MAP
1$:	MOVB	#377,(R1)+	; IN HTE
	$LOOP	R3,1$
	MOV	#11,R3		; THEN FORMAT THE REST OF HTE
2$:	CLRB	(R1)+		; WITH ZEROS...
	$LOOP	R3,2$		; FOR EACH FIELD
	$POP	R3,R1		; RESTORE REGS
	RTS	PC		; AND RETURN


	.PAGE
	.SBTTL	$EXMCH -- EXHAUSTIVE SEARCH FOR LOCAL SOCKET

;			THIS PROCEDURE PERFORMS AN EXHAUSTIVE
;			SEARCH OF ALL KNOWN CT'S
;			(EXCLUDING LISTENING CT'S)
;			IN AN ATTEMPT TO LOCATE A PENDING
;			CALL TO A LOCAL LISTENER.
;			THE DESIRED LOCAL SOCKET IS 
;			SPECIFIED IN R0.
;			THE PROCEDURE IS CALLED BY
;			THE LISTEN ($N.LSN) PRIMITIVE

;			RETURNS THE TARGET CT ADDRESS IN R2,
;			IF IT WAS FOUND. THE ADDRESS OF
;			THE PRECEEDING CT ENTRY IS RETURNED
;			IN R3, TO FACILITATE DELETION OF
;			THE ENTRY FROM A LIST OF CT'S ASSOCIATED
;			WITH A SPECIFIC HOST. (FOR ADDITION
;			TO THE LISTENING-SOCKET LIST.)
;			IF THE SOCKET WAS NOT LOCATED,
;			R2 IS RETURNED AS 0, AND
;			THE CONDITION CODE Z BIT IS SET IN PSW.

;			RETURNS HT POINTER IN R1.  R0 IS
;			RETURNED UNCHANGED.

$EXMCH:	MOV	#$HLIST,R1	;GET BASE OF HOST-LIST
	MOV	(R1)+,R4	;GET ENTRY LENGTH
	$PUSH	(R1)+		;PUT NUMBER OF ENTRIES ON STACK

EXSRCH:	MOV	R1,R3		;HTE ADDRX TO R3
	ADD	#HTECTI,R3	;AND GET ADDRX OF INPUT CHAIN HEAD
EXSRC0:	MOV	(R3),R2		;ADDRX OF POSSIBLE CT TO R2
	BEQ	EXS2		;NONE HERE
	CMP	R0,CTLCL(R2)	;LCL SCK CMPR?
	BEQ	ESRCHR		;YEAH.
	MOV	R2,R3		;ADVANCE TO NEXT
	BR	EXSRC0		;SEARCH INPUT CTS

EXS2:	MOV	R1,R3		;HTE ADDR TO R3
	ADD	#HTECTO,R3	;BASE OF CT CHAIN FOR THIS HOST
EXS3:	MOV	(R3),R2		;OBTAIN ADDR OF POSSIBLE CT
	BEQ	EXSR		;BRCH IF THERE AREN'T ANY
	CMP	R0,CTLCL(R2)	;IS THIS IT?
	BEQ	ESRCHR		;YEAH, FOUND HIM
	MOV	R2,R3		;ADVANCE TO NEXT
	BR	EXS3

EXSR:	ADD	R4,R1		;BUMP TO NEXT HOST TBL ENTRY
	DEC	@SP		;DECREMENT TALLY ON NR ENTRIES
	BGT	EXSRCH		;SEARCH THEM ALL
ESRCHR:	TST	(SP)+		;SET COND CODES
	RTS	PC		;RETURN, CC Z=1, R2=0
	.PAGE
	.SBTTL	$SLL -- SEARCH LIST OF LISTENING CT'S

;			THIS PROCEDURE SEARCHES FOR 
;			A LISTENING CT HAVING A SPECIFIED
;			LOCAL SOCKET, CONTAINED IN R0.
;			BECAUSE LISTENING SOCKETS ARE NOT
;			ASSOCIATED WITH A PARTICULAR HOST,
;			THE HOST-TABLE POINTER FIELD IN
;			THESE CT'S IS 0.

;			$SLL RETURNS THE ADDRESS OF THE
;			TARGET CT, IF FOUND, IN R2.
;			THE ADDRESS OF THE PRECEDING CT IS RETURNED
;			IN R3, TO ALLOW THE CALLER TO EASILY DELETE
;			THE CT FROM THE LISTENING LIST.

;			R0, R1 ARE RETURNED UNCHANGED.

$SLL:	MOV	#$LSLST,R3	;BASE OF LISTENER LIST
SLL2:	MOV	(R3),R2		;FETCH ADDRESS OF A CT FROM LIST
	BEQ	SLSCN0		;NONE IN LIST, OR END LIST.
	CMP	R0,CTLCL(R2)	;IS THIS IT?
	BEQ	SLLF		;WE FOUND HIM
	MOV	R2,R3		;SETUP TO ADVANCE TO NEXT
	BR	SLL2		;LOOP BACK AND CHECK FOR END.
SLLF:	CLZ			;SET COMPLETION CODE NE 0
SLSCN0:	RTS	PC		;AND RETURN

	.PAGE
	.SBTTL	$GLINK - GET A LINK FOR SPEC. HOST
;			*** $GLINK ***

;			ASSUMES HTE ADDR IN R1

;			FETCHES A FREE LINK FOR
;			SPECIFIED HOST


;			RETURNS

;			LINK NUMBER IN REG 0
;			CC = EQ IF NO LINKS,
;			CC = NE IF LINK ALLOCATED.


LMAX = 71		;LAST USABLE LINK NR

$GLINK:	CLR	R0		;GET AN UNUSED LINK
	MOV	R1,R2		;HTE POINTER TO R2
	ADD	#HTLINK,R2	;SET POINTER TO LINKBITS FIELD
FL0:	TSTB	(R2)+		;AND SEARCH FOR 0'S
	BNE	FBYTE		;BRANCH IF FOUND A NZRO BYTE
	ADD	#8.,R0		;BUMP R0
	CMP	#LMAX,R0	;LINKS ALL USED UP?
	BGT	FL0		;NOPE, KEEP SEARCHING
	RTS	PC		;RTN, CC IS L.E.
FBYTE:	DEC	R2		;BACKUP
	MOV	#1,R3		;INITIALIZE BIT POINTER
FBLUP:	BITB	R3,(R2)		;IS IT THIS ONE?
	BNE	FBIT		;YUP, WE FOUND IT
	INC	R0		;ELSE INC LINK COUNTER
	ASL	R3		;RE-ALIGN MASK
	BR	FBLUP	;AND KEEP LOOKING...

FBIT:	BICB	R3,(R2)		;CLEAR BIT IN LINK FIELD
	CLZ			;CLEAR Z BIT, CC=N.E.
	RTS	PC		;RETURN WITH VALUE IN R0
	.PAGE
	.SBTTL	$FLINK - FREE A LINK FOR SPEC HOST
	
;		*** $FLINK ***

;		FREE A LINK BELONGING
;		TO HOST WHOSE HTE ADDR IS
;		IN R1

$FLINK:	MOV	R1,R2		;BASE HTE TO R2
	ADD	#HTLINK,R2	;GET BASE OF LINK BYTES
	MOV	R0,R3		;PREPARE TO DIV BY 8
	ASR	R3
	ASR	R3
	ASR	R3		;TO GET OFFSET IN LINKBYTES
	ADD	R3,R2
	BIC	#177770,R0	;GET BYTE OFFSET IN 
	BISB	FPWR2(R0),(R2)	;PWR-OF-2 TBL
	RTS	PC		;SET AVAIL BIT AND RETURN

FPWR2:	.BYTE	1,2,4,10,20,40,100,200	;POWER-OF-2 TBL

	.PAGE
	.SBTTL	$FCTBL -- FIND CT ENTRY GIVEN LINK NR

;			***  $FCTBL  ***

;			ASSUMES
;			R0 IS LINK NR,  R1 IS HTE PTR
;			RETURNS
;			R2 = CT ADDRESS

$FCTBL:
FCT00:	BEQ	FCTRS		;BRANCH IF NONE MORE
	MOVB	CTSTAT(R2),-(SP)
	BIC	#177760,(SP)	; ENSURE THAT CONNETION OPEN
	CMP	#STOPEN,(SP)+	; BY CONNECTION STATE
	BNE	1$
	CMPB	R0,CTLINK(R2)	;IS SAME LINK?
	BEQ	FCTF		;YUP
1$:	MOV	(R2),R2	;ADVANCE TO NEXT CT ENTRY
	BR	FCT00		;CHECK FOR END OF LIST
FCTF:	TST	R2		;RETURN STATUS
FCTRS:	RTS	PC		;RETURN

	.SBTTL	$MATSK -- MATCH SOCKET NRS

;			***  $MATSK  **

;			ASSUMES
;			R0 IS LCL SCK NR
;			R1 IS HTE POINTER
;			R3,R4 ARE FGN SCK NR
;			RETURNS
;			R2 = CT ADDRESS

$MATSK:	JSR	PC,MASET2	;GET HEAD OF CTLIST
MATCK:	BEQ	MATRT		;NO MORE
	CMP	R0,CTLCL(R2)		;LCL SCK COMPARE?
	BNE	MATNX		;NO, GET NEXT ADDR
	CMP	R3,CTFGN(R2)		;FGN SCK CMP?
	BNE	MATNX		;GET NEXT
	CMP	R4,CTFGN+2(R2)		;2ND WD COMP?
	BNE	MATNX		;GO TO NEXT
	TST	R2		;SET C.C.
MATRT:	RTS	PC		;RETURN

MATNX:	MOV	(R2),R2		;GET NEXT CT IN CHAIN
	BR	MATCK		;CHECK FOR LAST

	.PAGE
	.SBTTL	$MALCL -- MATCH LOCAL SOCKET IDENTIFIERS

;			***  $MALCL  ***

;			ASSUMES
;			R0 IS LCL SCK NR
;			R1 IS HTE POINTER

;			RETURNS
;			R2 IS CT POINTER, IF FOUND

$MALCL:	JSR	PC,MASET2	;GET PTR TO CT LIST
MA00:	BEQ	MAR2		;BRANCH IF NO CT ENTRIES
	CMP	R0,CTLCL(R2)	;SAME LCL SOCKET?
	BEQ	MAR2		;RETURN IF SO W/ CT PTR
	MOV	(R2),R2	;BUMP TO NEXT IN CHAIN
	BR	MA00		;CHECK FOR END OF CHAIN
MAR2:	TST	R2		;SET C.C. ACCORDING TO SUCCESS
	RTS	PC		;IF Z BIT SET, NONE FND
MASET2:	BIT	#1,R0	;IS LCL SCK SENDER?
	BNE	MASEN		;YES
	MOV	HTECTI(R1),R2	;HEAD CT TO R2
	RTS	PC		;AND RETURN
MASEN:	MOV	HTECTO(R1),R2	;HEAD CT SENDERS TO R2
	RTS	PC		;AND RETURN
	.PAGE
	.SBTTL	$BLDCT -- BUILD CT ENTRY FOR SPEC. HOST

;			*** $BLDCT ***

;			ASSUMES
;			R0 = LCL SCK NR
;			R1 = HTE PTR , OR 0.
;			RETURNS
;			R1 UNCHANGED.
;			R2 = NEW CT PTR
$BLDCT:	$PUSH	R0,R1		;SAVE LCL SCK NR
	MOV	#CTPOOL,R0	;SETUP POOLID
	JSR	PC,$ALOCB	;ALLOCATE AND WAIT
	TST	R1		; SEE IF SUCCEEDED
	BEQ	BLDCF		; NO, FAILED
	MOV	#CTLEN,R3	;SETUP LEN OF CT
	MOV	R1,R4		;LEN IN WDS IN R3, ADDR IN R4
CLRCT:	CLR	(R4)+		;INITIALIZE THE CT ENTRY
	DEC	R3		;TALLY
	BGT	CLRCT		;FOR ALL WDS
	MOV	R1,R2		;CT PTR TO R2
	MOV	(SP),R1		; RECOVER HTE POINTER
	MOV	2(SP),CTLCL(R2)	;SET LCL SCK NR
	MOV	#OPNSIO,CTIOPC(R2)	;SET OPCODE FOR IPP COMPL
	BIT	#1,CTLCL(R2)	;LCL SCK SENDER?
	BNE	BLDSN		;YES
	MOV	#2,CTIFCN(R2)	;SET WRITE FUNCTION FOR IPP
	TST	R1		;WAS HOST SPECIFIED?
	BEQ	BLDS3		;NO, SKIP HTE SETUP.
	MOV	HTECTI(R1),(R2)	;CHAIN HOSTLIST ENTS
	MOV	R2,HTECTI(R1)	;STORE CT ADDR IN CHAIN
BLDS2:	MOV	R1,CTHTA(R2)	;STORE HTE ADDR IN CT
	MOV	(PC)+,R0	;RAD50 'IPP'
	.RAD50	'IPP'
	MOV	R0,CTIPP(R2)	;FORMAT CT
	MOV	#-1,R1		;SET SELECT UNIT
	$DFDEV	R0,R1		;ALLOCATE AN IPP
	TST	R0		; CHECK CONDITION CODE
	BNE	BLDCF		; BRANCH IF CAN'T GET AN IPP
	MOV	R1,CTIPPN(R2)	;STORE UNIT NR IN CT
	MOV	#200,CTISTA(R2) ;SET STATUS (DON)
	CLR	CTIBR(R2)	;INIT BYTES REQUESTED
BLDCF2:	$POP	R1,R0		;RESTORE HTE, LOCAL SOCK NR
	TST	R2		; CHECK SUCCESS, SET CODE
	RTS	PC		;RETURN WITH
				;  R1 = CT ADDR
				;  R2 = HTE ADDR
BLDCF:	CLR	R2		; INDICATE FAILURE
	BR	BLDCF2		; BACK TO POP REGS


BLDSN:	MOV	#1,CTIFCN(R2)	;READ FUNCTION FROM IPP
	TST	R1		;WAS HOST SPECIFIED?
	BEQ	BLDS3		;NO, SKIP HTE SETUP.
	MOV	HTECTO(R1),(R2)
	MOV	R2,HTECTO(R1)
	BR	BLDS2


BLDS3:	MOV	$LSLST,(R2)	;PLACE NEW CT ON LISTENING
	MOV	R2,$LSLST	;LIST...
	BR	BLDS2		;THEN PROCEED TO ALLOC. IPP


	.SBTTL 	$ICT -- INITIALIZE CT ENTRY

;			***  $ICT  ***

;			ASSUMES R2 = CT PTR

$ICT:	MOV	R2,R3		;SCRATCH REG
	ADD	#CTMCT,R3	;ADDR OF MSG CNT
	CLR	(R3)+		;CLEAR MSG CNT ON CONN
	CLR	(R3)+		;CLEAR BIT CNT HI
	CLR	(R3)+		;CLEAR BIT CNT LO
	RTS	PC		;RETURN

	.SBTTL	$RLSCT -- RELEASE AND FORGET CT ENTRY
$RLSCT:	$PUSH	R2		;SAVE CT POINTER
	ROR	CTLCL(R2)	;IS HE RECEIVE SOCKET?
	BCS	IHFNFL		;BRANCH IF SEND SOCK
	MOVB	CTLINK(R2),R0	;GET LINK
	BEQ	IHFNFL		;IF HAVEN'T ALLOC, DONT FREE
	MOV	CTHTA(R2),R1	;FETCH HTE ADDR
	BEQ	IHFNFL		;DON'T FREE IF NO HOST ASSIGNED
	JSR	PC,$FLINK	;FREE LINK
	MOV	@SP,R2		;RESTORE CT POINTER
IHFNFL:
	MOV	CTIPP(R2),R0	; RELEASE INTER-PROCESS PORT
	MOV	CTIPP+2(R2),R1
	$UDDEV	R0,R1		; BY UNDEFINING IT.
IHD02:	ADD	#CTQ,R2		;POINT TO CONN QUEUE
	JSR	PC,$DEQ		;DEQUEUE A MESSAGE
	BEQ	IHFACT		;NONE
	JSR	PC,$DISMQ	;FREE MQE AND ITS BUFF
	MOV	@SP,R2		;CT PTR AGAIN
	BR	IHD02		;LOOP THRU CT MSG PTRS

IHFACT:	MOV	@SP,R2		;GET CT PTR
	MOV	CTMQA(R2),R0	;ACTIVE MSG?
	BEQ	IHFMQP		;NEXT, FREE MQP
	MOV	$HIQ,R1		; ENSURE MQE IS NOT ON HOST-IMP
				; QUEUE....TO AVOID FREEING
				; AN MQE TWICE.
2$:	BEQ	1$		; AT END OF CHAIN...ITS NOT
	CMP	R1,R0		; IS THIS THE MQE ?
	BEQ	IHFMQP		; YES, SKIP FREEING CTMQA
	MOV	(R1),R1		; ADVANCE TO NEXT ENTRY IN $HIQ
	BR	2$		; UNTIL END OF CHAIN
1$:	JSR	PC,$DISMQ	;FREE MQE AND ITS BUF
	MOV	@SP,R2		;CT AGAIN
IHFMQP:	MOV	CTMQP(R2),R0	;MESSAGE QUEUE PTR TO R0
	BEQ	IHFFQ		;ALL DONE, FREE CT
	JSR	PC,$DISMQ	;FREE MQE AND BUF
IHFFQ:	$POP	R1		; CT -> FREE SPACE
	MOV	#CTPOOL,R0	;POOLID FOR CONN TBL
	JSR	PC,$FREEB	;FREE IT

	RTS	PC		;AND RETURN
	.PAGE
	.SBTTL	$ALOCW -- ALLOCATE BUFFER AND WAIT IF NECC

;		*** $ALOCW ***

;		ALLOCATE A BUFFER AND WAIT IF NECC.

;		POOLID IN R0

$ALOCW:	MOV	R0,-(SP)	;SAVE R0
ALOCW0:	MOV	(SP),R0
	JSR	PC,$ALOCB	;GET A BUFFER
	TST	R1
	BEQ	ALOCW2		;WAIT IF NONE
	MOV	(SP)+,R0	;RESTORE R0
	RTS	PC		;AND RETURN
ALOCW2:	$PUSH	R0
	$V	$NSEM
	$POP	R0
	$P	R0		;WAIT FOR BUFFER
	$P	$NSEM
	BR	ALOCW0		;RETURN TO TRY AGAIN


	.PAGE
	.SBTTL	$ENQ -- PLACE QUEUE ELEMENT IN FIFO QUEUE

;			***  $ENQ  ***
;			PLACE ENTRY IN FIFO QUEUE
;			R2 = ADDR (HEAD,TAIL)
;			R0 = ADDR (NEW Q EL)

$ENQ:	
	CLR	(R0)	;CLEAR LINK FROM NEW QUEUE EL
	TST	(R2)+	;HEAD OF QUEUE NULL?
	BEQ	ENQNL	;YES
	MOV	R0,@(R2)+	;UPDATE LINK TO TAIL
	BR	ENQR		;GO SETUP NEW TAIL
ENQNL:	MOV	R0,(R2)		;SET NEW TAIL IF Q MTY
ENQR:	MOV	R0,-(R2)	;UPDATE TAIL OR HEAD
	RTS	PC		;RETURN

	.SBTTL	$DEQ -- REMOVE ELEMENT FROM FIFO QUEUE

;			***  $DEQ  ***
;			FETCH ENTRY FROM FIFO QUEUE
;			R2 = ADDR (HEAD,TAIL) OF QUEUE
;			RETURNS R0 = ADDR (Q EL)
;			CC Z BIT SET IF NUL

$DEQ:	
	MOV	(R2),R0		;QHEAD TO R0
	BEQ	DQRTS		;ITS NULL
	MOV	(R0),(R2)	;UPDATE QUEUE HEAD
DQRTS:	TST	R0		;SET C.C.
	RTS	PC		;RETURN

	.SBTTL	$LLDEL -- DELETE AN ELEMENT FROM A LINKED LIST

;			***  $LLDEL  ***

;			ASSUMES:

;			R0 = POINTER TO A LIST ELEMENT
;			R2 = HEAD OF A LIST

;			RETURNS:
;			R2 POINTS TO ELEMENT PREV. TO ONE DEL'D.


$LLDEL:	
QDLUP:	CMP	(R2),R0		;IS LINK OF (R2) TO BE DEL'D
	BEQ	QDGOT		;SEARCH FOR IT
	MOV	(R2),R2		;SCAN
	BNE	QDLUP		;ERROR IF NOT FOUND
	RTS	PC		;DON'T COMPLAIN.
QDGOT:	MOV	@R0,@R2		;PATCH LINK TO SKIP DEL'D QEL
	RTS	PC		;AND RETURN

	.SBTTL	$QDEL -- DELETE AN ENTRY FROM A QUEUE

;			***  $QDEL  ***

;			SAME ASSUMPTIONS AS $LLDEL,
;			EXCEPT $QDEL PATCHES UP THE
;			TAIL FIELD OF A QUEUE POINTER.

$QDEL:	MOV	R2,R3		;MOVE QUEUE HEAD PTR SAVE
	JSR	PC,$LLDEL	;DELETE ENTRY FROM LINKLIST
	TST	(R2)		;IS TAIL TO BE UPDATED?
	BNE	QDG2		;NO, SIMPLY RETURN
	MOV	R2,2(R3)	;STORE NEW TAIL IN Q POINTER
QDG2:	RTS	PC		;RETURN..

	.SBTTL	$GFMQE -- GET FREE MESSAGE QUEUE ELEMENT

;			***  $GFMQE  ***
;			GET FREE MESSAGE QUEUE ELEMENT
;			RETURNS FREE ELEMENT IN R4
;			CALLS $ERROR IF NONE AVAIL

$GFMQE:
	MOV	$IQF,R4		;GET TOP OF FREELIST
	BEQ	GFERR		;ERROR, NONE AVAIL
	MOV	(R4),$IQF	;UPDATE HEAD OF FREE QUEUE
	RTS	PC

GFERR:	$NEROR	3		; NO FMQE'S

	.SBTTL	$FMQE -- FREE MESSAGE QUEUE ELEMENT

;			***  $FMQE  ***

;			ASSUMES R4 = ADDR ELEMENT
;			TO BE PLACED ON FREE MSG QUEUE

$FMQE:
	MOV	$IQF,(R4)	;LINK TO CURRENT TOP FREE QUEUE
	MOV	R4,$IQF
	RTS	PC		;AND RETURN


	.SBTTL	$MQFMT -- FORMAT MESSAGE QUEUE ELEMENT

;			*** $MQFMT  ***

;			THIS PROCEDURE GETS AND ENTRY
;			FROM THE FREE MESSAGE QUEUE
;			AND FORMATS IT WITH
;			MSG ADDR, POOLID, AND LEN

;			ASSUMES:
;			R0 = BUFFER POOL ID
;			R1 = A(MSG)
;			R2 = LENGTH

$MQFMT:	JSR	PC,$GFMQE	;GET AN ENTRY FROM MESSAGE QUEUE
	MOV	R1,-(R4)	;STORE MESSAGE ADDRESS
	MOV	R0,-(R4)	;STORE POOL ID
	MOV	R2,-(R4)	;STORE LENGTH
	.IF EQ	N.XNCP-1	;XNCP OPTION ??
	CLR	-(R4)		;CLEAR ADDITIONAL WORDS IN MQE
	CLR	-(R4)
	ADD	#12,R4		;LEAVE R4 POINTING TO BASE (LAST ADDR) MQE
	.IFF
	ADD	#6,R4		;RE-SET R4 TO QUEUE ENTRY
	.ENDC
	RTS	PC		;RETURN

	.SBTTL	$DISMQ	DISCARD MQE AND ASSOCIATED BUFFER
$DISMQ:	$PUSH	R0		;MQE ADDRESS ASSUMED IN R0
	MOV	-(R0),R1	;ADDRESS TO R1
	MOV	-(R0),R0	;POOLID TO R0
	JSR	PC,$FREEB	;RELEASE THE BUFFER
	$POP	R4		;MQE TO R4
	JSR	PC,$FMQE	;FREE THE MQE
	RTS	PC		;AND RETURN

	.SBTTL	$ETCST	SET CONNECTION STATE

;			***  $ETCST  *** 

;			ASSUMES
;			R0 IS NEW STATE
;			R2 IS CT POINTER

$ETCST:	MOVB	CTSTAT(R2),R3
	BICB	#17,R3		;CLEAR STATE BITS
	BISB	R0,R3		;SET NEW STATE
	MOVB	R3,CTSTAT(R2)	;UPDATE CTSTAT FIELD
	RTS	PC		;AND RETURN

	.SBTTL	$INCAL -- INCREASE ALLOCATION FOR CONNECTION
;			*** $INCAL ***

;			ASSUMES
;			R2 IS CT POINTER
;			R3,R4 ARE BIT COUNTS

$INCAL:	ADD	R4,CTBCT+2(R2)	;INCREASE BIT COUNT
	ADC	CTBCT(R2)
	ADD	R3,CTBCT(R2)
	RTS	PC		;RETURN

$DECAL:	SUB	R4,CTBCT+2(R2)
	SBC	CTBCT(R2)
	SUB	R3,CTBCT(R2)	;DECREMENT BIT COUNT
	RTS	PC


	.END




