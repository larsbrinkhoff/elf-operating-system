;	ELF75C.2
;<VOICE>NNCP3.M11;14    21-NOV-74 00:22:51	EDIT BY RETZ

;			FIXED LACK OF SIGNAL IN CLOSE (CCT POINTER)

;<VOICE>NNCP3.M11;13    20-NOV-74 23:38:36	EDIT BY RETZ

;			FIXED LISTEN-LIST PROBLEM (INFINITE
;			CHAIN.)

	.TITLE	NNCP3 -- ELF NCP OUTER LAYER PROCEDURES
	.LIST	ME
	.NLIST	CND
	.CSECT	$NCP3

	$CNFIG
	$DFREG
	$DFCT
	$DFHTE
	$DFCCT		;DEFINE CONNECTION CONTROL TABLE

	$DFSCC		;DEFINE SOCKET COMPLETION CODES
	$NSDEF		; NCP STATE DEFINITIONS

	.GLOBL	$N.CON,$N.CLS,$N.LSN
	.GLOBL	$SHL,$BLDCT,$ICT,$GLINK,$FLINK
	.GLOBL	$HHENQ,$HIENQ,$DEAD
	.GLOBL	$MATSK,$DECAL,$ALOCW,$MQFMT
	.GLOBL	$MALCL,$ETCST,$RFCLS
	.GLOBL	$ENQ,$DEQ,$FMQE
	.GLOBL	$LSLST,$EXMCH,$SLL,$RLSCT,$DISMQ
	.GLOBL	$NSEM,$NRSV,$NRRES
	.GLOBL	$NCPI
	.GLOBL	$CLSCW		; CLOSE CONNECTION -> GO STATE 0

OPNNXC	=	4		; OPCODE TO SIGNAL NCP NEW CONNX

	.PAGE
	.SBTTL	ATRIUM TO NCP PRIMITIVES


;			*** CONNECT ***

;			THIS NCP PROCEDURE INITIATES THE
;			ESTABLISHMENT OF A CONNECTION.  IT ASSUMES
;			THE ADDRESS OF A CONNECTION CONTROL TABLE (CCT)
;			IN R0, AND RETURNS AN INTER-PROCESS PORT
;			IDENTIFIER (IF THE CONNECT WAS SUCCESSFUL) IN
;			R1.  THE CONNECT PRIMITIVE IS USED TO INITIATE
;			A CONNECTION OR TO ACCEPT ONE WHICH WAS
;			PREVIOUSLY PLACED IN THE LISTENING STATE.

$N.CON:	JSR	R5,$NRSV	;SAVE CALLER REGISTES
	JSR	PC,N.CON	;INITIATE 'CONNECT' OP
	MOV	R1,2(SP)	 ; STORE RETURN IPP NUMBER IN STACK
	BR	NEXIT		;RESTORE CALLER REGS


;			*** LISTEN ***

;			THIS PROCEDURE PLACES A CONNECTION IN A 
;			'LISTENING' STATE, I.E., THE LOCAL SOCKET 
;			SPECIFIED IN THE CCT AWAITS A REMOTE CONNECT.

$N.LSN:	JSR	R5,$NRSV	;SAVE CALLER REGISTERS
	JSR	PC,N.LSN	;INITIATE 'LISTEN' OP
	BR	NEXIT		; AND EXIT

$N.CLS:	JSR	R5,$NRSV	;SAVE CALLER REGISTERS
	JSR	PC,N.CLS
NEXIT:	JSR	R5,$NRRES	;RESTORE REGISTERS
	RTI			;AND RETURN TO CALLER

$NRSV:	$PUSH	R4,R3,R2,R1,R0	; CALLER REGISTERS GET SAVED
	$P	$NSEM		; NCP INTERLOCK TAKEN
	MOV	@SP,R0		; RECOVER CCT ADDRESS
	MOV	R0,N.CCT	; SET CCT ADDRESS
	CLRB	CCTCC(R0)	; CLEAR
	MOV	R5,PC		; RETURN

$NRRES:	TST	(SP)+		; DISCARD R5 ON STACK
	$V	$NSEM		; RELEASE NCOP INTERLOCK
	$POP	R0,R1,R2,R3,R4	;RESTORE REGISTERS
	RTS	R5		; AND RETURN


	.PAGE
	.SBTTL	$N.LSN -- ESTABLISH A LISTENING SOCKET
	.NLIST	ME	;NO MACRO EXPANSIONS PLEASE

;			***  $N.LSN  *** 

;			CAUSE A SOCKET TO BE CREATED
;			IN A LISTENING STATE

;			ASSUMES CCT PTR IN R0

N.LSN:	BIS	R0,CLFLG	;SET LISTEN FLAG
	MOV	CCTLCL(R0),R0	;GET LOCAL SOCK ID SPECIFIED
	JSR	PC,$SLL		;SEARCH LISTENING SOCKET LIST
	BNE	LSFAIL		;ITS ALREADY LISTENING -- ERROR
	JSR	PC,$EXMCH	;PERFORM EXHAUSTIVE SEARCH FOR SOCK
	BNE	LSNS0		;IF DEFINED, SEE IF PENDING STATE.
	CLR	R1		;INDICATE NO HOSTID
	JSR	PC,$BLDCT	;ALLOC A CT
	BNE	CONSIM		;GO SIMULATE CONNECT
	JMP	CLCLE2		; ERROR, CAN'T ALLOC. IPP

LSNS0:	MOV	N.CCT,R0	;CCT PTR TO R0
	MOVB	CTSTAT(R2),R4	;GET CONNECTION STATUS IN R4
	BIC	#177760,R4	;TRIM TO GET CONN STATE
	BEQ	LSCLSD		;ITS CLOSED, BUT KNOWN.
	CMPB	#STOPWL,R4	;IS IT PENDING?
	BNE	LSFAIL		;ELSE THIS IS ILLEGAL CALL.
	MOV	R1,N.HTE	;SET HTE PTR
	MOV	CTFGN(R2),CCTFGN(R0)	;COPY FOREIGN SOCKET
	MOV	CTFGN+2(R2),CCTFGN+2(R0)  ;INTO CALLER'S CCT
	MOV	(R1),(R0)	;AND COPY HOSTID TOO.
	BR	CONSIM		;SIMULATE CONNECT.
LSFAIL:	MOV	N.CCT,R0	; CCT ADDRESS AGAIN
	MOVB	#WCCIVO,CCTCC(R0)	;SET ERROR COND CODE
LSPOST:	MOV	N.CCT,R1	; RECOVER CCT ADDRESS
	$SIGNL	#0,CCTOP(R1),R1	;SIGNAL CALLER
	RTS	PC		;AND RETURN
LSCLSD:	MOV	(R2),(R3)	;DELETE FROM CT CHAIN
	JSR	PC,$ICT		;INIT THIS CT ENTRY
	MOV	$LSLST,(R2)	; INSERT CT ON LISTENING-LIST
	MOV	R2,$LSLST	; SET NEW HEAD OF LIST
	BR	CONSIM		;AND PUT HIM ON LISTEN LIST


	.SBTTL	$N.CON -- ESTABLISH A CONNECTION (INIT)

;			***  $N.CON  ***

;			ASSUMES CCT PTR IN R0

N.CON:	CLR	CLFLG		;CLEAR LISTEN FLAG
	TSTB	$DEAD		;HAS HOST/IMP CONN. DIED?
	BNE	CONDED		;YES, NOTIFY CALLING PROCESS
	MOV	(R0),R0		;GET HOSTID FROM CCT
	JSR	PC,$SHL		;GET HTE POINTER
	BEQ	CONUDH		;UNDEFINED HOST - ERROR
	MOV	R1,N.HTE	;SAVE HTE POINTER
	MOV	N.CCT,R4	; CCT PTR TO R4
	CLRB	CCTCC(R4)	;INITIALIZE CONDITION CODE
	MOV	CCTLCL(R4),R0	;OBTAIN LOCAL SOCK NR
	JSR	PC,$SLL		; WAS IT LISTENING ?
	BNE	LSFAIL		; YEAH, ISSUE ERROR TO CALLER
	MOV	CCTFGN(R4),R3	;AND FOREIGN SOCK NR
	MOV	CCTFGN+2(R4),R4	;AND 2ND WORD
	JSR	PC,$MATSK	;MATCH LCL, FGN SOCK ?
	BEQ	CBLD		;NOT FOUND, GO BUILD CT ENTRY
CONSIM:	MOV	R2,N.CT		;SAVE CT POINTER
	MOVB	CTSTAT(R2),R3	;STATUS WORD TO R3
	BIC	#177760,R3	;OBTAIN INDEX
	MOV	N.CCT,R4	;CCT POINTER
	MOV	R4,CTCCT(R2)	;SETUP CCT PTR IN CT
	MOVB	CCTOP(R4),CTOPC(R2) ; SET OPCODE USER EXPECTS
	$GAPID			;OBTAIN ACTIVE PROCESS ID
	MOVB	R0,CTPCI(R2)	;AND SAVE IT IN CT
	TST	CLFLG		;LISTENING?
	BNE	CLSN		;YUP, PROCESS LISTEN REQUEST
	ASL	R3		;OBTAIN WORD INDEX
	$PUSH	CTIPPN(R2)	; SAVE IPP NUMBER ON STACK
	JSR	PC,@CONTB(R3)	;JSR THRU TABLE
	$POP	R1		; RETURN IPP NUMBER
	RTS	PC		;RETURN TO CALLER

CONDED:	MOVB	#WCCDED,CCTCC(R0)	;SET 'DEAD IMP' COMPL
	BR	COPOST			;POST COMPL

CBLD:	MOV	N.CCT,R4	;SETUP CCT ADDRX
	MOV	CCTLCL(R4),R0	;SPECIFY LCL SCK
	JSR	PC,$BLDCT	;BUILD CT ENTRY (FIX HOSTLINKS)
	BEQ	CLCLE2		; BRANCH IF CAN'T GET CT
	MOV	N.CCT,R4	;OBTAN CCT ADR
	ADD	#CCTBS,R4	;PLUS OFFSET TO BYTE SIZE
	$PUSH	R2		;SAVE CT POINTER
	ADD	#CTBSIZ,R2	;POINT TO BYTE SIZE FIELD OF CT
	MOVB	(R4)+,(R2)+	;STORE BYTE SIZE
	MOV	(R4)+,(R2)+	;LCL SCK
	MOV	(R4)+,(R2)+	;FGN SCK
	MOV	(R4)+,(R2)+	;FGN SCK
	BIT	#1,-(R4)	;IS FGN SCK SEND SCK?
	BEQ	CLCSND		;NOPE, LCL IS SEND
	MOV	@SP,R2		;CT POINTER TO R2, PLEASE
	TSTB	CTLINK(R2)	;HAS LINK BEEN ALLOCATED?
	BNE	CLCSND		;YES, DON'T GET A NEW ONE.
	JSR	PC,$GLINK	;LCL IS RCV, ALLOC A LINK
	BEQ	CLCLE		;NO LINKS AVAIL .. ERROR
CLCSND:	$POP	R2		;CT ADDRX AGAIN
	MOVB	R0,CTLINK(R2)	;SETUP LINK FIELD IN CT
	BR	CONSIM		;GO PROCESS CLOSED CONN

CONUDH:	MOV	N.CCT,R4		;OBTAIN CCT PTR
	MOVB	#WCCUDH,CCTCC(R4)	;SET COMPLETION CODE
COPOST:	JMP	LSPOST		;GO SIGNAL CALLER

CLCLE:	$POP	R2		;NO LINKS, POP R2 AGAIN
CLCLE2:	MOV	N.CCT,R4	;CCT ADDR
	MOVB	#WCCNL,CCTCC(R4)	;SET COMPLETION CODE
	BR	COPOST		;POST CALLER AND RETURN


CLSN:	TST	R3		;ARE WE CLOSED ALREADY?
	BEQ	COLSN0		;YUP, GO TO LISTENING
	CMP	#STOPWL,R3	;PENDING CALL?
	BNE	CONERR		;NO, INVALID STATE TRANSITION
	MOV	#STRUL,R0	;YES, GO TO RULING
	JSR	PC,$ETCST	;SET STATUS
	MOV	N.CCT,R4	;CCT PTR TO R4
	MOVB	#WCCCMP,CCTCC(R4)	;AND POST HIM COMPLETE
	BR	COPOST		;POST PROCESS TO RCV CONTROL
COLSN0:	MOV	#STLSN,R0	;GO TO LISTENING STATE
	JSR	PC,$ETCST	;SET STATUS
	RTS	PC		;AND RETURN


;			***  CONNECT  ***
;			***  BRANCH   ***
;			***  TABLE    ***

CONTB:	.WORD	CONCON,CONERR,CONOPN
	.WORD	CONOPW,CONOPW,CONERR
	.WORD	CONERR,CONERR
	.WORD	CONTST

CONERR:	JMP	LSFAIL		; SET INVALID OP - RETURN


;			STATE PROCESSORS FOR CONNECT (INIT)

CONCON:	JSR	PC,$ICT		;INIT CT
	MOV	#STOPWR,R0	;GO TO ST 7 (CONNECT)
CONCO2:	JSR	PC,$ETCST	;SET STATUS
	MOV	(PC),R0		;R0 IS NON-ZERO, SEND RFC
	JSR	PC,$RFCLS	;TO FOREIGN HOST
	RTS	PC		;AND RETURN

;			***  CT WAS IN 'RULING' STATE ***

;			CALLER ACCEPTS FOREIGN
;			RFC BY ISSUING $N.CON


;				-  OR  -

;			***  CT WAS IN 'PENDING' STATE ***

CONTST:

CONOPN:	BIT	#1,CTLCL(R2)	; IS IT SEND SOCKET
	BNE	RFOSND		; YES, BRCH IF SO
	MOVB	CTBSIZ(R2),CCTBS(R4) ; INFORM RECEIVER OF BYTE SIZE
	TSTB	CTLINK(R2)	; SEE IF LINK DEFINED
	BNE	RFOACC		; YES, DON'T BOTHER TO GET ONE.
	JSR	PC,$GLINK	;GET A LINK
	BEQ	RFONL0		;NO LINKS, ABORT.
	MOV	N.CT,R2		;RELOAD CT POINTER
	MOVB	R0,CTLINK(R2)	;SAVE LINK IN CT
RFOACC:	MOV	N.CCT,R4	;FETCH CCT ADDR
RFOAC2:	MOVB	#WCCCMP,CCTCC(R4)	;IMMEDIATE SATISFACTION
	MOV	R4,R1		;CCT POINTER TO R1
	$SIGNL	#0,CCTOP(R1),R1	;SIGNAL CALLER
	$SIGNL	$NCPI,#OPNNXC,R2	; SIGNAL NCP NEW CONNX
	MOV	#STOPEN,R0	;TO STATE 6 (OPEN)
	BR	CONCO2		;RETURN AN RFC

RFONL0:	MOV	N.CCT,R0	;CCT ADDR, PLEASE
	MOVB	#WCCNL,CCTCC(R0) ;SET 'NO LINKS' COMP CODE
	MOV	N.CT,R2		;AND GET CT PTR
	MOV	#STCLWR,R0	;GO TO CLOSE-WAIT
	JSR	PC,$ETCST	;SET CONNECTION STATE
	CLR	R0		;SEND A CLS TO CALLER
	JSR	PC,$RFCLS	;AND REJECT CONNECTION
	BR	COPOST		;POST IN ERROR

CONOPW:	MOVB	#WCCCLS,CCTCC(R4) ; SET COMPLETION CODE - REMOTE CLOSE
	BR	COPOST		; WAKEUP USER

RFOSND:	MOVB	CCTBS(R4),CTBSIZ(R2)	;CT BYTE SIZE SETUP
	BR	RFOAC2		;CONTINUE



	.PAGE

;			***  $N.CLS  ***

;			CLOSE AN ESTABLISHED CONNECTION
;			OR A LISTENING SOCKET
;			OR REJECT AN ATTEMPT TO CONNECT

N.CLS:	MOV	CCTLCL(R0),R0	;GET CONDITION CODE
	JSR	PC,$SLL		;SEARCH FOR LISTENER
	BNE	CLSN01		; RETRACT LISTEN REQUEST
	MOV	@N.CCT,R0	; HOST ID TO R0
	JSR	PC,$SHL		;SEARCH HOSTLIST
	BEQ	CLSUDH		;UNDEFINED HOST
	MOV	R1,N.HTE	;SAVE HTBL ADDRX
	MOV	N.CCT,R0	; CCT AGAIN TO R0
	MOV	CCTFGN(R0),R3	;PERFORM MATCH
	MOV	CCTFGN+2(R0),R4	;OF LOCAL, FGN SOCKS
	MOV	CCTLCL(R0),R0	;GET LCL SCK
	JSR	PC,$MATSK	;MATCH?
	BEQ	CLSERR		;CANT CLOSE UNKNOWN SOCK PAIR
CLSN00:	MOV	R2,N.CT		;SAVE CONN TBL ADDRESS
	MOVB	CTSTAT(R2),R3	;FETCH CONNECTION STATUS
	BIC	#177760,R3	;BYTE OFFSET
	MOV	N.CCT,R4	; CCT POINTER TO R4
	ASL	R3		;WORD OFFSET TO TBL
	JSR	PC,@CLSTBL(R3)	;JSR THRU CLS STATE TBL
	RTS	PC		;AND RETURN
CLSUDH:	JMP	CONUDH		;AND BEHAVE LIKE CONNECT ERROR

CLSN01:	MOV	(R2),(R3)	;CLOSE LISTENING SOCKET
	JSR	PC,$RLSCT	;RELEASE CT
	MOV	N.CCT,R4	; CCT ADDRX TO R4
	MOVB	#WCCCMP,CCTCC(R4)	;SET CCT COND CODE
CLPOST:	JMP	LSPOST		;GO SIGNAL AND RETURN


;			***  CLOSE  ***
;			*** BRANCH  ***
;			***  TABLE  ***

CLSTBL:	.WORD	CLSER1	;ERROR (IT WAS CLOSED)
	.WORD	CLSER1		; CAN'T GET HERE, BECAUSE
				; WE CHECKED FOR LISTENER, ABOVE
	.WORD	CLSWT		;TO STATE 3 (WERE RULING)
	.WORD	CLSLSN,CLSDR2,CLSDRN
	.WORD	CLSTST		;IF SEND TO ST4, IF RCV TO ST3
	.WORD	CLSWT
	.WORD	CLSER1


CLSERR:	MOV	N.CCT,R4	; CCT ADDR TO R4
CLSER1:	MOVB	#WCCIVO,CCTCC(R4)	;SET NON-EXISTENT CONNECTION
	BR	CLPOST		;TO ERROR PROCESSOR


CLSLSN:	MOVB	#WCCCMP,CCTCC(R4)	;COMPLETE
	JSR	PC,$CLSCW	; CLOSE CONNECTION
	BR	CLPOST

CLSWT:	CLR	R0		;INDICATE CLS
	$PUSH	R2,R4		;SAVE CT, CCT
	JSR	PC,$RFCLS		;SEND CLS
	$POP	R4,R2		;RSTORE CCT, CT
	MOV	#STCLWR,R0	; GO CLOSE-WAIT-REMOTE
	JSR	PC,$ETCST	;(CLOSE-WAIT)
	RTS	PC

CLSTST:	BIT	#1,CTLCL(R2)	;IS LCL SOCK SEND SCK?
	BNE	CLSDWD		;YES, GO TO DATA-WAIT
CLSPUS:	$PUSH	R4,R2		;SAVE CT,CCT
	MOV	CTMQP(R2),R0	;RELEASE MQP IF EXISTS
	BEQ	CLNFMQ		;NONEXIST
	CLR	CTMQP(R2)	;AND FORGET IT
	JSR	PC,$DISMQ	;DISCARD MQE
CLNFMQ:	$POP	R2,R4
CLNFM2:	MOV	#STCLWR,R0	; WAIT FOR REMOTE CLS
	JSR	PC,$ETCST	; SET CONNECTION STATE
	CLR	R0		; SETUP TO SEND A CLS
	JSR	PC,$RFCLS
	RTS	PC

;			(CLOSING SEND CONNECTION -- SEE
;			 IF DATA IS QUEUED OR IF RFNM IS
;			 AWAITED.)

CLSDWD:	TST	CTMQA(R2)	; IS RFNM AWAITED ON CONNX ?
	BEQ	CLNFM2		; GO TO CLOSE-WAIT-REMOTE
	MOV	#STDRAI,R0	; GO TO DRAIN-WAIT IF RFNM PENDING
	JSR	PC,$ETCST	; SET CONNECTION STATUS
	RTS	PC		; AND THATS IT

;				 CLOSE OP IN DRAIN-WAIT
CLSDRN:	BIT	#1,CTLCL(R2)	; SEND SOCKET?
	BNE	CLSWT		; YES, GO CLOSE-WAIT-REMOTE
				; ELSE CLOSE CONNECTION
CLSDR2:	$PUSH	R2,R4		;SAVE CT, CCT POINTERS
	CLR	R0		;SET OP-CODE CLS FOR $RFCLS
	JSR	PC,$RFCLS	;ISSUE CLS
	$POP	R4,R2		;RESTORE CCT, CT
	BR	CLSLSN		; DELETE CONNECTION -> STATE 0
CLFLG:	.WORD	0		;FLAG TO INDICATE LISTEN REQUEST
N.CCT:	.WORD	0		;ADDRESS OF ACTIVE CCT
N.CT:	.WORD	0		;CT POINTER
N.HTE:	.WORD	0		;HTE POINTER

	.END
  