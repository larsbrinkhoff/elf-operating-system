;	ELF75C.1
	.TITLE	NIOV -- ELF/ARPANET I/O PROCESSES -- VDH

	.LIST	ME
	$CNFIG
	$DFREG
	$DFIOR			;DEFINE IORB FORMAT
	.NLIST	ME
	.LIST	MEB

	.SBTTL	RELIABLE TRANSMISSION PACKAGE GLOBLS 
	.GLOBL	$VDHCT		;VDH LINE UP/DOWN COUNTER
	.GLOBL	$IMOPI,$IMIPI,$NCPI	;NCP PROCESS ID'S
	.GLOBL	$IMPIN,$IMPOU	;NCP PROCESS ENTRY POINTS
	.GLOBL	$IHQ,$GFMQE,$ENQ,$DISMQ
	.GLOBL	$HIQ,$DEQ,$FMQE
	.GLOBL	$ALOCW,$FREEB
	.GLOBL	$DEAD
	.GLOBL	$NSEM
	.IF EQ DEBUG-1
	.GLOBL	$TRCAC
	.ENDC

	.PAGE
	.SBTTL	RTP - INPUT PROCESSOR

;			----------

;			THE RELIABLE TRANSMISSION PACKAGE
;			PERFORMS ACKNOWLEDGEMENT AND
;			RETRANSMISSION FUNCTIONS FOR
;			RELIABLE COMMUNICATION VIA AN IMP
;			MODEM.   REFER TO BBN RPT #1822.

;			THE FOLLOWING CODE PROCESSES INCOMING
;			PACKETS FROM THE IMP.

;			----------

;			***  VDH PARAMETERS  ***


;			THE FOLLOWING PARAM DETERMINES THE NUMBER
;			OF VDH 'CHANNELS'.

VDH.CH	=	2		;SETUP FOR 2-CHANNEL RTP

;			THE FOLLOWING IS THE VDH/RTP 'K' PARAMETER
;			FOR DETERMINING LINE/IMP ALIVE STATUS.

VDH.K	=	4		;NUMBER OF "I-HEARD-YOU"
;				 PACKETS REQUIRED TO BRING LINE UP.

;			THE FOLLOWING IS THE VDH 'R' PARAMETER,
;			WHICH IS THE TIME CONSTANT FOR TRANSMITTING
;			THE RTP 'HELLO' MESSAGES.

VDH.R	=	1250.		;TIME CONST FOR SENDING "HELLO"'S

;			THE FOLLOWING PARAMETER DETERMINES THE
;			NUMBER OF 'HELLO' PACKETS WHICH MUST GO
;			UNANSWERED (WITH 'I-HEARD-YOU'S ) TO DECLARE THE
;			LINE DEAD.

VDH.T	=	6		 ; T = 6
;			
;			THE FOLLOWING IS THE AMOUNT OF TIME THE
;			RTP WAITS IF THE LINE IS DETERMINED TO BE
;			DOWN (THIS GIVES THE IMP TIME TO DECIDE ITS
;			DOWN TOO.)

VDTDW	=	2*VDH.T*VDH.R

MAXMGL	=	508.		;MAXIMUM MESSAGE LENGTH
NPAKSZ	=	64.		; NUMBER OF WORDS IN PACKET
RTNMSK	=	37400		;MASK TO OBTAIN WORD COUNT
RXVRT	=	200.		; TIMEOUT BEFORE RE-TRANSMISSION
	.PAGE
	.SBTTL	RELIABLE TRANSMISSION PACKAGE -- OPCODES

;			OPCODES FOR RTP INPUT PROCESS

OPRIC0	=	0		;INPUT CHANNEL COMPLETED
OPRIC1	=	1		;INPUT CHANNEL COMPLETED
OPRID	=	2		; IMP DEAD
OPRIT	=	3		;INPUT TIMER EXPIRED

;			OPCODES FOR RTP OUTPUT PROCESS

OPROM	=	0		;MESSAGE ON OUTPUT QUEUE
OPROC	=	1		;OUTPUT COMPLETED
OPROT	=	2		;TIMER (SEND "HELLO")
OPROI	=	3		;SEND "I HEARD YOU"
OPROA	=	4		;ACKNOWLEDGE RECEIVED PACKET
OPROD	=	5		;IMP GOING DOWN - DRAIN
OPRON	=	6		;OUTPUT CHANNEL AVAILABLE


;			OPCODES FOR NCP INPUT PROCESS

OPNCM	=	0		;MESSAGE PLACED ON HOST/IMP QUEUE
OPNCDD	=	1		;IMP CONNECTION DEAD (IMP DEAD)
OPNIUP	=	5		; NOTIFICATION THAT IMP IS UP

	.PAGE
	.SBTTL	$IMPIN -- IMP INITIALIZATION FOR INPUT

	.CSECT	$NIO		;NETWORK I/O CONTROL CSECT
$IMPIN:	MOV	IORB0,R0		;OBTAIN RAD50 DEVICE NAME
	MOV	IORB0+2,R1	;AND UNIT NUMBER
	$DFDEV	R0,R1		;DEFINE VDH INPUT
	MOV	IORB1,R0	;SET RAD50 CODE 'VDH'
	MOV	IORB1+2,R1	;AND ITS UNIT NUMBER
	$DFDEV	R0,R1		;DEFINE VDH INPUT CHNL 1
	$P	$NSEM		;INIT SEMAPHORE/INTERLOCK
	CLR	AMSGI		; INDICATE NO ACTIVE INPUT MSG

;			RETURN HERE TO RESTART RTP

IMPRS:	$HIO	#IORB0		;HALT I/O REQUESTS FOR INPUT
	$HIO	#IORB1		;ON BOTH INPUT CHANNELS
	CLR	$OEIN		;INIT RTP PARAMERTERS
	CLR	$CHNLI		;NIT INPUT ODD/EVEN, CHANNEL COUNTER
	CLR	$CHNLO		;AND OUTPUT CHANNEL NUMBER
	INCB	$DEAD		; SET DEAD FLAG
	MOV	#$RTOIU,R0	; SET ADDRX OF OUTPUT IN-USE FLGS
	MOV	#VDH.CH,R3	; NR CHANNELS
1$:	CLRB	(R0)+		; INIT OUTPUT-IN-USE FLAGS
	$LOOP	R3,1$
	CLR	$VDHCT		;INDICATE IN DEAD-WAIT
	CLRB	ACKFLG		;CLEAR ACK-REQUIRED FLAG
	MOVB	#7,IHYCT	;INIT "I-HEARD-YOU" COUNTER

;			RESET INPUT MESSAGE QUEUE

	MOV	#OPRIT,R0	; CANCEL PREV TIMER SETTING
	$STIME	R0,#0		; BY SETTING IT TO 0
	MOV	#377*400,R0	; SETUP FOR SIGNAL
	$SIGNL	R0,R0,R1	; SIGNAL PROCESS (SELF)
RI0:	$WAIT			; WAIT FOR THAT OPCODE
	TSTB	R0		;IN R0
	BPL	RI0		;AND THEN SET THE TIMER
	$STIME	#OPRIT,#VDTDW	;SET TIMER TO WAIT UNTIL DECLARED
	$NWATS	#OPRIT		;WAIT FOR EXPIRATION OF TIMER UP
	MOV	#-VDH.K,$VDHCT	;NOW TRY TO BRING UP LINE
	$SIO	#IORB0		;THEN START NEW REQUESTS
	$SIO	#IORB1		;IN BOTH INPUT CHANNELS
	$STIME	#OPRIT,#RXVRT	; SET RE-TRANSMISSION TIMER
RWAIT:	$NWAIT			;AWAIT COMPLETION OF INPUT REQUEST
	ASL	R0		;COMPUTE INDEX ON BRANCH TABLE
	BIC	#177770,R0	;CLEAR ALL BUT INDEX BITS
	JSR	PC,@RITBL(R0)
	BR	RWAIT		;BACK TO CHECK INPUT STATUS
	.PAGE

RITBL:	.WORD	RICC,RICC,RIID,RITIM

RIID:	TST	(SP)+		;FORGET RETURN ADDR, WE'RE RESTARTING
	BR	IMPRS		;AND BACK WE GO

RICC:	MOV	IRUVA(R1),R4	; OBTAIN BUFFER ADDRESS OF INPUT PACKET
	TST	IRBX(R1)	;TEST NUMBER BYTES-XFERRED
	BEQ	RICCE3		;INTERFACE ERROR.
	BIT	#177,IRSTA(R1)	; IS THERE AN INPUT ERROR?
	BNE	RICCE2		; YES, JUST RE-INITIALIZE INPUT
	JSR	PC,PACKIN	;PROCESS INPUT PACKET
RICCER:	$SIO	R1		;RE-INITIALIZE INPUT
	RTS	PC		;AND RETURN
RICCE2:	INC	$MS02		;INCREMENT MSG-RECEIVED IN ERROR
	BR	RICCER		;AND RE-INIT INPUT

RICCE3:	INC	$MS05		;COUNT NUMBER OF 0-BYTE PACKETS
	BR	RICCER		;AND TREAT THOSE AS ERROR



RITIM:	MOV	#OPRON*400,R0	; INIT R0
	BISB	$IMOPI,R0	; SET PROCESS ID
	$SIGNL	R0,R0,R1	; WAKUP OUTPUT PROCESS
	MOV	#OPRIT,R0	; SET OPCODE
	$STIME	R0,#RXVRT	; RESTART TIMER
	RTS	PC	;IGNORE TIMER INPUT IN THIS STATE
	.PAGE
	.SBTTL	PACKIN -- PACKET INPUT PROCEDURE

;			----------

;			BEGIN  ***  PACKIN  ***

;			THIS PROCEDURE PROCESSES A PACKET RECEIVED
;			FROM THE IMP.  THE CONTROL WORD IS EXAMINED
;			TO DETERMINE IF THE PACKET IS ACTUAL DATA,
;			A "SPECIAL PACKET", OR A NULL PACKET.
;			IF THE PACKET CONTAINS REAL DATA, IT IS
;			PLACED IN A BUFFER IN WHICH A MESSAGE IS BEING
;			FORMED.  IF THE "LAST-PACKET" BIT IS ON IN THE
;			CONTROL WORD, THE NEWLY-FORMED MESSAGE IS
;			PLACED ON THE IMP-HOST MESSAGE QUEUE, AND
;			THE NCP INPUT PROCESS IS AWAKENED (SIGNALLED).
;			IF THE ARRIVING PACKET IS A "SPECIAL" PACKET
;			(I.E., A "HELLO" OR "I-HEARD-YOU" PACKET)
;			THE PROCEDURE AWAKENS THE OUTPUT RTP PROCESS
;			FOR APPROPRIATE ACTION, AND UPDATES THE LINE
;			PACKET COUNTER.  IF THE PACKET RECEIVED IS
;			A NULL PACKET, THE OUTPUT PROCESS IS SIGNALLED,
;			UPDATING THE "CHANNEL-IN-USE" FLAG FOR THE
;			CORRESPONDING OUTPUT CHANNEL.

;			----------

PACKIN:	$PUSH	R0,R1		;SAVE CALLER REGS
	MOV	(R4),R0		; PACKET CONTROL WORD TO R0
	BIT	#100,R0		;SPECIAL PACKET?
	BNE	SPCPAK		;BRANCH IF SO
	MOVB	$OEOUT,R3	;ODD/EVEN, TRANSMIT SIDE TO R3
	MOVB	R0,$OEOUT	;MOVE CTRL WD ACK TO $OEOUT
	MOV	R3,R2		;MOVE OLD ODD/EVEN
	BIC	R0,R2		;COMPUTE XOR($OEOUT,ACKBITS)
	BIC	R3,R0		;ANY 1'S WILL INDICATE SUCCESS
	BIS	R0,R2		;R2=1 FOR EACH XMIT CHNL ACKNOLEGED
	ASR	R2		;ALIGN TO FLAG CHNL IN-USE BITS
	ASR	R2
	MOV	#$RTOIU,R3	;GET CHNL IN-USE PTR
	MOV	#VDH.CH,R1	;GET NUMBER OF CHANNLS
RTOC:	ROR	R2		;MOVE BIT TO C
	BCC	RONCL		;BRANCH IF NO ACK
	TSTB	(R3)		; IS ACK PENDING FOR XMIT CHNL ?
	BNE	1$		; YES, PROCEED TO RESET CHNL BUSY
	INC	$MS06		; INCREMENT SPURIOUS ACK COUNTER
1$:	CLRB	(R3)		;CLEAR IN-USE FLAG
	CMPB	R1,OCHFL	; IS ACKED CHANNEL AWAITED?
	BNE	2$		; NO, DON'T BOTHER WITH SIGNAL.
	$SIGNL	$IMOPI,#OPRON,R1	; SIGNAL OUTPUT PROCESS
2$:
RONCL:	INC	R3		;INCREMENT POINTER
	DEC	R1		;AND TALLY
	BGT	RTOC		;FOR ALL CHANNELS
	MOV	(R4),R0		;CONTROL WORD TO R0
	BIT	#RTNMSK,R0	;SEE IF NULL PACKET (WC=0)
	BEQ	RTINUL		; YES, SIMPLY SIGNAL OUTPUT PROCESS
	TSTB	ACKFLG		;SEE IF SIGNAL REQUIRED
	BNE	NSIG0		;IF NOT, DON'T SIGNAL OUTPUT PROCESS
	INCB	ACKFLG		;SET ACK FLAG
	$PUSH	R0		;SAVE CALLER
	MOV	#OPROA*400,R0	; SET OPCODE
	BISB	$IMOPI,R0	; SET IMP OUTPUT PROCESS ID
	$SIGNL	R0,R0,R1	; SIGNAL IMP OUTPUT
	$POP	R0		;THEN RESTORE REGS
NSIG0:

;		***	NOW PROCESS RECEIVE CHNLS IF NON-NUL
;				LOOK FOR DUPLICATE

	BIC	#100000,R0	;CLEAR LAST-PACKET BIT
	MOV	R0,R2		;SETUP FOR SHIFT
	BIC	#177774,R0	;GET CHANNEL NR RCD
	CMP	R0,$CHNLI	;IS THIS THE ONE WE WANT?
	BNE	RTINUL		;THROW IT AWAY
	SUB	#12.,R0		;PREPARE FOR RIGHTSHIFT
	$PUSH	R0		;R0 CONTAINS NEGATIVE NUMBER OF SHIFTS
	CLC			;SETUP FOR LOGICAL SHF RIGHT
	ROR	R2		;SHIFT RIGHT
	BR	RONRR		;INCREMENT TALLY AND SHIFT
	ASR	R2		;SHIFT DATA RIGHT
RONRR:	INC	R0		;INCREMENT AND TALLY
	BMI	.-4		;TILL 12.-CHNLNO PLACES
	MOV	#137777,R0		;OBTAN MASK IN R0
	ASR	R0		;SHIFT HIM 12.-CHNLNO PLACES
	INC	(SP)		;NOW USE TALLY ON STACK
	BMI	.-4		;INCREMENT TILL 0
	TST	(SP)+		;REMOVE THE 0 FROM STACK
	MOVB	$OEIN,R1	;PUT RCV O/E BITS IN R1
	MOV	R2,R3		;COMPUTE XNOR(R1,R2)
	BIC	R1,R3		;AND STICK RESULT
	BIC	R2,R1		;IN R1, INDICATING DUPLICATE
	BIS	R3,R1		;GET XOR
	BIC	R0,R1		;SELECT CORRECT CHNL O/E BIT
;
;			** NOTE **
;
;		IF R1 NE 0 THEN DUPLICATE

	COM	R2		;COMPLEMENT PACKET O/E BIT
	BIC	R0,R2		;AND SELECT ONLY CORRECT CHNL
	COM	R0		;COMPUTE NOT(MASK)
	BICB	R0,$OEIN	;CLEAR APPROPRIATE O/E BIT IN $OEIN
	BISB	R2,$OEIN	;AND SET ITS NEW VALUE
	BICB	#303,$OEIN	;CLEAR ALL BUT RCV OE BITS
;
;			*** END OF RECEIVE ODD/EVEN LOGIC ***
;

	MOV	(R4),R0		;GRAB CONTROL WORD BY ASS
	INC	$MS00		;INCR NR PACKETS RCVED W/O ERROR
	TST	R1		;SEE IF DUPLICATE PACKET
	BGT	RTINUL		;REINIT INPUT, AND USE CRASS LANGUAGE
;			***
;			***  ITS A MESSAGE PACKET
;			***
	INC	$MS01		;INCR NR NON-DUPLICATES
	JSR	PC,RIENQ	;PUT MESSAGE IN IMP-HOST QUEUE
	MOV	$CHNLI,R0	;GET INPUT CHNL NR
	INC	R0		;INCREMENT IT
	CMP	R0,#VDH.CH	;CMPR TO MAX CHNL
	BLT	1$		;SKIP RESET CHNL TO 0
	CLR	R0
1$:	MOV	R0,$CHNLI	;SETUP CHNL NUMBER IN
RTINUL:	$POP	R1,R0		;RESTORE REGS
	RTS	PC		;  END  ***  PACKIN  ***

SPCPAK:	TST	R0		;SPECIAL PACKET; HELLO?
	BMI	SPCIHY		;ITS 'I HEARD YOU'
	TSTB	IHYCT		;SEE IF LIMIT EXCEEDED
	BMI	RTINUL		;YES, DONT SEND "IHEARDYOU"
	DECB	IHYCT		;DECREMENT COUNTER, AND SIGNAL
	MOV	#OPROI*400,R0	; SET OPCODE FOR SIGNAL
	BISB	$IMOPI,R0	; AND SET PROCESS ID (OUTPUT
	$SIGNL	R0,R0,R1	; THEN SIGNAL OUTPUT PROCESS)
	BR	RTINUL		;RETURN, THRU WITH PACKET
SPCIHY:	TST	$VDHCT		;HAVE WE DIED?
	BGT	SDCT		;NO, RESET COUNTER
	INC	$VDHCT		;INCREMENT VDH COUNTER
	BLT	RTINUL		;DISCARD PACKET IF NOT ALIVE YET
	CLRB	$DEAD		;INDICATE ALIVE
	MOV	#OPNIUP*400,R0	; OPCODE TO TELL NCP IMP IS UP
	BISB	$NCPI,R0	; SET NCP PROCESS ID
	$SIGNL	R0,R0,R1	; AND WAKE HIM UP
SDCT:	MOV	#VDH.T,$VDHCT	;INIT VDH COUNTER FOR ALIVE
	BR	RTINUL		;THRU WITH PACKET, RETURN
	.PAGE
	.SBTTL	ENQUEUE MESSAGE FOR NCP

RIENQ:	MOV	R4,APAK		;SAVE ADDRESS OF PACKET
	MOV	AMSGI,R1		;GET ADDRX OF MESSAGE
	BNE	MMS1		;DEFINED? BRCH IF YES
	TST	(R4)		;LAST PACKET?
	BMI	MLSTP		;BRANCH IF YES
	MOV	#1,R0		;SET POOL 1, 512 WORD MSG
MLAL0:	MOV	R0,APOOL	;STORE POOL NUMBER
	JSR	PC,$ALOCW	;ALLOCATE A BUFFER
;				 WAIT FOR COMPLETION OF ALLOCATE
	MOV	R1,AMSGI	;STORE ADDRX OF MESSAGE
	CLR	AMNDX		;CLEAR MSG INDEX
MMS1:	MOV	APAK,R4		;RESTORE BASE OF PACKET
	MOV	(R4),R0		;GET CONTROL WORD
	MOV	AMNDX,R2	;SETUP INDEX
	BIC	#177777-RTNMSK,R0	;GET WORD COUNT
	SWAB	R0		;IN LO BYTE
	BEQ	RIMPE2		; ZERO LENGTH MESSAGE
	ADD	R0,R2
	CMP	R2,#MAXMGL	;G.T. MAX MSGLEN?
	BGT	RIMPE1		;IMP ERROR
	MOV	AMNDX,R2	;MOVE MESSAGE INDEX TO R2
	ASL	R2		;GET OFFSET (BYTES)
	ADD	R2,R1		;COMPUTE MSG PTR
	ADD	R0,AMNDX	;UPDATE MSG INDEX (WORDS)
	TST	(R4)+		;POINT TO ACTUAL MESSAGE
RIMLP1:	MOV	(R4)+,(R1)+	;MOVE PACKET TO MSG
	DEC	R0		;TALLY NR WDS
	BGT	RIMLP1		;LOOP TO MOVE PACKET TO MESSAGE
	MOV	APAK,R4		;RESTORE ADDRX OF PACKET
	TST	(R4)		;LAST PACKET?
	BGE	RINQ		;IF NOT, DONT ENQUEUE MSG TO I-H
	TST	APOOL		; BUFFER ALREADY ALLOCATED IN POOL 0 ?
	BEQ	RIMLP3		; YES, DON'T MOVE INTO POOL 0 BUF
	CMP	AMNDX,#NPAKSZ	; COMPARE TO SEE IF LESS THAN 1 PACKET
	BLOS	RTRADE		; IF SO, THEN MOVE INTO SMALL BUFFER
RIMLP3:	JSR	PC,$GFMQE	;GET FREE MSG QUEUE EL
	MOV	R4,R0		;ELEMENT ADDR TO R0 FOR $ENQ
	MOV	AMSGI,-(R4)	;MESSAGE ADDR
	MOV	APOOL,-(R4)	;POOL ID
	MOV	AMNDX,-(R4)	;LENGTH
RIMLP2:
	.IF EQ DEBUG-1
	$PUSH	R1
	CLR	R1		; SET FLAG FOR TRACE
	JSR	PC,$TRACE
	$POP	R1
	.ENDC
	MOV	#$IHQ,R2	;ADDR OF IMP-HOST QUEUE
	JSR	PC,$ENQ		;ENQUEUE MESAGE
	CMP	(R2)+,(R2)	; IS SOLE MESSAGE ON NCP'S QUEUE ?
	BNE	RIMNS		; NO, ASSUME NCP WILL WAKE UP LATER
	$SIGNL	$NCPI,#OPNCM,R1		;SIGNAL MSG ON IHQ
RIMNS:	MOV	APAK,R4		;RESTORE ADDR OF PACKET
RIMPEX:	CLR	AMSGI		;INDICATE NO MESSAGE
RINQ:	RTS	PC	
RIMPE1:	INC	$MS07		; INCREMENT NR ILLEGAL MESSAGES
	BR	RIMPEX		; BACK TO DISCARD PACKET
RIMPE2:	INC	$MS08		; NR PACKETS WITH 0 WORD COUNT
	BR	RIMPEX		; DISCARD THE PACKET

;			HERE WE ALLOCATE A SMALL BUFFER FOR
;			SINGLE-PACKET MESSAGES, AND MOVE SUCH MESSAGES
;			INTO IT, FREEING THE LARGE BUFFERS.

RTRADE:	MOV	AMNDX,R0	; MESSAGE INDEX
	ASL	R0		; BYTES...
	$PUSH	R0		; SAVE POOL IDENTIFIER
	JSR	PC,$ALOCW	; ALLOCATE IT
	$PUSH	R1		; SAVE NEW BUFFER ADDRESS
	MOV	AMNDX,R3	; OBTAIN ACTUAL NUMBER OF WORDS READ IN R3
	MOV	AMSGI,R4	; BUFFER ADDRX IN R4
1$:	MOV	(R4)+,(R1)+	; MOVE MESSAGE TO NEW BUFFER
	$LOOP	R3,1$		; LOOP FOR ALL WORDS IN INPUT
	JSR	PC,$GFMQE	; ALLOCATE AN MQE
	MOV	R4,R0		; MQE ADDRX TO R0
	$POP	-(R4),-(R4)	; ADDRESS ALLOCATED POPPED INTO MQE
	MOV	AMNDX,-(R4)	; WORD COUNT INTO MQE
	$PUSH	R0		; SAVE MQE POINTER
	MOV	APOOL,R0	; POOLID OF OLD ELEMENT
	MOV	AMSGI,R1	; BUFFER ADDRESS
	JSR	PC,$FREEB	; FREE IT
	$POP	R0		; RESTORE NEW MQE POINTER
	BR	RIMLP2		; BACK FOR ENQUEUE


MLSTP:	MOV	#4,R0		; SET LENGTH FOR SINGLE PACKETEERS
	BR	MLAL0		;CONTINUE WITH 64 WORD BUFFER
	.PAGE
	.SBTTL	RTP - OUTPUT PROCESSOR

	.CSECT	$NIO		;CONTINUE NETWORK I/O CONTROL CSECT


;			VDH OUTPUT CONTROL

$IMPOU:	$DFDEV	IORB2,IORB2+2	;DEFINE VDH OUTPUT DEVICE
	$P	$NSEM		;INIT INTERLOCK
	MOV	SP,RSOSSA	; SAVE INIT STACK VAL
ROCON1:	MOV	#OPROT,R0	; MOVE TIMER OPCODE TO R0
	$STIME	R0,#VDH.R	; SET TIMER FOR OUTPUT PROC.
ROUTPT:	$NWAIT			;WAIT FOR TIMER OR OTHER SIGNL
	TST	$VDHCT		; REMAIN SILENT WHILE DEAD
	BEQ	ROCON1		;AND SIMPLY RESET TIMER
	ASL	R0		;ALIGN OPCODE
	BIC	#177760,R0	;CLEAN OFF UNWANTED BITS
	JSR	PC,@ROTBL(R0)	;CALL INTERPRETER
	BR	ROUTPT		;WAIT UNTIL SIGNALLED

ROTBL:	.WORD	ROMSG,ROUTPT,ROHELO,ROROI,ROROA,ROROD,RORON

ROROI:	JSR	PC,ROSPI	;SEND "I HEARD YOU"
	INCB	IHYCT		;INCREMENT "I-HEARD-YOU" COUNTER
	RTS	PC		;AND RETURN

ROHELO:	TST	$VDHCT		;CHECK IMP DEAD/COMING UP
	BEQ	RORTS		;BRANCH IF INITIAL DEAD WAIT
	BMI	RN2D		; BRANCH IF COMING UP
	DEC	$VDHCT		; DECREMENT VDH COUNTER
	BGT	RN2D		;BRANCH IF STILL ALIVE
ROROD:	CLR	$VDHCT		; INIT COUNTER
	INCB	$DEAD		;SET DEAD FLAG
	CLR	R0		; SETUP FOR BIS
	BISB	$NCPI,R0	;NCP PROC. ID TO R0
	BIS	#OPNCDD*400,R0	; SET OPCODE IN HIGH 8 BITS
	$SIGNL	R0,R0,R1	; SIGNAL NCP THAT IMP DIED
	CLR	R0		; INIT R0 FOR BIS
	BISB	$IMIPI,R0	; SET IMP INPUT PROCESS ID
	BIS	#OPRID*400,R0	; SET OPCODE IN HIGH 8 BITS
	$SIGNL	R0,R0,R1	; SIGNAL INPUT PROCESS TO RESTART
;				 NOW ISSUE LAST "HELLO"
RN2D:	JSR	PC,ROSPH	;SEND "HELLO MESSAGE"
	MOV	#OPROT,R0	; SET OPCODE FOR TIMER EXPIRATION
	$STIME	R0,#VDH.R	; SET TIME TIL NEXT "HELLO" MSG
RORTS:	RTS	PC		;AND RETURN TO CALLER 

	.PAGE
	.SBTTL	RTP OUTPUT INTERPRETER

ROMSG:	MOV	#$HIQ,R2	;FETCH ENTRY FROM HOST-IMP QUEUE
	JSR	PC,$DEQ		;PULL IT OFF THE QUEUE
	BEQ	ROROA		;NO ENTRIES ON IT
	JSR	PC,RTSNDM	;SEND THE MQE POINTED TO BY R0
	RTS	PC

ROROA:	CLRB	ACKFLG		;ALLOW SIGNALS
	JSR	PC,RSN		;SIMPLY SEND A NULL PACKET
	RTS	PC		;AND RETURN

RORON:
	RTS	PC
	.PAGE
	.SBTTL	OUTPUT MESSAGE CONTROL

RTSNDM:	MOV	R0,MQPT		;SAVE MESSAGE QUEUE POINTER
	.IF EQ DEBUG-1
	$PUSH	R1
	MOV	#1,R1		; SET 'SEND' FLAG
	JSR	PC,$TRACE
	$POP	R1
	.ENDC
	MOV	-(R0),AMSGO	;GET ADDRX OF MESSAGE
	MOV	-(R0),POOLID	;GET POOLID
	MOV	-(R0),MSGL	;MESSAGE LENGTH

;		***
;		***  WE HAVE WORK TO DO
;		***  I.E., THERES A MESSAGE
;		***  ON THE HOST/IMP QUEUE
;		***


	CLR	MSGNDX		;INITIALIZE INDEX TO MESSAGE
;			TRANSMIT THE NEXT PACKET IN A
;			MESSAGE
PCHNL:	MOV	$CHNLO,R0	;GET CHNL NR
	TSTB	$RTOIU(R0)	;TEST OUTPUT IN USE
	BEQ	RTSND		;NOT IN USE, READY-TO-SEND
	JSR	PC,RESEND	;RE TRANSMIT MESSAGE
	BR	PCHNL		; TRY AGAIN
RTSND:	INCB	$RTOIU(R0)	;SET IN-USE FLAG
	ASL	R0
	MOV	OBUFL(R0),R2	;GET OUTPUT BUFFER ADDRX
	TST	MSGNDX		;IS THIS THE FIRST PACKET IN MSG
	BNE	RREMSG		;SEND REMAINDER
	MOV	AMSGO,R1	;SEND ONLY LEADER IN FIRST PACKET
	MOV	#2,R3		;SET LENGTH EQ 2 WORDS
RTS2:	JSR	PC,SENDIT	;INITIATE TRANSMISSION OF MSG
	MOV	$CHNLO,R0	;GET CHNL NR
	INC	R0		;ADVANCE TO NEXT
	CMP	R0,#VDH.CH	;IS THAT THE LAST CHNL?
	BLT	1$		; NO, UPDATE IT
	CLR	R0		;YUP, RESET TO BEGIN
1$:	MOV	R0,$CHNLO	;UPDATE $CHNL

	CMP	MSGNDX,MSGL	;DID WE FINISH MSG?
	BLT	PCHNL		;NOPE
	TST	$HIQ		; IS THERE ANYTHING QUEUED TO GO ??
	BNE	2$		; YES, DON'T BOTHER WITH NULL PACKET
	JSR	PC,RSN		; SEND A NULL, INSURE MSG MADE IT

;			  MESSAGE HAS BEEN SUCCESSFULLY
;			  TRANSMITTED....FREE MQE BUFFER AND
;			  MQE IF NCP HAS SO REQUESTED (AS
;			  INDICATED BY NEGATIVE POOLID IN MQE).

2$:	MOV	MQPT,R0		;OBTAIN MESSAGE QUEUE POINTER
	TST	-4(R0)		;IS POOLID NEG ??
	BPL	PNFRMQ		; NO, DONT RELEASE MQE
	JSR	PC,$DISMQ	; DISCARD MQE AND ASSOC. BUFFER.
PNFRMQ:	RTS	PC		;THAT'S IT

RSN:	CLR	R0		;SEE IF ANY ARE LEFT OUTSTANDING
ROQTB:	TSTB	$RTOIU(R0)	;ANY CHNLS BZY?
	BEQ	RTOSCN		;NO, NOT THIS ONE
	JSR	PC,RESEND	;RE-INIT TRANSMISSION
	BR	ROQTB		; KEEP ON TRUCKING
RTOSCN:	INC	R0		;INCREMENT INDEX
	CMP	R0,#VDH.CH	;SENT ALL CHNLS?
	BLT	ROQTB		;LOOP THRU THEM
	JSR	PC,ROSNUL	;SEND NULL
	RTS	PC		;RETURN

RREMSG:	MOV	MSGL,R3		;XFER MESSAGE LENGTH
	SUB	MSGNDX,R3	;HOW MUCH IS THERE TO GO?
	CMP	R3,#63.		;TRIM
	BLE	3$
	MOV	#63.,R3		;TO 63 IF GT 63
3$:	MOV	MSGNDX,R1	;GET BUFFER ADDRX
	ASL	R1		;IN BYTES
	ADD	AMSGO,R1	;ADD TO BASE OF BUFFER
	BR	RTS2		;BACK TO ISSUE SENDIT

ROSPH:	MOV	#300,R0		;SETUP TO SEND 'HELLO' PACKET
	BR	ROSCOM		;SEND SPECIAL PACKET
ROSPI:	MOV	#100300,R0	;SETUP FOR 'I HEARD YOU'
	BR	ROSCOM		;SEND SPECIAL PACKET


ROSNUL:	MOV	#200,R0		;SET 'FOR-IMP' BIT
	BISB	$OEIN,R0	;OR IN RECEIVE ACK BITS
ROSCOM:	MOV	R0,RTONP	;MOVE TO NULL PACKET
	MOV	#RTONP,IORB2+IRUVA ;SET CALLER VIRTUAL ADDRX
	MOV	#2,IORB2+IRBR	;AND BYTES REQUESTED
	JSR	PC,SEND		;SEND AN WAIT OUTPUT COMPLETE
	RTS	PC		;AND RETURN

;		*** OUTPUT CONTROLLER ***
;			R1 =	MSG BUFFER ADDR
;			R2 = PACKET BUFFER ADDR
;			R3 = NUMBER OF WORDS TO SEND

SENDIT:	MOV	R3,R0		;XFER NR WDS
	INC	$MS03		;INCR NR ORIGINAL XMISSIONS
	SWAB	R0		;INTO WORD COUNT
	BIS	#200,R0		;SET 'FOR IMP'
	BISB	$OEIN,R0	;FETCH ACKNOWLEDGE BITS
	BIS	$CHNLO,R0	;GET CHNL NUMBER
	MOV	#12.,R4	;MOVE NR SHIFTS
	SUB	$CHNLO,R4	;SHIFT LEFT BY
	$PUSH	R0		;SAVE R0, CURRENT
	MOVB	$OEOUT,R0	;GET ODD/EVEN OUTPUT BITS
SEASL:	ASL	R0		;SHIFT (R4) TIMES
	$LOOP	R4,SEASL	;TALLY AND SHIFT
	BIC	#137777,R0	;CLEAR ALL BUT ODD/EVEN BIT
	BIS	(SP)+,R0	;OR ODD/EVEN BIT INTO CTRL WORD
	ADD	R3,MSGNDX	;BUMP INDEX
	CMP	MSGNDX,MSGL	;IS THIS THE LAST
	BLT	1$		;BRANCH IF NO
	BIS	#100000,R0	;ELSE SET 'LAST PACKET'
1$:	MOV	R0,(R2)+	;STORE CONTROL WORD
	MOV	R3,R0		;MOVE WORD COUNT
2$:	MOV	(R1)+,(R2)+	;STORE DATA IN PACKET BUFFER
	$LOOP	R0,2$		;TRANSFER MESSAGE INTO PACKET BUFFER
	INC	R3		;INCLUDE CONTROL WORD
	ASL	R3		;OBTAIN NUMBER OF BYTES
	SUB	R3,R2		;MESSAGE POINTER
	MOV	R3,IORB2+IRBR	;SET BYTES REQUESTED
	MOV	R2,IORB2+IRUVA	;SET VIRTUAL ADDRESS
SEND:	$SIO	#IORB2		;INIT I/O ON OUTPUT BUFFER
	$NWATS	#OPROC		;WAIT FOR OUTPUT COMPLETE
	RTS	PC		;AND RETURN
	.PAGE
	.SBTTL	VDH RESEND/RE-TRANSMISSION LOGIC

RESEND:	$PUSH	R0		;SAVE CHANNEL NUMBER
	MOVB	R0,OCHFL	; SETUP OUTPUT CHANNEL FLAG

RSCHK:	$TSTQS	#OPROI		; NOW CHECK FOR POSSIBLE SIGNALS
	BNE	RSOOI		; DURING RE-TRANSMISSION
	$TSTQS	#OPROT		; SEND 'HELLO'
	BNE	RSOOT
	TSTB	$DEAD		; HAS IMP/LINE DIED?
	BNE	RSEXIT		; EXIT OF IMP DIED
	$TSTQS	#OPROA		; ACK NECESSARY ?
	BNE	RSOOA		; YUP
	$TSTQS	#OPRON		; TIME TO RESEND?
	BNE	RSOON		; MOVING TO MONTANA SOON
	$V	$NSEM		; RELEASE INTERLOCK
	$DSCHD			; WAIT FOR ELEMENT
	$P	$NSEM
	BR	RSCHK		; AND RETURN WHEN READY.
RSOOT:	$WAITS	R0
	JSR	PC,ROHELO	; SEND A 'HELLO'
	BR	RSCHK
RSOOA:	$WAITS	R0
	CLRB	ACKFLG
	JSR	PC,ROSNUL	; ACK WITH A NULL
	BR	RSCHK		; BACK TO CHECK AGAIN
RSOOI:	$WAITS	R0
	JSR	PC,ROROI	; SEND 'I HEARD YOU'
	BR	RSCHK
RSEXIT:	MOV	MQPT,R0		; OUTPUT MESSAGE QUEUE PTR
	BEQ	1$		; THERE ISN'T ANY
	TST	-4(R0)		; IS IT TO BE DISCARDED?
	BPL	1$		; NO, NOT AT THIS POINT
	JSR	PC,$DISMQ	; DISCARD MQE
1$:	MOV	RSOSSA,SP	; RESET STACK
	JMP	ROCON1		; RESTART OUTPUT PROCESS.
RSOON:	$WAITS	R0
	COMB	OCHFL		; CANCEL OUTPUT CHECK FLAG
	MOV	(SP),R0		; CHNL NR TO R0
	ASL	R0		;CHNLNR * 2
	INC	$MS04		;INCREMENT NR RETRANSMISSIONS
	MOV	OBUFL(R0),R2	;GET BUFFER ADDR
	MOV	(R2),R0		;GET CONTROL WORD
	BIC	#74,R0		;UPDATE ACK BITS
	BISB	$OEIN,R0	;IN CONTROL WORD
	MOV	R0,(R2)		;STORE BACK IN BUFFER
	SWAB	R0		;EXTRACT WORD COUNT
	BIC	#177700,R0	;CLEAR OTHER BITS
	INC	R0		;INCLUDE CONTROL WORD
	ASL	R0		;OBTAIN COUNT, BYTES
	MOV	R0,IORB2+IRBR	;SET BYTES REQUESTED
	MOV	R2,IORB2+IRUVA	 ;AND VIRTUAL ADDRESS
	JSR	PC,SEND		;SEND IORB2 (OUTPUT)
	$POP	R0		;RESTORE CHANNEL NUMBER
	RTS	PC

	.IF EQ DEBUG-1
	.PAGE
	.SBTTL	RTP -- TRACE FACILITY

;			ASSUME R0 POINTS TO MQE
;				R1 = FLAG 0 IF RCV,  1 IF SND

$TRACE:	$PUSH	R0,R1,R3,R4
	MOV	$TRCAC,R4
	MOV	(R4),R4
	MOV	R4,$TRCAC	; UPDATE ACTIVE TRACE POINTER
	CMP	(R4)+,(R4)+	; BUMP PAST LINK ELEMENTS
	MOV	R0,(R4)		; SET MQE POINTER VALUE
	BIS	R1,(R4)+	; AND INSERT FLAG
	MOV	-(R0),R1	; MSG ADDR
	MOV	R1,(R4)+	; INTO TRC EL
	MOV	-(R0),(R4)+	; POOLID
	MOV	-(R0),(R4)+	; LENGTH
	MOV	#TRCLEN/2-6,R3	; TALLY, WORDS
1$:	MOV	(R1)+,(R4)+	; MOVE FIRST WORDS OF MSG INTO TRCTBL
	$LOOP	R3,1$
	$POP	R4,R3,R1,R0	; RESTORE REGS
	RTS	PC		; AND THAT'S ALL

$TRCAC:	.WORD	TRCTBL		; POINTER TO LAST USED TRC ELEMENT.

TRCLEN	=	32.		; TRACE ELEMENT LENGTH, BYTES
TRCCNT	=	32.		; NUMBER OF TRC ELEMENTS

TRCTBL:
	.REPT	TRCCNT
	.WORD	.+TRCLEN	; FORWARD PTR
	.WORD	.-TRCLEN-2	; PREV. PTR
	.WORD	0		; FLAG AS UNUSED
	.BLKB	TRCLEN-6	; RESERVE STORAGE FOR TRC EL.
	.ENDR
.=TRCTBL+2
	.WORD	TRCTBL+<TRCLEN*TRCCNT>-TRCLEN
.=TRCTBL+<TRCCNT*TRCLEN>-TRCLEN
	.WORD	TRCTBL		; LINK TO FIRST ELEMENT
.=TRCTBL+<TRCLEN*TRCCNT>
	.ENDC

	.PAGE
	.SBTTL	RTP -- DATA AREA


;			----------

;			RTP CRITICAL CONSTANTS

;			----------

	.CSECT


$VDHCT:	.WORD	0		;VDH LINE MONITOR COUNTER
$DEBUG:	.BYTE	0		;DEBUG MODE - SET BY OPERATOR
$VDHFL:	.BYTE	0		;VDH FLAGS (LINE DEAD/ALIVE)
$IHBIT:	.BYTE	0		;CURRENT IMP-HOST FLAG
	.BYTE	0		; NOT USED
$OEIN:	.BYTE	0		;ODD/EVEN BITS , INPUT
$OEOUT:	.BYTE	0		;ODD/EVEN BITS, OUTPUT
$CHNLI:	.WORD	0		;CURRENT INPUT CHANNEL (LOGICAL)
$CHNLO:	.WORD	0		;CURRENT OUTPUT CHANNEL
RSOSSA:	.WORD	0		; STACK VALUE SAVE
ACKFLG:	.BYTE	0		;ACKNOWLEGEMENT FLAG
IHYCT:	.BYTE	0		;"I-HEARD-YOU" COUNTER
OCHFL:	.BYTE	0,0	; OUTPUT CHANNEL ACK-AWAITED FLAG

RTABL:	.WORD	RBUF0,RBUF1	;ADDRESSES OF BUFFERS

AMSGI:	.WORD	0	;ADDRESS OF INPUT MESSAGE BEING CONSTRUCTED
APAK:	.WORD	0
APOOL:	.WORD	0
AMNDX:	.WORD	0

;		***		RTP		   ***
;		***  SYSTEM MEASUREMENT CONSTANTS  ***


$MS00:	.WORD	0		; NUMBER PACKS RCD W/O ERROR
$MS01:	.WORD	0		; NUMBER OF NON-DUPLICATES RCD
$MS02:	.WORD	0		; NUMBER MESSAGE RECEIVED IN ERROR
$MS03:	.WORD	0		; NUMBER OF ORIGINAL TRANSMISSIONS (SENDS)
$MS04:	.WORD	0		; NUMBER OF RETRANSMISSIONS
$MS05:	.WORD	0		; NUM 0-BYTE PACKETS RECEIVED
$MS06:	.WORD	0		; NUMBER OF 0-LENGTH CONTROL WDS PACKETS
$MS07:	.WORD	0		; NUMBER OF ILLEGAL MESSAGE LENGTH
$MS08:	.WORD	0		; NUMBER OF SPURIOUS ACKS


RBUF0:	.BLKW	64.		;INPUT BUFFERS
RBUF1:	.BLKW	64.

	.SBTTL	RTP OUTPUT CONTROLLER DATA AREA

	.CSECT			;OUTPUT DATA AREA

$RTOIU:	.REPT	VDH.CH		;LIST OF OUTPUT CHNL STAT BYTES
	.BYTE	0
	.ENDR
RTONP:	.WORD	0		;CELL FOR USE AS NULL PACKET
AMSGO:	.WORD	0		;ADDR OF CURRENT MSG
POOLID:	.WORD	0		;CURRENT BUFFER POOL DESCR
MSGL:	.WORD	0		;MSG LEN (WORDS)
MSGNDX:	.WORD	0		;CURRENT INDEX INTO MSG (WORDS)
MQPT:	.WORD	0		;CURRENT MSG QUEUE POINTER

	.PAGE
	.SBTTL	I/O REQUEST BLOCKS FOR VDH

;			THESE I/O REQUEST BLOCKS ASSUME MATCHING
;			I/O DRIVERS CONTAINED IN THE ELF KERNEL.
;			THE FOLLOWING IMP I/O CONFIGURATION IS
;			ASSUMED:

;			  I/O DEVICE NAME: VDH
;			  UNIT NUMBERS:

;			  0 -- VDH CHANNEL 0, INPUT
;			  1 -- VDH CHANNEL 1, INPUT
;			  2 -- VDH OUTPUT


IORB0:	.RAD50	'VDH'	;NAME OF DEVICE
	.WORD	0	;UNIT 0
	.BYTE	OPRIC0,0	;OPCODE, VSM ID
	.WORD	RBUF0		;BUFFER ADDRESS
	.WORD	1		; FUNCTION = READ
	.WORD	128.,0,0,0,0	;BYTES REQUESTED, STATUS, BYTES XFERRED


IORB1:	.RAD50	'VDH'		;VDH UNIT 1
	.WORD	1		;UNIT 1
	.BYTE	OPRIC1,0	;OPCODE, VSM ID
	.WORD	RBUF1		;BUFFER ADDRESS
	.WORD	1		;FUNCTION = READ
	.WORD	128.,0,0,0,0	;BYTES REQUESTED, STATUS, BYTES XFERRED

IORB2:	.RAD50	'VDH'		;VDH UNIT 2, OUTPUT
	.WORD	2		;UNIT 2
	.BYTE	OPROC,0		;OPCODE, VSM ID
	.WORD	0		;** TO BE FILLED IN WITH BUFFER ADDRESS **
	.WORD	2		;FUNCTION = WRITE
	.WORD	0		;TO BE FILLED IN WITH REQUEST BYTE-COUNT
	.WORD	0,0		;STATUS, BYTES XFERRED
	.WORD	0,0		;DEVICE BLOCK ADDRESS (NOT USED)
OBUFL:	.WORD	TBUF0,TBUF1	;OUTPUT BUFFERS

TBUF0:	.BLKW	64.
TBUF1:	.BLKW	64.

	.END
 -AV
  