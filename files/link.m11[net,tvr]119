;	PDP-11 LINKER,LINK V011A
;	COPYRIGHT 1970,1971,1972 DIGITAL EQUIPMENT CORPORATION
;       14 AUG 72
	.TITLE	LINK
;	TAPE 1
;
.MCALL	.CLOSE,.CORE,.CSI1,.CSI2,.CVTDT,.DELET,.DTCVT,.D2BIN
.MCALL	.EXIT,.INIT,.MONF,.OPEN,.O2BIN,.RADPK,.READ,.RLSE,.RSTRT
.MCALL	.STAT,.TMCVT,.TRAN,.TRAP,.WAIT,.WRITE,.GTCIL,.LOOK
;

	.MACRO	VRSION
	.ASCII	/V11A01/
	.ENDM

;

;
	.IFDF	DEBUG
	.GLOBL	REPORT
	.ENDC
;
;	DEFINE REGISTERS
;
	R0=%0
	R1=%1
	R2=%2
	R3=%3
	R4=%4
	R5=%5
	SP=%6
	PC=%7
;
;	DEFINE PARAMETERS
;
;	ASCII CHARACTERS
	CR=15
	LF=12
	VT=13
	TAB=11
	FF=14			;FORM FEED
	LANG=74			;<
	RANG=76			;>
	CRLF=005015
	L=114

;
;	SYMBOL TABLE PARAMETERS
;
	BPSYM=10.		;# OF BYTES PER SYMBOL
	BASE=8.			;DISTANCE TO BASE OF A SECTION
	FLAGS=4			;DISTANCE TO FLAGS OF AN ENTRY
	VALR=6			;DISTANCE TO RELOCATABLE VALUE OF AN ENTRY
	NAME2=2			;DISTANCE TO 2ND WORD ON AN ENTRY
	OBJMN=0			;OBJECT MODULE NAME
	SECTN=1			;SECTION NAME
	SYMN=4			;SYMBOL ENTRY
	ABSREL=40		;ABS/REL BIT (0/1)
	UNDEF=10		;UNDEFINED/DEFINED (0/1)
	INTGLB=100		;INTERNAL/GLOBAL (0/1)
	MONCND=1		;MONITOR ROUTINE CANDIDATE
	LOCAL=5			;LOCAL SECTION NAME
	IDENT=6			;IDENT DIRECTIVE.

;
;	TXT MODIFICATION COMMANDS
;
	TCMD1=1			;INTERNAL RELOCATION
	TCMD2=2			;GLOBAL RELOCATION
	TCMD3=3			;INTERNAL DISPLACED
	TCMD4=4			;GLOBAL DISPLACED
	TCMD5=5			;GLOBAL ADDITIVE
	TCMD6=6			;GLOBAL ADDITIVE DISPLACED
	TCMD7=9.		;GENERATE LIMITS

;
;	PC MODIFICATION COMMANDS
;
	PCMD1=7			;SET PC
	PCMD2=8.			;MODIFY PC
;	MISCELLANEOUS

	SPLEN=100.		;STACK LENGTH

	ALODSZ=320		;ABSOLUTE LOADER SIZE
	HGHMEM=16384.		;HIGH MEMADR +1

;
;	MONITOR IO COMMANDS
;
	INIT=6
	OPEN=16
	OPENI=4
	OPENO=2
	RSTRT=41
	WAIT=1
	READ=4
	WRITE=2
	CLOSE=17
	RELEAS=7
	TRAPV=41
	CSI1=56
	CSI2=57
	FMS=41
	CONV=42
	DELET=21
	TRAN=10
	STAT=13
	GET=65
	GUT=41
	ACTION=40003			;EXECUTE LOAD MOD
	.IFDF	BLKIO
	.GLOBL	READIT,READST,CLOSRD,INITRD
	.GLOBL	RLSRD,OPENRD,READIU,XXREAD,INA,INB,OBJDEV
	.GLOBL	TRNBLK,OBJADR
	.ENDC

;
;	MONITOR IO DATA MODES
;
	FASC=0
	FBIN=1
	UFBIN=3
;
;	MONITOR IO ERROR BITS
;
	EOF=100
;
;	BLOCK TYPE COMMANDS
;
	GSDBLK=1
	TXTBLK=3
	RLDBLK=4
	ISDBLK=5
	MODEND=6
	GSDEND=2
	STBBLK=9.
	STBEND=10.
;
;	JUMP TABLE MAX INDICES.
;
	SWSMAX=6
	TMAX=3		;SEE LINK57
	GSDMAX=6	;SEE GGSD05
	PMAX=6		;SEE SCMDT
	CMDMAX=14.	;SEE RCMDT
	ERMAX=3		;SEE ERTAB
;	COMD SIZE (BYTES)
	COMDSZ=36
	IND=6		;INDEX INTO FILE BLOCK
;	MISCELLANEOUS
	BUF=104.	;52 WORDS FOR CSI BUFFS.
	DETACH=40	;DETACH BIT FOR HEADERS
	MXDVSZ=1000.	;ASSUME 500 WORDS MAX SIZE FOR
			;  DRIVER AND BUFFER.
	OCTOBI=4	;OCTAL TO BINARY CODE
	DETOBI=2	;DECIMAL TO BINARY CODE
	RATOBI=0	;RADIX50 TO BINARY CODE
	DOTBLK=127400	;RADIX50 FOR ".  "
	BLANKS=0	;RADIX50 FOR "   "
	INC=256.
	ERR10=1444	;F044-ERROR IN FORTRAN COMMAND STRING
;THIS SOURCE OF THE LINKER CAN BE
;ASSEMBLED INTO TWO UNIQUE VERSIONS:
;1.  IF THE SYMBOL "NOSEG" IS DEFINED, THE
;    RESULTING OBJECT MODULE IS THE FULL
;    LINKER.
;    *************************************
;2.  IF THE SYMBOL "NOSEG" IS NOT DEFINED,
;    THE RESULTING PACKAGE IS A LINKER
;    THAT UTILIZES CORE OVERLAYS FROM THE SYSTEM
;    DEVICE TO CONSERVE ON SYMBOL TABLE SPACE.
;
;	THIS VERSION OF THE LINKER
;	UTILIZES CORE OVERLAYS FROM THE SYSTEM
;	DEVICE TO CONSERVE ON SYMBOL TABLE SPACE.
;
;THE OVERLAY VERSION OF THE LINKER IS SELF CONTAINED
;IN THAT IT IS ITS OWN OVERLAY BUILDER.
;
;WHEN THE SYMBOL "OVRBLD" IS DEFINED, THE
;RESULTING OBJECT MODULE IS THE BUILDER.
;
;WHEN THE SYMBOL "OVRBLD" IS NOT DEFINED, THE
;RESULTING OBJECT MODULE IS THE RESIDENT LINKER.
;
;WHEN LINKED, THE BUILDER'S TOP SHOULD BE XXX460.
;EXECUTING THE BUILDER'S LOAD MODULE
;VIA THE MONITOR COMMAND RUN
;CAUSES THE CREATION OF THE
;CONTIGUOUS FILE OF OVERLAYS
;(LINK11.OVR) ON THE SYSTEM DEVICE WITH LOGIN UIC.
;
;WHEN LINKED, THE RESIDENT LINKER'S TOP SHOULD ALSO BE XXX460.
;AT RUN TIME, THE RESIDENT LINKER
;REQUIRES THE OVERLAYS TO BE ON THE SYSTEM DEVICE
;WITH FILE NAME LINK11.OVR AND LOGIN OR [1,1]UIC.
;
	.CSECT
	.IFDF	NOSEG
OVRBLD=1			;PORTIONS OF
L1=0				;BUILD SECTION
L2=0				;ARE NEEDED.
L3=0				;SET ALL SYMBOLS
L4=0
L5=0				;USED IN ADJUSTING
L6=0
L7=0				;ADDRESSES TO WORK
L8=0
L9=0				;IN OVERLAY
BEGO01=0			;ENVIRONMENT
BEGO02=0			;TO 0.
BEGO03=0
BEGO04=0
BEGO05=0
BEGO06=0
BEGO07=0
BEGO08=0
BEGO09=0
BEGOVR=0
	.ENDC
;
;*****OVERLAY PROCEDURES*****
;
;THE NUMBER OF BYTES ALLOCATED FOR THE
;OVERLAY AREA
OVRSIZ=2000	;1024 DECIMAL BYTES
;THE NUMBER OF WORDS ALLOCATED FOR THE
;OVERLAY AREA
OVRWRD=1000	;512 DECIMAL WORDS
;
;IF THE SYMBOL "OVRBLD" IS DEFINED (VIA A
;PARAMETER ASSIGNMENT) THE RESULTING OBJECT
;MODULE WILL CONSIST OF:
;		OVERLAY BUILDER
;		OVERLAY #1
;		OVERLAY #2
;		.
;		.
;		.
;		OVERLAY #N
;		OVERLAY AREA
;		RESIDENT LINK-11
;
;THE RUN TIME TRANSFER ADDRESS WILL BE
;"STARTB" IN THE OVERLAY BUILDER
;
;IF THE SYMBOL "OVRBLD" IS NOT DEFINED
;THE RESULTING OBJECT MODULE WILL
;CONSIST OF:
;		OVERLAY AREA
;		RESIDENT LINK-11
;
;THE RUN TIME TRANSFER ADDRESS WILL
;BE "LNK" IN RESIDENT LINK-11
;
;
;
;PARAMETER ASSIGNMENTS
WTCMD=1				;.WAIT
OPN=16				;.OPEN
DLT=21				;.DELETE
RLS=7				;.RELEASE
R6=%6				;REGISTER 6
R7=%7				;REGISTER 7
ERR9=1640			;NOT ENOUGH ROOM AT BUILD TIME
				;TO ALLOCATE CONTIGUOUS FILE
ERR8=2207			;EOD OR DEVICE ERROR ON OUTPUT
				;.TRAN OR DEVICE ERROR ON
				;INPUT .TRAN
;
;
;IF IN RSX PROCESS RTH ALWAYS
;
	.IFDF	RSX
	RTH=1
	.ENDC
	.IFDF	OVRBLD
	.IFNDF	NOSEG
	.TITLE	LINKOB
;
;THE FOLLOWING TABLE CONTAINS THE
;STARTING CORE ADDRESS OF EACH OVERLAY
;IN THE ORDER OF ASCENDING LOCATIONS.
;A 0 WORD TERMINATES THE ENTRIES.
;AS NEW OVERLAYS ARE CREATED THEIR
;POINTERS MUST BE ADDED TO THE END
;OF THE TABLE AND THE OVERLAY ITSELF
;PUT IN THE SAME POSITION
;RELATIVE TO THE OTHER OVERLAYS.
;
OVRTAB:	.WORD	BEGO01		;OVERLAY #1
	.WORD	BEGO02		;OVERLAY #2
	.WORD	BEGO03		;OVERLAY #3
	.WORD	BEGO04		;OVERLAY #4
	.WORD	BEGO05		;OVERLAY #5
	.WORD	BEGO06		;OVERLAY #6
	.WORD	BEGO07		;OVERLAY #7
	.WORD	BEGO08		;OVERLAY #8
	.WORD	BEGO09		;OVERLAY #9
	.WORD	0
;
;OVERLAY DEVICE OUTPUT TRAN BLOCK
;
OVRTBO:	.WORD	0		;DEVICE BLOCK NUMBER
OVROSA:	.WORD	0		;MEMORY START ADDRESS
	.WORD	OVRWRD		;WORD COUNT
OVRERR:	.WORD	2		;FUNCTION (WRITE)
	.WORD	0		;NUMBER OF WORDS NOT TRAN'D.
;RESTART ADDRESS OF OVERLAY BUILDER---
;RELEASE OVERLAY DEVICE IF STILL INIT'D.
AGAIN:	TST	OVRLB		;IS DATA SET INIT'D
	BEQ	STARTB		;NO
	.RLSE	#OVRLB		;YES-RELEASE IT
;
;STARTING ADDRESS OF OVERLAY BUILDER
STARTB:	MOV	#OVRTAB,R6	;INITIALIZE THE STACK
	START=STARTB		;SET UP TRANSFER ADRESS
	;SET UP RESTART ADDRESS
	.RSTRT	#AGAIN
;
;USE THE COMMAND STRING INTERPRETER (CSI)
;TO DETERMINE THE SYSTEM DEVICE AND
;UNIT OF THIS SYSTEM.
;
	MOV	#ONCE,R0	;ADDRESS OF ONCE ONLY FLAG.
	TSTB	(R0)+		;BRANCH IF ALREADY
	BEQ	OVER		;DONE ONCE.
;THE FLAG AT ONCE IS CLEARED BY CSI
;DUE TO ITS PROXIMITY TO OVRFB.
;R0 NOW POINTS TO OVRBLK.
	.CSI1	@R0		;ADDRESS OF CMDBUF
;THE LINE IS SYNTACTICALLY ACCEPTABLE, THUS
;THE RETURN FLAG ON TOP OF STACK IS IGNORED.
	MOV	R0,@R6		;ADDRESS OF OVRBLK
	EMT	57		;CSI2
	TST	(R6)+		;CORRECT STACK
OVER:
	MOV	#OVRLB,R1	;LINK BLOCK
	CLR	@R1		;FOR ^C BEGIN
	MOV	#OVRFB,R2	;FILE BLOCK
	MOV	#OVRTBO,R3	;OUTPUT TRAN BLOCK
;.INIT OVERLAY DEVICE
	.INIT	R1
;OBTAIN DEVICE STATUS
	.STAT	R1
	CMP	(R6)+,(R6)+	;CORRECT STACK.
				;PHYSICAL BLOCK SIZE
	MOV	@R6,R4		;(IN WORDS) OF OVERLAY DEVICE
	MOV	#OVRWRD,-(R6)
	JSR	R7,DIVIDE
	MOV	(R6)+,R5	;NUMBER OF PHYSICAL
				;BLOCKS PER OVERLAY
	CLR	-(R6)
	MOV	#OVRTAB,R0
BLDR01:	TST	(R0)+		;TOP OF STACK
	BEQ	BLDR02		;CONTAINS TOTAL
	ADD	R5,@R6		;NUMBER OF PHYSICAL
	BR	BLDR01		;BLOCKS REQUIRED.
BLDR02:	MOV	#64.,-(R6)	;DIVIDE PHYSICAL BLOCK
	MOV	R4,-(R6)	;SIZE BY 64 (DECIMAL)
	JSR	R7,DIVIDE	;QUOTIENT ON STACK.
	MOV	(R6)+,R0	;NUMBER OF 64'S IN
				;PHYSICAL BLOCK
	MOV	@R6,R4		;TOTAL NUMBER OF
				;PHYSICAL BLOCKS REQUIRED

BLDR03:	DEC	R0
	BEQ	BLDR08		;TOTAL NUMBER OF
	ADD	R4,@R6		;64 (DECIMAL) WORD BLOCKS
	BR	BLDR03		;REQUIRED ON TOP OF
				;STACK
;DELETE FILE IF ALREADY EXISTING
BLDR08:	MOV	#BLDR04,-4(R2)	;ERROR RETURN
	.DELET	R1,R2
BLDR04:	CLR	-4(R2)		;ERRORS TO MONITOR
;ALLOCATE THE NECESSARY SPACE FOR ONE
;CONTIGUOUS FILE.
	MOV	R2,-(R6)	;FILE BLOCK
	MOV	R1,-(R6)	;LINK BLOCK
	EMT	15
	TST	(R6)+
	BLT	BLDR09		;SPACE AVAILABLE?
	CLR	-(R6)		;NO.
	MOV	#ERR9,-(R6)	;FATAL ERROR.
	BR	BLDR10
;
;DETERMINE THE PHYSICAL STARTING BLOCK
;OF THE CONTIGUOUS FILE AND PLACE IT
;IN THE 1ST WORD OF THE OUTPUT TRAN BLOCK.
BLDR09:	.LOOK	R1,R2,1
	MOV	(R6)+,@R3	;STARTING BLOCK.
	CMP	(R6)+,(R6)+	;CORRECT STACK
;THE ONE CONTIGUOUS FILE WILL CONTAIN
;N OVERLAYS WITH EACH BEGINNING AT THE
;START OF A PHYSICAL BLOCK ON THE DEVICE
;
	MOV	#OVRTAB,R0
BLDR07:	MOV	(R0)+,OVROSA	;MEMORY START ADDRESS
	BEQ	BLDR05
;TRAN OUT AN OVERLAY.
;
	.TRAN	R1,R3
;WAIT FOR COMPLETION OF TRANSFER
;
	.WAIT	R1
;CHECK FOR ERROR ON TRANSFER
;
	BIT	#140000,OVRERR
	BEQ	BLDR06
;ERROR ON TRANSFER
	MOV	OVRERR,-(R6)	;PUSH STATUS BYTE
	BIC	#377,@R6	;INTO LOW INFO BYTE
	SWAB	@R6		;AND CLEAR THE REST.
	MOV	#ERR8,-(R6)	;ERROR CODE

BLDR10:	IOT
	.EXIT			;RETURN TO MONITOR
BLDR06:	ADD	R5,@R3		;CHANGE BLOCK NUMBER
				;IN TRAN BLOCK FOR
	BR	BLDR07		;NEXT OVERLAY TRANSFER
;
;ALL OVERLAYS HAVE BEEN TRAN'D OUT.
;
BLDR05:	.RLSE	R1
;
;RETURN TO THE MONITOR
	.EXIT
;*****OVERLAYS BEGIN HERE*****
;
;	OVERLAY #1
L1=BEGOVR-BEGO01		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO01:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
;
	JMP	START1		;ENTRY1
	.ENDC
;
;	CREATE COMD
;
;	INIT THE OUTPUT DATA SET TO HSP.
;
;
;	INITIALIZE LOAD MODULE DATA SET
;
START1:	TST	LODDEV+6-L1	;ANY LOAD MOD OUTPUT?
	BEQ	LINK24		;NO--
;	INIT OUTPUT DATA SET, DELETE OUTPUT FILE
;	OPEN OUTPUT FILE
	MOV	#OPLOD-BEGO01+BEGOVR,LODADR-4-L1	;SET UP ERROR RETURN
	.INIT	#LODDEV		;INIT THE DATA SET
	TST	LODADR+4-L1
	BNE	.+10
	MOV	#0,LODADR+4-L1
	.=.-4
	.RAD50	/LDA/
	.=.+2
	.DELET	#LODDEV,#LODADR
;	IF THE FILE ALREADY EXISTED IT WAS
;	DELETED AND CONTROL WAS RETURNED
;	NORMALLY.
;	IF THE FILE DID NOT EXIST, THE ERROR
;	RETURN "OPLOD" WAS TAKEN.
;
;	OPEN LOAD MODULE FILE
;
OPLOD:	CLR	LODADR-4-L1	;NOW LET MON HANDLE ERRORS
	INCB	LODOPF-L1	;INDICATE LOAD MODULE OPENED
	TST	LODADR+4-L1
	BNE	.+10
	MOV	#0,LODADR+4-L1	;SET DEFAULT EXTENSION
	.=.-4
	.RAD50	/LDA/
	.=.+2
	.OPEN	#LODDEV,#LODADR
;	INIT OUTPUT
;
LINK24:	IOOI			;SETS R0,R1 TO PROPER BUFFER
;
;	SET UP THE BUFFER AND DUMP IT.  USE R0,R1 AS POINTERS.
;
	MOV	#COMDSZ,(R0)	;SET BC
;	SET COMD LOAD ADDRESS
	MOV	LOWADR-L1,-(SP)	;ASSUME LOWADR IS OK.
	CMP	PRSIZE-L1,#COMDSZ	;IS PROGRAM SMALLER THAN COMD?
	BHIS	LINK15		;NO - USE LOWADR
	CLR	(SP)		;ASSUME 0 AS LOAD ADDRESS.
	CMP	TOPMEM-L1,#COMDSZ	;IS TOP TOO LOW?
	BLO	LINK15		;YES - USE 0 AS LOAD ADDRESS
	MOV	TOPMEM-L1,(SP)	;YES - PUT COMD UP AGAINST TOP.
	SUB	#COMDSZ,(SP)	;CALCULATE CORRECT ADDRESS.
LINK15:	MOV	(SP)+,(R1)+	;SET LOAD ADDRESS FOR COMD.
	MOV	#6001,(R1)+	;SET COMMAND FOR 12. GENERAL WORDS.
	MOV	LOWADR-L1,(R1)+	;SET PROGRAM LOW ADDRESS
	.IFDF	RTH		;BRTH20
	TSTB	RTF-L1		;RTH WITH MODULE?
	BEQ	.+16		;NO-
	SUB	SS-L1,-2(R1)	;YES, LA=LA - STACK SIZE
	SUB	#2,-2(R1)
	.ENDC			;ERTH20
	MOV	PRSIZE-L1,(R1)+	;SET PROGRAM SIZE
	.IFDF	RTH		;BRTH21
	TSTB	RTF-L1		;RTH WITH MODULE?
	BEQ	LNK177		;NO-
	TSTB	NOIOF-L1
	BEQ	.+10
	ADD	RTHSIZ-L1,-2(R1)
	.ENDC			;ERTH21
LNK177:	MOV	TRA-L1,(R1)+	;SET TRA
	MOV	TRADDT-L1,(R1)+	;DDT ADDRESS
	CLR	(R1)+		;NOT LOAD-TIME RELOCATABLE
	MOV	SYMC-L1,R2
	MOV	(R2)+,(R1)+	;SET MODULE NAME
	MOV	(R2)+,(R1)+
	.IFDF	RTH		;BRTH22
	TSTB	RTF-L1
	BEQ	LNK179
	TSTB	NOIOF-L1
	BEQ	LNK178
	TSTB	CSIN-L1		;NAME FROM CSI
	BNE	LNK178		;YES-
	MOV	-4(R1),NAM1-L1	;NO-FILL NAME FROM COMD
	MOV	-2(R1),NAM2-L1
	BR	LNK179
LNK178:	MOV	NAM1-L1,-4(R1)	;NO-FILL NAME FROM COMD
	MOV	NAM2-L1,-2(R1)
LNK179:	CLRB	NOIOF-L1
	.ENDC			;ERTH22
;
;	SET .IDENT
;
	ADD	#BPSYM,R2	;R2 POINTS TO FLAG WORD OF NEXT
				;ENTRY IN SYMBOL TABLE
	CMP	(R2),#3000	;IS .IDENT SPECIFIED?
	BNE	1$		;NO-
	CMP	-(R2),-(R2)	;YES-SET R2 TO .IDENT IN SYMTAB
	MOV	(R2)+,(R1)+	;SET .IDENT
	MOV	(R2)+,(R1)+
	BR	2$
;
;	SET TIME OF DAY WHEN MODULE LINKED
;
1$:	CLR	(R1)+		;CLEAR AREA OF .IDENT IN COMD
	CLR	(R1)+
2$:	MOV	#104,-(SP)
	EMT	41
	MOV	(SP)+,(R1)+	;SET TIME
	MOV	(SP)+,(R1)+
;
;	SET DATE WHEN MODULE LINKED IN JULIAN
;
	MOV	#103,-(SP)
	EMT	41
	MOV	(SP)+,(R1)+	;SET DATE
	MOV	R1,R2
	MOV	#2,(R1)+
	MOV	SSYME-L1,R3
LNK119:	CMP	R3,USYME-L1
	BHIS	LNK120
	CMP	-4(R0),(R0)
	BLE	LNK126
	BIT	#MONCND,FLAGS(R3)
	BEQ	LNK125
	MOV	BASE(R3),(R1)+
	ADD	#INC,(R2)
	ADD	#2,(R0)
	MOV	R3,R4
	SQUISH
	SUB	#BPSYM,USYME-L1
	BR	LNK119
LNK125:	ADD	#BPSYM,R3
	BR	LNK119
LNK126:	IOOP
	TSTB	IOOPER-L1
	BEQ	.+6
LNK160:	JMP	LINK25-L1
	ADD	-4(R0),LOWADR-L1
	MOV	LOWADR-L1,(R1)+
	MOV	R1,R2
	MOV	#2,(R1)+
	MOV	#4,(R0)
	BR	LNK119
LNK120:	MOV	(R0),-(SP)
	ADD	#2,(SP)
	CMP	-4(R0),(SP)+
	BGE	LNK127
	IOOP
	TSTB	IOOPER-L1
	BNE	LNK160
	ADD	-4(R0),LOWADR-L1
	MOV	LOWADR-L1,(R1)+
	ADD	#2,(R0)
LNK127:	ADD	#2,(R0)
	CLR	(R1)+		;END OF COMD
	IOOP			;PUT OUT THE COMD
	TSTB	IOOPER-L1		;CHECK FOR ERROR
	BNE	LNK160		;YES.
	MOV	R0,PUTR0-L1	;SAVE R0
	MOV	R1,PUTR1-L1	;AND R1 FOR NEXT PUT.
	TSTB	FORTRF-L1		;CS FROM FORTRAN?
	BEQ	1$			;NO-
	MOV	BEGCS-L1,CMDBUF-L1	;YES-
	BR	2$
1$:	MOV	LIMIT-L1,CMDBUF-L1	;RESET CSI POINTER
2$:	CMP	SSYME-L1,USYME-L1
	BEQ	.+4
	ERR23
	JMP	LINK73-L1
	.IFNDF	NOSEG
	.EOT
;TAPE 2
ENDO01:
SIZO01=ENDO01-BEGO01
;
;*****OVERLAY #2*****
L2=BEGOVR-BEGO02		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO02:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
;
	JMP	START2		;ENTRY1
	.ENDC
;
;	RESET-CLOSE & RELEASE ALL OPENED FILES & INITED DATA SETS
;
START2:	TST	INCMD-L2		;IS KB INITED?
	BEQ	RESE06		;NO-
	.RLSE	#INCMD		;RELEASE KB
	.RLSE	#OUTCMD		;RELEASE TELEPRINTER
RESE06:	TST	OBJDEV-L2		;IS OBJ DEV INITED?
	BEQ	RESE01		;NO-
	IOIC
RESE01:	MOV	#MAPDEV,R0
	TSTB	MAPOPF-L2		;IS MAP OPEN?
	BEQ	RESE02		;NO-
	.CLOSE	R0		;YES-CLOSE AND RELEASE
RESE02:	TST	@R0		;IS IT INITED?
	BEQ	RESE03		;NO-
	.RLSE	R0
RESE03:	MOV	#LODDEV,R0
	TSTB	LODOPF-L2		;IS LOD DEV OPEN?
	BEQ	RESE04		;NO-
	.CLOSE	R0		;YES-CLOSE AND RELEASE IT
	.DELET	R0,#LODADR	;DELETE LOAD MODULE FILE
RESE04:	TST	@R0		;IS IT INITED?
	BEQ	RESE05		;NO-
	.RLSE	R0		;YES-
RESE05:	TSTB	STBOPF-L2	;IS STB DEV OPEN?
	BEQ	RESE08		;NO-
	.CLOSE	#STBDEV		;YES-CLOSE AND RELEASE
RESE08:	TST	STBDEV-L2
	BEQ	RESE07
	.RLSE	#STBDEV
RESE07:	MOV	#STCLR,R0	;GET START OF AREA TO BE CLEARED
1$:	CLR	(R0)+		;CLEAR IT ALL
	CMP	R0,#ENDCLR	;ONE WORD AT
	BLO	1$		;A TIME
	MOV	EXT-L2,STBDEV+2-L2
	MOV	DEV-L2,STBDEV+6-L2
	MOV	FIL-L2,STBADR-L2
	MOV	NAM-L2,STBADR+2-L2
;
;	INITIALIZE KEYBOARD DATA SET
;
	.INIT	#INCMD
;
;	INITIALIZE TELETYPE DATA SET
;
	.INIT	#OUTCMD
;
	.RSTRT	#LINK		;RESTART
;
;	PRINT NAME
;
	MOV	#LNKNM,R0
	TYPE
;
;	START PASS 1
;
LINK66:
	JMP	LINK80-L2
	.IFNDF	NOSEG

ENDO02:
SIZO02=ENDO02-BEGO02
;
;*****OVERLAY #3*****
L3=BEGOVR-BEGO03		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO03:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
;
	JMP	STRT31		;ENTRY1
	JMP	STRT32		;ENTRY2
	.ENDC
;
; PROCESS OUTPUT SPECIFICATIONS AND SET MONITOR TOP.
;
STRT31:	.MONF
	MOV	(SP)+,MONTOP-L3	;INITIALIZE AT CURRENT SIZE
	MOV	CMDBUF-L3,BLKO-L3
	MOV	#2,@CMDBUF-L3	;PREPARE FOR OUTPUT FIELD
	.CSI2	#BLKO		;GET FIRST OUTPUT FIELD
	.IF NDF	RSX
	MOV	#LODADR,R0	;ADDRESS OF FILE NAME BLOCK
	MOV	#NAME,R1	;ADDRESS OF ASCII STRING STORAGE
	UNPACK			;CONVERT IT TO ASCII
	MOV	#LODADR,R0	;ADDRESS OF FILE NAME
	TST	(R0)+		;IGNORE
	BEQ	1$		;BLANK NAME
	TST	(R0)+
	TST	@R0		;IS THE EXTENSION NULL??
	BNE	1$		;NO
	MOV	#.-.,@R0	;MOVE IN THE PROPER EXTENSION
.=.-2
	.RAD50	/LDA/		;EXTENSION IS LDA
1$:	INC	R1		;SKIP OVER "."
	UNPACK			;UNPACK THE EXTENSION
	MOVB	#' ,R0
	MOVB	R0,-(R1)	;CLEAR
	MOVB	R0,-(R1)	;POTENTIAL
	MOVB	R0,-(R1)	;TRASH
	.ENDC
	TST	LODDEV+6-L3
	BNE	2$
	INCB	NOOUTP-L3
2$:	BIT	#4,(SP)		;BIT2 SET?
	BEQ	3$		;NO-
	INCB	BIT2F-L3	;YES-
3$:	BIT	#2,(SP)		;BIT1 SET?
	BEQ	4$		;NO-
	ERR19			;YES-
4$:	ASR	(SP)+
	BCS	LINK86		;ODD=>NO MAP FOLLOWS
	MOV	CMDBUF-L3,BLKM-L3	; GET MAP FILE
	.CSI2	#BLKM
	TSTB	MAPDEV+6-L3
	BEQ	5$
	INCB	MAPF-L3		;SET MAP FLAG
5$:	BIT	#4,(SP)		;BIT2 SET?
	BEQ	6$		;NO-
	INCB	BIT2F-L3	;YES-
6$:	BIT	#2,(SP)		;BIT1 SET?
	BEQ	7$		;NO-
	ERR19			;YES-
7$:	ASR	(SP)+
	BCS	LINK86
	MOV	CMDBUF-L3,BLKS-L3
	.CSI2	#BLKS
	TST	STBDEV+6-L3	;SYMBOL TABLE TO BE OUTPUT?
	BEQ	8$		;NO-
	INCB	SYMTAB-L3	;YES-
8$:	BIT	#4,(SP)		;BIT2 SET?
	BEQ	9$		;NO-
	INCB	BIT2F-L3	;YES-
9$:	BIT	#2,(SP)		;BIT1 SET?
	BEQ	10$		;NO-
	ERR19			;YES-
10$:	ASR	(SP)+
	BCS	LNK157
	ERR20
LINK86:	TSTB	NOOUTP-L3
	BEQ	.+12
	CLRB	NOOUTP-L3
	INCB	NOONOM-L3
LNK157:	TSTB	NOONOM-L3
	BEQ	.+12
	CLRB	NOONOM-L3
	INCB	NOMMS-L3
	CLR	@CMDBUF-L3
	MOV	CMDBUF-L3,BLKI-L3
	.CSI2	#BLKI
	TST	OBJDEV+6-L3
	BNE	LNK136
	ASR	(SP)+
	BCS	LNK135
	ERR17
LNK135:	TSTB	NOMMS-L3
	BEQ	.+6
	JMP	LNK145-L3
	ERR02
LNK136:	BIT	#4,(SP)		;BIT2 SET?
	BEQ	1$		;NO-
	INCB	BIT2F-L3	;YES-
1$:	BIT	#2,(SP)		;BIT1 SET?
	BEQ	2$		;NO-
	ERR19			;YES-
2$:	TST	LODDEV+6-L3
	BEQ	LINK35
	MOV	#LODADR,R0
	TST	(R0)
	BNE	LINK35
	MOV	#OBJADR,R1
	MOV	(R1)+,(R0)+
	MOV	(R1),(R0)
LINK35:	JMP	LNK128-L3
;
; OBTAIN ADR OF HIGHEST WORD IN CORE
;
STRT32:	.CORE
	MOV	#ALODSZ,-(SP)
	SUB	(SP)+,(SP)
	ADD	#2,(SP)
	MOV	(SP)+,TOPMEM-L3
	JMP	LINK84-L3
	.IFNDF	NOSEG
ENDO03:
SIZO03=ENDO03-BEGO03
;
;*****OVERLAY #4*****
L4=BEGOVR-BEGO04		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO04:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
;
	JMP	LINK13		;ENTRY1
	.ENDC
LINK13:
	.IFDF	RSX
	INCB	FLAG-L4
	MOVTAB
	CLRB	FLAG-L4
	.ENDC
	MOV	SYME-L4,R0	;GET BEGINNING OF UNDEFINES
	MOV	R0,SSYME-L4	;SAVE FOR PMAP
LINK27:	CMP	R0,USYME-L4	;ANY UNDEFINES LEFT?
	BHIS	LNK112		;NO-GO SEE ABOUT MAP.
	.IFNDF	RSX
	CMP	#DOTBLK,NAME2(R0) ;IS 2ND WORD ".  "?
	BEQ	LNK111		;YES-GO CHANGE ".  " INTO "   "
	BIT	#MONCND,FLAGS(R0) ;MONCND FLAG SET?
	BEQ	LNK130		;NO-
	TST	BASE(R0)	;YES-EMT FILLED IN?
	BNE	LNK116		;YES-
	BIC	#MONCND,FLAGS(R0) ;NO-
	MOV	#DOTBLK,NAME2(R0)
	BR	LNK130
	.ENDC
LNK130:	BIC	#ABSREL,FLAGS(R0)	;NO-MAKE ABSOLUTE
	BIS	#UNDEF+INTGLB,FLAGS(R0)	;MAKE DEFINED & GLOBAL
	MOVB	#SYMN,FLAGS+1(R0)	;MAKE IT A SYMBOL DEFINITION
	CLR	VALR(R0)
	CLR	BASE(R0)
LNK116:	ADD	#BPSYM,R0		;UPDATE R0 TO NEXT SYMBOL
	BR	LINK27
	.IFNDF	RSX
LNK111:	MOV	#BLANKS,NAME2(R0) ;CHANGE ".  " INTO "   "
	BIS	#MONCND,FLAGS(R0) ;FLAGS ENTRY: MON ROUTINE CAND
	CLR	BASE(R0)	;CLEAR SPACE OF EMT
	BR	LNK116
	.ENDC
LNK112:
	.IFNDF	RSX
	TSTB	SECTIM-L4
	BNE	LNK131
	INCB	MONLIB-L4	;IN MON LIB SEARCH
	JMP	LINK80-L4	;CHECK FOR ROOM FOR COM ST
LNK131:	CLRB	SECTIM-L4
	.ENDC
;	INITIALIZE FOR PASS 2
	CMP	SYMC-L4,SYME-L4	;ANY SYMBOLS?
	BNE	.+6		;YES
	JMP	LINK-L4		;NO, RESTART!
	MOVB	#1,TMP1-L4		;SET ADDRESS REPEAT FLAG
	MOV	TOPMEM-L4,CURPC-L4	;GET TOP OF MEMORY INTO CURRENT
;	ASSIGN ADDRESSES, CALCULATE TOTAL SIZE, KEEP LOWEST ADDRESS LOADED.
LINK63:	CLR	PRSIZE-L4	;0 TO PROGRAM SIZE
	.IFDF	RTH		;BRTH2
	TSTB	RTF-L4		;RTH?
	BEQ	LNK182		;NO-
	MOV	SS-L4,PRSIZE-L4	;YES-
	ADD	#2,PRSIZE-L4
	TSTB	TMP1-L4
	BEQ	LNK184
	SUB	SS-L4,CURPC-L4
	SUB	#2,CURPC-L4
	BR	LNK182
LNK184:	ADD	SS-L4,CURPC-L4
	ADD	#2,CURPC-L4
	.ENDC			;ERTH2
LNK182:	MOV	SYMC-L4,R0	;SET PTR TO FIRST MODULE NAME.
	MOV	R0,PTRG-L4
	BR	LINK17
LINK16:	ADD	#BPSYM,R0	;MOVE TO NEXT ENTRY
LINK17:	CMP	R0,SYME-L4	;DONE?
	BHIS	LINK18		;YES-GET OUT

	MOVB	FLAGS+1(R0),R1	;GET FLAG TO HIGH BYTE (ENTRY TYPE)
	MOVB	FLAGS(R0),R2	;GET FLAG LOW BYTE
	CMPB	#OBJMN,R1	;OBJ-MODULE NAME?
	BEQ	LINK16		;YES-IGNORE
LNK170:	CMPB	#SYMN,R1	;SYMBOL ENTRY?
	BEQ	LINK19		;YES-GO
	CMPB	#SECTN,R1	;SECTION NAME?
	BEQ	LINK20		;YES-GO
	CMPB	#LOCAL,R1	;LOCAL SECTION NAME?
	BEQ	LINK20		;YES-GO
	BR	LINK16		;IGNORE ALL OTHER THINGS.
;
;	ENTRY POINT
LINK19:	BITB	#ABSREL,R2	;ABS OR REL?
	BEQ	LINK33		;ABS
	MOV	PTSECT-L4,R3
	MOV	BASE(R3),BASE(R0)	;GET SECTION BASE
	ADD	VALR(R0),BASE(R0)	;RELOCATE
	BR	LINK16		;DO NEXT ENTRY
LINK33:	MOV	VALR(R0),BASE(R0) ;SET ABS VALUE
	BR	LINK16
;
;	SECTION NAME
;
LINK20:	BITB	#ABSREL,R2	;ABS OR REL?
	BNE	LINK21		;GO IF REL
	CLR	BASE(R0)	;SET BASE AND
	CLR	VALR(R0)	;SIZE TO 0
	BR	LINK22
LINK21:	MOV	VALR(R0),R3	;GET SECTION SIZE
	MOV	R3,-(SP)	;MAKE SIZE EVEN
	ASR	R3
	MOV	(SP)+,R3
	ADC	R3
	ADD	R3,PRSIZE-L4	;SUM UP FOR TOTAL SIZE
	.IFDF	RTH		;BRTH3
	CMP	RTHPTR-L4,R0	;PROCESSING RTH?
	BHI	.+6		;NO-
	MOV	R3,RTHSIZ-L4	;YES-EXTRACT RTH SIZE FROM SYMTAB
	.ENDC			;ERTH3
	TSTB	TMP1-L4		;IS THIS FIRST TIME?
	BNE	LINK78		;FIRST
	MOV	CURPC-L4,BASE(R0)	;SECOND--SET BASE
	ADD	R3,CURPC-L4	;ADJUST PC
	BR	LINK22
LINK78:	SUB	R3,CURPC-L4	;ADJUST PC BY SIZE.
	MOV	CURPC-L4,BASE(R0)	;SET BASE OF SECTION TO NEW PC.
LINK22:	MOV	R0,PTSECT-L4	;SAVE PTR TO THIS SECTION.
	BR	LINK16		;DO NEXT ONE.
;
LINK18:
;

;	IF BOTTOM SET, CALCULATE NEW TOP AND 
;	ASSIGN ADDRESSES AGAIN.
	TSTB	TMP1-L4
	BEQ	LNK183
	.IFDF	RTH		;BRTH4
	TSTB	NOIOF-L4	;RTH ?
	BEQ	LNK183		;NO-
	ADD	RTHSIZ-L4,PRSIZE-L4	;YES-
	SUB	RTHSIZ-L4,CURPC-L4
	.ENDC			;ERTH4
LNK183:	TSTB	BOTF-L4
	BEQ	LINK77		;NO BOTTOM.
	CLRB	BOTF-L4
	SUB	CURPC-L4,TOPMEM-L4	;CALCULATE NEW TOP AS
	ADD	BOTMEM-L4,TOPMEM-L4	;  TOP-(CURRENT-BOTTOM)
LINK77:	TSTB	TMP1-L4		;DONE TWICE?
	BEQ	LINK64		;YES
	CLRB	TMP1-L4
	MOV	TOPMEM-L4,-(SP)	;CALCULATE LOWADR
	SUB	PRSIZE-L4,(SP)
	MOV	(SP),CURPC-L4
	.IFDF	RTH		;BRTH5
	TSTB	RTF-L4		;RTH?
	BEQ	LNK185		;NO-
	ADD	SS-L4,(SP)	;YES-
	ADD	#2,(SP)
	.ENDC			;ERTH5
LNK185:	MOV	(SP)+,LOWADR-L4
	JMP	LINK63
;	FINALIZE THE TRANSFER ADDRESS
;
LINK64:	CMP	TOPMEM-L4,PRSIZE-L4
	BHIS	.+6
	INCB	BELOW0-L4
	TSTB	TRAF-L4		;IS THERE ONE?
	BNE	LINK60		;YES
	MOV	#1,TRA-L4	;ASSUME 1
	BR	LINK61
LINK60:	TSTB	FTRA-L4		;WAS ONE FORCED?
	BNE	LINK61		;YES-
	TSTB	STRA-L4		;MUST WE SEARCH?
	BEQ	LINK30		;NO-
	MOV	#1,R0		;YES- SEARCH
	MOV	#TRABLK+4,R4
	SRGLOB
	MOV	R0,R4
	MOV	R4,TRA-L4
	BR	LINK61
LINK30:	MOV	#TRABLK,R4
	SRMODN			;SEARCH FOR MODULE NAME
	BR	LINK32		;FOUND
	ERR12			;MODULE NAME MUST BE THERE.
LINK32:	MOV	R4,PTRG-L4	;SET PTRG TO CURRENT NAME.
	MOV	#TRABLK+4,R4
	GETSEC			;SEARCH FOR SECTION NAME.
	ERR13			;MUST BE THERE.
	ADD	BASE(R4),TRA-L4	;CALCULATE TRA
;  FINALIZE DDT TRA
LINK61:	TSTB	SDDTRA-L4	;HAVE WE SEEN ONE?
	BEQ	LINK31		;NO-
	MOV	#DDTTRA,R4	;YES-FIX IT UP
	SRMODN
	BR	.+4
	ERR12
	MOV	R4,PTRG-L4
	MOV	#DDTTRA+4,R4
	GETSEC
	ERR13
	ADD	BASE(R4),TRADDT-L4
LINK31:	MOV	SYMC-L4,PTRG-L4	;SET PTRG
	MOV	TRA-L4,R0	;PRINT MSG--TRA,LOW ADR-L4,ETC
	MOV	#TRAMA,R1
	OTOA
	MOV	LOWADR-L4,R0
	.IFDF	RTH		;BRTH6
	TSTB	RTF-L4		;PROCESSING RTH ?
	BEQ	LNK172		;NO-
	SUB	SS-L4,R0	;YES,LA=LA-SS
	SUB	#2,R0
	.ENDC			;ERTH6
LNK172:	MOV	#TRAMB,R1
	OTOA
	MOV	TOPMEM-L4,R0
	.IFDF	RTH		;BRTH7
	TSTB	NOIOF-L4	;CREATING RTH?
	BEQ	LNK173		;NO-
	MOV	CURPC-L4,R0
	MOV	R0,SLARTH-L4	;SAVE RTH LOAD ADDR
	ADD	RTHSIZ-L4,R0	;YES, HI=HI+RTHSIZE
	.ENDC			;ERTH7
LNK173:	MOV	#TRAMC,R1
	OTOA
	JMP	EXOVL4-L4
	.IFNDF	NOSEG

ENDO04:
SIZO04=ENDO04-BEGO04
;
;*****OVERLAY #5*****
L5=BEGOVR-BEGO05		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO05:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
	JMP	START5		;ENTRY1
	.ENDC
;
;
;	GET GSD (GGSD)
;
;	READ GSD OFF A TAPE AND BUILDS A SYMBOL TABLE.
;
;
START5:	SAVREG			;SAVE REGISTER
	TSTB	LIBF-L5		;TEST LIB FLAG
	BNE	GGSD22		;IN DIR SEARCH
	MOVTAB			;INPUT INIT.  SET R0, R1
	MOV	#INA,IN-L5
	.IFDF	BLKIO
	JSR	PC,@#READIT	;INITIATE READ ON INA
	.ENDC
	.IFNDF	BLKIO
	.READ	#OBJDEV,#INA
	.ENDC
GGSD26:	IOIG
GGSD23:	BITB	#EOF,-1(R0)	;ERROR?
	BNE	GGSDEX		;YES, GET OUT
	CMPB	#STBBLK,(R1)	;IS THIS STB?
	BNE	.+6		;NO-
	JMP	BEGSTB-L5	;YES-GO PROCESS IT.
	CMPB	#GSDBLK,(R1)	;IS THIS GSD?
	BEQ	.+4		;YES, OK
	ERR03			;ERROR IF NOT GSD.
	CMPB	#OBJMN,7(R1)	;IS 1-ST ENTRY OBJ MOD NAME?
	BEQ	.+4		;YES, OK
	ERR04			;ELSE, ERROR.
GGSD01:	BITB	#EOF,-1(R0)	;TEST STATUS FOR ERRORS
	BNE	GGSDEX		;ERROR - EXIT AND IGNORE
	INCB	NSTBF-L5	;CAN'T INPUT CORE LIBS ANY MORE
GGSD02:	MOV	(R1)+,R2	;GET BLOCK TYPE
	SUB	#2,(R0)		;DECREMENT BC
	CMPB	#GSDBLK,R2	;GSD
	BEQ	GGSD03		;YES
	.IFDF	RTH		;BRTH8
	TSTB	RTF-L5		;PROCESSING RTH?
	BEQ	GGSD29		;NO-
	CMPB	#TXTBLK,R2	;YES - TEXT?
	BNE	GGSD04		;NO - GET ANOTHER BLOCK
	TSTB	CSISS-L5	;YES - SS FROM CSI?
	BNE	GGSDEX		;YES-
	MOV	22(R1),SS-L5	;NO - EXTRACT SS FROM O.M.
	MOV	SS-L5,-(SP)	;ODD STACK SIZE
	ASR	(SP)+
	BCC	EVEN		;EVEN
	INC	SS-L5		;ODD, MAKE EVEN
EVEN:	TSTB	CSIN-L5		;NAME FROM CSI?
	BNE	GGSDEX		;NO -
	MOV	40(R1),NAM2-L5	;YES - EXTRACT NAME FROM O.B.
	MOV	42(R1),NAM1-L5
	BR	GGSDEX		;GET OUT.
	.ENDC			;ERTH8
GGSD29:	TSTB	LIBF-L5
	BNE	GGSD30
	MOVB	TAPES-L5,-(SP)
	BISB	CONCAT-L5,(SP)+
	BNE	GGSD04		;IGNORE GSDEND IF EITHER
				;  TAPES OR CONCAT ON.
GGSD30:	CMPB	#GSDEND,R2	;GSD END
	BNE	GGSD04		;NO
GGSDEX:	RESREG			;YES - EXIT
	TSTB	LIBF-L5		;TEST LIB FLAG
	BNE	GGSDE1		;IN DIR SEARCH
	IOIC			;CLOSE OBJECT MODULE FILE
GGSDE1:	RTS	PC
GGSD22:	TSTB	SBBF-L5		;MATCH IN 2ND LINE?
	BNE	GGSD24		;YES - FIX UP "IN"
	IOIG			;NO - GET NEXT BLOCK
	BR	GGSD23
GGSD24:	CMP	#2,CNT-L5
	BNE	GGSD04
	MOV	IN-L5,R0
	CMP	(R0)+,(R0)+
	MOV	R0,R1
	TST	(R1)+
	DEC	CNT-L5
	BR	GGSD23
GGSD04:	CMP	#1,CNT-L5
	BNE	GGSD25
	MOV	INSAVE-L5,IN-L5
	CLR	CNT-L5
	CLRB	SBBF-L5
GGSD25:	IOIG
	BR	GGSD01
GGSD03:	SUB	#8.,(R0)	;ANY ENTRY LEFT?
	BLT	GGSD04		;NO - GO GET ANOTHER BLOCK
	MOV	R1,R4		;SET R4 TO THE ENTRY
	ADD	#8.,R1		;MOVE R1 TO NEXT ENTRY.
	MOVB	FLAGS+1(R4),R2	;GET ENTRY TYPE
	CMP	R2,#GSDMAX
	BLE	.+4
	ERR14
	ASL	R2
	JMP	@GGSD05-BEGO05+BEGOVR(R2)	;DISPATCH
GGSD05:	+GGSD06-BEGO05+BEGOVR	;MODULE NAME
	+GGSD07-BEGO05+BEGOVR	;SECTION NAME
	+GGSD03-BEGO05+BEGOVR	;ISD SIZE (IGNORE)
	+GGSD08-BEGO05+BEGOVR	;TRA SPECIFICATION
	+GGSD09-BEGO05+BEGOVR	;SYMBOL
	+GGSD07-BEGO05+BEGOVR	;LOCAL SECTION NAME
	+GGSD32-BEGO05+BEGOVR	;IDENT DIRECTIVE
;
;	MODULE NAME
;
GGSD06:	CLRB	SAMECS-L5
	MOV	R4,R2		;SAVE R4
	SRMODN			;CHECK IF MODULE NAME IS UNIQUE
	BR	GGSD10		;ERROR IF NOT UNIQUE
GGSD31:	MOV	R2,R4
	MOV	SYME-L5,PTRG-L5	;SET PTR TO MODULE NAME
	INSYME			;INSERT AT SYME + UPDATE PTRS
	BR	GGSD03		;DO NEXT ENTRY
GGSD10:	CMP	(R2),MAIN1-L5	;MODULE NAME NOT UNIQUE
	BNE	ASBEF1		;MODULE NAME MAIN.?
	CMP	2(R2),MAIN2-L5
	BNE	ASBEF1		;NO-
	CMP	SYMB-L5,SYMC-L5	;YES - PROCESSING CORE LIBS?
	BEQ	ASBEF1		;NO-
	TSTB	MAINF-L5	;YES - WAS ONE MAIN. SEEN ALREADY?
	BNE	PREPAR		;YES - PRINT ERROR AND ABORT OBJ MOD.
	INCB	MAINF-L5	;NO - MARK FIRST MAIN. WAS SEEN.
	BR	GGSD31		;AND DON'T PRINT ERROR AND CONTINUE
				;PROCESSING OBJECT MODULE.
PREPAR:	CLRB	MAINF-L5
	BR	ASBEF3
ASBEF1:	CMP	(R2),DATA1-L5	;MODULE NAME DATA.?
	BNE	ASBEF3
	CMP	2(R2),DATA2-L5
	BNE	ASBEF3
	CMP	SYMB-L5,SYMC-L5	;PROCESSING CORE LIBS?
	BEQ	ASBEF3
	TSTB	DATAF-L5	;WAS 1 DATA. SEEN ALREADY?
	BNE	1$
	INCB	DATAF-L5
	MOV	R4,-(SP)
	MOV	R2,R4
	SRMODN
	BR	.+4
	ERR25
	MOV	#126423,(R4)
	MOV	(SP)+,R4
	BR	GGSD31
1$:	CLRB	DATAF-L5
ASBEF3:	ERR05			;ERROR-MODULE NAME NOT UNIQUE
	TSTB	CONCAT-L5
	BEQ	GGSD27
GGSD28:	IOIG
	BITB	#EOF,-1(R0)
	BNE	GGSDEX
	CMPB	#MODEND,(R1)
	BEQ	.+4
	BR	GGSD28
	JMP	GGSD26
GGSD27:	JMP	GGSDEX
;
;	SECTION NAME
;
GGSD07:	MOV	R4,R2		;GIND THE GLOBAL + GET
	PTGLOB			;PTR (R4) TO IT.
	BR	GGSD11		;NOT FOUND, GO INSERT IT.
	BITB	#UNDEF,FLAGS(R4) ;IS IT DEFINED
	BNE	GGSD12		;YES
	SQUISH			;NO - REMOVE THE UNDEFINED SYMBOL
	SUB	#BPSYM,USYME-L5
GGSD11:	MOV	R2,R4		;INSERT AT SYME-L5 AND UPDATE PTRS.
	MOV	SYME-L5,PTRH-L5
	INSYME
	BR	GGSD14
GGSD12:	CMPB	FLAGS+1(R4),#SECTN ;IS IT A SECTION NAME?
	BEQ	GGSD33
	CMPB	FLAGS+1(R4),#LOCAL	;LOCAL SECTION NAME?
	BNE	GGSD13		;NO - ERROR - MULT DEFINITION.
GGSD33:	TSTB	SCOUNT-L5	;READ AT LEAST 1 SYMTAB?
	BEQ	LNK163		;NO-
	TSTB	NSTBF-L5	;YES-FINISHED READING SYMTABS?
	BEQ	LNK163		;NO-
	INCB	SAMECS-L5	;YES-SET FLAG TO AID IN
				;CHECKING FOR EXTRA ENTRIES
LNK163:	CMPB	FLAGS+1(R4),#LOCAL
	BEQ	GGSD11
	MOV	R4,PTRH-L5
	CMP	VALR(R4),VALR(R2) ;WHICH SIZE IS BIGGEST
	BHIS	GGSD14
	TSTB	SAMECS-L5
	BEQ	.+8.
	CMP	R4,SYMC-L5
	BLO	.+10.
	MOV	VALR(R2),VALR(R4) ;GET BIGGEST SIZE.
	BR	GGSD14
	ERR26			;W323,CSECT SIZE TOO LARGE
LNK193:	BR	GGSD14		;GO DO NEXT ENTRY

;
;	TRA SPECIFICATION
;
GGSD08:	TSTB	DDTF-L5		;IS THIS THE DEBUG FILE?
	BEQ	GGSD20		;NO-
	INCB	SDDTRA-L5
	MOV	#DDTTRA,R2
	BR	GGSD21
GGSD20:	TSTB	UTRA-L5		;SHOULD WE USE THIS ONE?
	BEQ	GGSD18
	CLRB	UTRA-L5
	INCB	TRAF-L5
	BR	GGSD19
GGSD18:	TSTB	TRAF-L5		;IS THERE ONE ALREADY?
	BNE	GGSD14		;YES, GET OUT
GGSD19:	MOV	#TRABLK,R2
;	GET CURRENT OBJ MODULE NAME
GGSD21:	MOV	PTRG-L5,R3
	MOV	(R3)+,(R2)+
	MOV	(R3),(R2)+
;	GET TRA SPEC
	MOV	(R4)+,(R2)+	;SECTION NAME
	MOV	(R4)+,(R2)+
	TST	(R4)+		;SKIP FLAGS
	MOV	(R4)+,(R2)+	;CONSTANT
	MOVB	DDTF-L5,-(SP)	;IS THIS THE DDT TRA?
	CLRB	DDTF-L5
	TSTB	(SP)+
	BNE	GGSD14		;YES-DO NOT TEST FOR ODD VALUE
	BIT	#1,-(R2)	;IS IT ODD
	BNE	GGSD14		;YES - IGNORE
	INCB	TRAF-L5		;NO - SET FLAG
GGSD14:	JMP	GGSD03

;
;	SYMBOL DEFINITION
;

GGSD09:	MOV	R4,R2		;SAVE R4
	BITB	#UNDEF,FLAGS(R2) ;REF OR DEF?
	BEQ	GGSD15		;REF
	PTGLOB			;SEARCH FOR IT AND SET R4
	BR	GGSD16		;NOT FOUND
	BITB	#UNDEF,FLAGS(R4) ;FOUND, IS IT DEFINED
	BNE	GGSD13		;YES - ERROR
	SQUISH
	SUB	#BPSYM,USYME-L5
GGSD16:	TSTB	SAMECS-L5
	BEQ	.+8.
	CMP	PTRH-L5,SYMC-L5
	BLO	.+8.
	MOV	R2,R4
	INPTRH
	BR	GGSD14
	ERR06			;W342,TOO MANY ENTRIES IN CSECT
	BR	GGSD14
;
;	MULTIPLY DEFINED SYMBOL--BROADCAST IT
;
GGSD13:	MOV	R0,CONVER-L5	;SAVE R0,R1
	MOV	PTRG-L5,R0	;MOVE ADR OF MOD NAME TO R0
	CMP	(R0),MAIN1-L5	;IS IT MAIN.?
	BNE	ASBEF2		;NO-
	CMP	2(R0),MAIN2-L5
	BNE	ASBEF2		;NO-
	CMP	SYMB-L5,SYMC-L5	;YES - PROCESSING CORE LIBS?
	BEQ	ASBEF2		;NO-
	CMP	(R4),MAIN1-L5	;YES - IS GLOBAL MAIN.?
	BNE	ASBEF2		;NO-
	CMP	2(R4),MAIN2-L5
	BNE	ASBEF2		;NO-
	CMP	MAINF-L5,#1	;1ST MAIN. GLOBL?
	BNE	ASBEF2		;NO-
	INCB	MAINF-L5	;YES-MARK IT: MAINF=2
	MOV	#126423,(R4)	;GLOB NAME IN COR LIB STB =$$$N.
	MOV	R0,R4
	SRMODN
	BR	.+4
	ERR25
	MOV	#126423,(R4)	;MOD NAME IN COR LIB STB =$$$N.
	MOV	CONVER-L5,R0
	BR	GGSD16		;INSERT MAIN. GLOBAL INTO SYM TAB
	BR	NOMES		;YES - DON'T PRINT MESSAGE.

ASBEF2:	MOV	R1,-(SP)
	MOV	#MULMSA,R1	;ADR OF ASCII CHAR
	MOV	R4,R0		;ADR OF MOD40#
	UNPACK
	MOV	#MULMSB,R1	;MODULE NAME
	MOV	PTRG-L5,R0

	UNPACK
	MOV	(SP)+,R1	;RESTORE R1.
	MOV	#MULMSG,R0

	TYPE
	MOV	#1302,R0	;CODE=W302

	CLR	-(SP)
	MOV	R0,-(SP)
	IOT
NOMES:	MOV	CONVER-L5,R0
	BR	GGSD14
;
;	REFERENCE TO A GLOBAL
;
GGSD15:	PTGLOB
	BR	GGSD17		;NOT THERE - INSERT IT.
	BR	GGSD14		;IF THERE, IGNORE
GGSD17:	MOV	R2,R4
	INUSYM			;INSERT AS UNDEFINED SYMBOL
	BR	GGSD14
;
;	IDENT DIRECTIVE
;
;	PLACE BLOCK OF .IDENT AFTER THE BLOCK OF THE CORRESPONDING
;	.TITLE IN THE SYMBOL TABLE
;
GGSD32:	SAVREG
	MOV	R4,-(SP)	;SAVE R4 THE POINTER TO ENNTRY
				;IN READ BUFFER
	CMP	PTRG-L5,SYMC-L5	;1ST .IDENT?
	BNE	1$		;NO-
	MOV	(SP),R0		;YES-ADDRESS OF INPUT IN R0
	MOV	#ID,R1		;ADDRESS OF OUTPUT IN R1
	UNPACK
1$:	TSTB	IDF-L5		; .IDENT INTO SYMTAB?
	BEQ	2$		;YES-
	CMP	PTRG-L5,SYMC-L5	;1ST .IDENT?
	BEQ	2$		;YES-
	TST	(SP)+		;NO-POP R4 OFF STACK
	BR	3$
2$:	MOV	PTRG-L5,R4	;YES-OBTAIN POINTER TO CURRENT
				;OBJECT MODULE NAME
	ADD	#BPSYM,R4	;MAKE R4 POINT AFTER IT
	UNSQUISH		;MAKE A HOLE WHERE R4 POINTS
				;NOTE-R4 STILL CONTAINS ADDRESS OF
				;BEGINNING OF HOLE IN SYMBOL TABLE
	MOV	(SP)+,R3	;SET INTO R3 THE POINTER TO THE
				;ENTRY IN READ BUFFER
	MOV	(R3)+,(R4)+	;MOVE BLOCK OF .IDENT
	MOV	(R3)+,(R4)+	;AFTER BLOCK OF .TITLE
	MOV	(R3)+,(R4)+
	MOV	(R3)+,(R4)+
	ADD	#BPSYM,SYME-L5	;UPDATE SYMTAB POINTERS
	ADD	#BPSYM,USYME-L5
3$:	RESREG
	JMP	GGSD03
	.IFNDF	NOSEG
	.EOT
;TAPE 3
ENDO05:
SIZO05=ENDO05-BEGO05
;
;*****OVERLAY #6*****
L6=BEGOVR-BEGO06		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO06:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
;
	JMP	START6		;ENTRY1
	.ENDC
;
;	LIBRARY SEARCHING ROUTINE
;
;	INITIALIZATION
;
;
;	REGISTER ASSIGNMENTS
;
;	EVEN REGISTERS ARE ASSOCIATED WITH A LIBRARY DIRECTORY
;	ODD REGISTERS ARE ASSOCIATED WITH A SYMBOL TABLE.
;	R0	DIRECTORY POINTER
;	R1	SYMBOL TABLE POINTER
;	R2	SIZE OF DIRECTORY SEGMENT
;	R3	SIZE OF SYMBOL TABLE
;	R4	CURRENT DIRECTORY SYMBOL
;	R5	CURRENT UNDEFINED FROM SYMBOL TABLE
;
START6:	MOV	STBC-L6,R3	;GET SYMTAB BC
	BEQ	OUT5		;NO UNDEFINED GLOBALS IN SYMT
	MOV	R3,SVSTBC-L6	;SAVE SYMTAB BC
	MOV	FDATA-L6,R0	;GET PTR TO 1ST DATA ITEM
	MOV	BC-L6,R2	;GET DIR BC
	ADD	#2,R2
	MOV	SYME-L6,R1	;SET UP SYMTAB PTR
	MOV	(R0)+,R4	;GET NEXT DIRECTORY SYMBOL
	MOV	(R1)+,R5	;GET NEXT UNDEFINED IN SYMBOL TABLE
	.IFDF	OLDLUK
	.IFNDF	RSX
	TSTB	MONLIB-L6
	BNE	TSTEND
	.ENDC
	.ENDC
COMP1:	CMP	R4,R5		;COMPARE SYMTAB SYMBOL TO DIRECTORY
				;SYMBOL
	BEQ	MATCH1		;IF SYMBOLS MATCH GO TO 2ND COMP

;
;	MISMATCH
;	ATTEMPT TO INCREMENT INDEX OF SYMBOL TABLE
;
MISM1:	TST	(SP)		;NOOP
TRYINC:	ADD	#12,R3		;INCREMENT SYMBOL TABLE COUNT
	BNE	INCTAB		;IF MORE SYMBOLS IN SYMTAB GO TO
				;INCREMENT INDEX
;
;	REACHED THE END OF THE UNDEFINEDS IN SYMBOL TABLE
;
	.IFNDF	RSX
	TSTB	MONLIB-L6
	BNE	INCMC1
	.ENDC
	ADD	#10,R2		;INCREMENT DIRECTORY COUNT
OUT1:	BR	OUT6
OUT5:	JMP	FINI
	.IFNDF	RSX
INCMC1:
	.IFNDF	OLDLUK
	ADD	#2,R2
	.ENDC
	.IFDF	OLDLUK
	ADD	#16,R2
	.ENDC
	.ENDC
OUT6:	BGE	FINI		;FINISHED IF NO MORE SYMBOLS IN DIRECTORY
;
;	DID NOT REACH THE END OF THE DIRECTORY
;
	.IFNDF	RSX
	TSTB	MONLIB-L6
	BNE	INCE1
	.ENDC
	ADD	#6,R0		;POINT TO NEXT DIR ENTRY
	BR	OUT2
	.IFNDF	RSX
INCE1:
	.IFNDF	OLDLUK
	INC	INDEX-L6	;UPDATE MRT TABLE INDEX
	.ENDC
	.IFDF	OLDLUK
	ADD	#14,R0
	.ENDC
	.ENDC
OUT2:	MOV	(R0)+,R4	;GET NEXT DIRECTORY SYMBOL
;	RESTART UNDEFINEDS IN SYMBOL TABLE
	MOV	SVSTBC-L6,R3	;RESET SYMBOL TABLE SIZE COUNT
	MOV	SYME-L6,R1	;REPOSITION THE POINTER IN R1 TO
				;THE BEGINNING OF THE SYMBOL TABLE
	MOV	(R1)+,R5	;GET NEXT UNDEFINED IN SYMBOL TABLE
	BR	COMP1		;GO TO COMPARE FIRST UNDEFINED
				;IN SYMBOL TABLE
;	INDEX UNDEFINEDS IN SYMBOL TABLE
;
INCTAB:	ADD	#10,R1		;POINT TO NEXT SYMTAB ENTRY
	MOV	(R1)+,R5
	BR	COMP1		;GO TO COMPARE FIRST UNDEFINED
MATCH1:
	.IFNDF	OLDLUK
	TSTB	MONLIB-L6	;1ST PARTS MATCHED
	BEQ	COMP2
	MOV	(R1)+,R5
	TST	R5
	BEQ	MATCH2
	BR	MISM2
	.ENDC
COMP2:	MOV	(R0)+,R4	;PREPARE FOR 2ND MATCHING
	MOV	(R1)+,R5
	CMP	R4,R5
	BEQ	MATCH2		;2ND PARTS MATCHED?
MISM2:				;NO-
MISM3:		
TRYIN2:	ADD	#12,R3		;TRY INCR SYMTAB COUNT
	BNE	INCT2		;SYMTAB ENDED?
	.IFNDF	RSX
	TSTB	MONLIB-L6
	BNE	INCM2
	.ENDC
	ADD	#10,R2		;YES-TRY INCR DIR COUNT
	BR	OUT3
	.IFNDF	RSX
INCM2:
	.IFNDF	OLDLUK
	ADD	#2,R2
	.ENDC
	.IFDF	OLDLUK
	ADD	#16,R2
	.ENDC
	.ENDC
OUT3:	BGE	FINI		;DIR ENDED?
	.IFNDF	RSX
	TSTB	MONLIB-L6
	BNE	INCE2
	.ENDC
	ADD	#4,R0		;NO- GET NEXT DIR ENTRY
	BR	OUT4
	.IFNDF	RSX
INCE2:
	.IFNDF	OLDLUK
	INC	INDEX-L6	;UPDATE MRT TABLE INDEX
	.ENDC
	.IFDF	OLDLUK
	ADD	#12,R0
	.ENDC
	.ENDC
OUT4:	MOV	(R0)+,R4
	MOV	SVSTBC-L6,R3	;RESTART UNDEFINES
	MOV	SYME-L6,R1	;IN SYMTAB
	MOV	(R1)+,R5
	BR	COMP1
INCT2:	ADD	#6,R1		;POINT TO NEXT SYMTAB ENTRY
	MOV	(R1)+,R5	;SYMTAB DID NOT END YET
	TSTB	MONLIB-L6	;MONITOR SEARCH
	BNE	COMP1		;YES, ENTRY IS CORRECT
	CMP	-(R0),-(R0)	;RESTART DIR ENTRY TO 1ST PART
	MOV	(R0)+,R4	;OF SYMBOL PAIR
	BR	COMP1
				;IN SYMBOL TABLE
;
;	SYMBOLS MATCHED
;
MATCH2:
	.IFNDF	RSX
	TSTB	MONLIB-L6
	BNE	MONLT3
	.ENDC
	MOVB	(R0)+,LBYTE-L6
	BITB	#10,LBYTE-L6
	BEQ	INTERM		;UNDEF
	MOVB	(R0)+,HBYTE-L6	;DEFINED
	CMPB	#1,HBYTE-L6	;IS IT A SECTION,OR A SYMBOL?
	BEQ	MATCH3		;MATCHED A SECTION NAME
	CMPB	#4,HBYTE-L6	;MATCHED A SYMBOL
	BEQ	MATCH3
	TST	-(R0)
	BR	MISM3
	.IFNDF	RSX
MONLT3:	BITB	#1,(R1)
	BNE	MONMAT
	BR	MISM3
	.ENDC
INTERM:	TSTB	-(R0)
	BR	MISM3
	.IFNDF	RSX
MONMAT:
	.IFNDF	OLDLUK
	MOV	INDEX-L6,4(R1)
	SUB	#2,4(R1)	;MAKE THE EMT VALUE CORRECT
	.ENDC
	.IFDF	OLDLUK
	CMP	6(R0),4(R1)
	.ENDC
	CMP	-(R1),-(R1)
	BR	INCM2
	.ENDC
MATCH3:	MOV	#1,DIRSRV-L6
	BR	FINI1
	.IFDF	OLDLUK
	.IFNDF	RSX
TSTEND:	TST	R4
	BEQ	FINI
	JMP	COMP1
	.ENDC
	.ENDC
FINI:	MOV	#0,DIRSRV-L6
FINI1:	RTS	PC
	.IFNDF	NOSEG

ENDO06:
SIZO06=ENDO06-BEGO06
;
;*****OVERLAY #7*****
L7=BEGOVR-BEGO07		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO07:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
;
	JMP	START7		;ENTRY1
	JMP	PMAP10		;ENTRY2
	.ENDC

;
;	SUBROUTINE TO PRINT THE LOAD MAP (PMAP)
;
;	OUTPUT TO MAPSL
;	INIT MAPSL TO DEVICE CODE IN MAPDEV
;
;	SET POINTERS TO SYMBOL TABLE
START7:	SAVREG
	MOV	SP,SSP-L7	;SAVE SP
	MOV	SYMB-L7,R2	;BEGINNING OF TABLE
;
;	INITIALIZE MAP OUTPUT DEVICE
;
	MOV	#ERRET3-BEGO07+BEGOVR,MAPADR-4-L7	;SET UP
						;ERROR RETURN
	.INIT	#MAPDEV		;INIT THE DATA SET
	TST	MAPADR+4-L7
	BNE	.+10
	MOV	#0,MAPADR+4-L7
	.=.-4
	.RAD50	/MAP/
	.=.+2
	.DELET	#MAPDEV,#MAPADR
ERRET3:	CLR	MAPADR-4-L7	;NOW LET MONITOR HANDLE ERRORS
	INCB	MAPOPF-L7	;INDICATE MAP OPEN
	TST	MAPADR+4-L7
	BNE	.+10
	MOV	#0,MAPADR+4-L7	;SET DEFAULT EXTENSION
	.=.-4
	.RAD50	/MAP/
	.=.+2
	.OPEN	#MAPDEV,#MAPADR
	.RSTRT	#PMAP14		;SET UP ABORTING ADDRESS
	.IFNDF	RSX
	.DTCVT	#DATE		;GET TODAY'S DATE
	.TMCVT	#TIME		;AND THE TIME
	MOVB	#' ,R0
	MOV	#DATE,R1
	MOVB	R0,-(R1)
	MOVB	R0,-(R1)
	.ENDC
	MOV	#PMAP86,R0	;PRINT HEAD
	MAPTYP
;
;	CLEAR ID
;
	MOV	#100040,-(SP)
	MOV	(SP),ID-L7
	MOV	(SP),ID-L7+2
	MOV	(SP),ID-L7+4
	MOV	(SP)+,ID-L7+6
	.IFDF	RTH		;BRTH9
	TSTB	RTF-L7		;TYPE RTH IN LOAD MAP ?
	BEQ	.+10		;NO-
	MOV	#RTHB,R0
	MAPTYP
	.ENDC			;ERTH9
;	MSG TRAM IS ALREDY FORMATTED
	MOV	#TRAM,R0
	MAPTYP
	MOV	#4,-(SP)	;SET COUNT FLAG TO NON-GLOBAL
	BR	PMAP01		;GO TO PRINT LOOP
;	UPDATE POINTER AND LOOK FOR END OF TABLE.
PMAP02:	ADD	#BPSYM,R2
PMAP01:	CMP	R2,SSYME-L7	;DONE
	BHIS	PMAP09		;YES - GO DO UNDEFINES
	MOVB	FLAGS+1(R2),R3	;NO - GET ENTRY TYPE
	MOV	#PMAP82+6,R1	;ADR OF OUTPUT BUFFER
	CMP	R3,#PMAX
	BLE	.+4
	ERR14
	ASL	R3
	JMP	@SCMDT-BEGO07+BEGOVR(R3) ;DISPATCH
;
;	TEST FOR & LIST UNDEFINES
;
PMAP09:	JSR	PC,FINLIN	;TERMINATE LAST LINE
	TST	(SP)+		;DISCARD COUNT FLAG
	MOV	SSYME-L7,R0	;ANY UNDEFINES?
	CMP	USYME-L7,R0
	BEQ	PMAPX1		;NO - GET OUT
				;YES - PRINT THE HEADING
;
;	PRINT HEADING
;
	MOV	R0,-(SP)
	MOV	#PMAP80,R0	;PRINT SOME STARS
	MAPTYP
	MAPTYP			;MORE STARS
	MOV	#PMAP84,R0	;"UNDEFINED REFS"
	MAPTYP
	MOV	(SP)+,R0
	CLRB	PMAP11-L7
;
;	PRINT VARIABLES, ONE PER LINE.
;
PMAP16:	BIT	#MONCND,FLAGS(R0)
	BEQ	PMAP10
	ADD	#BPSYM,R0
	CMP	R0,USYME-L7
	BLO	PMAP16
	BR	PMAPX1

PMAP10:	MOV	#PMAP82+6,R1
	UNPACK
	MOVB	#CR,(R1)+
	MOVB	#LF,(R1)+
	MOV	#8.,PMAP82+4-L7	;SET BC
	MOV	R0,-(SP)
	MOV	#PMAP82,R0
	TSTB	PMAP11-L7
	BEQ	PMAP12
	TYPE
	BR	PMAP13
PMAP12:	MAPTYP
PMAP13:	MOV	(SP)+,R0
	ADD	#BPSYM,R0	;UPDATE PTR TO NEXT SYMBOL
	CMP	R0,USYME-L7	;DONE?
	BLO	PMAP16		;NO - DO IT AGAIN
;	DONE
PMAPX1:	.RSTRT	#LINK
	RESREG			;RESTORE REGISTERS
;
;	CLOSE MAP FILE
;
	TSTB	PMAP11-L7	;DO NOT CLOSE IF
	BNE	PMAP15		;LISTING UNDEFINES
	CLRB	MAPOPF-L7	;CLEAR MAP DEV OPEN FLAG
	.CLOSE	#MAPDEV
;
;	RELEASE MAP DATA SET
;
	.RLSE	#MAPDEV
PMAP15:	RTS	PC		;EXIT
;	SCMDT--SYMBOL TABLE ENTRY TYPE DISPATCH TABLE.
;	COMMANDS ARE:  OBJ-MOD NAME, PROG-SECT NAME, INT-SYM NAME,
;		      TRA-SPEC, SYMBOL ENTRY
;
SCMDT:	.WORD	PMAP03-BEGO07+BEGOVR
	.WORD	PMAP04-BEGO07+BEGOVR
	.WORD	PMAP05-BEGO07+BEGOVR
	.WORD	PMAP05-BEGO07+BEGOVR
	.WORD	PMAP06-BEGO07+BEGOVR
	.WORD	PMAP04-BEGO07+BEGOVR
;	CNTRL-C RETURN SEEN DURING MAP
;		ABORT IT.
;
PMAP14:	MOV	SSP-L7,SP	;RESTORE SP
	BR	PMAPX1		;GET OUT
;
;	OBJ-MOD NAME
PMAP03:	JSR	PC,FINLIN	;FINISH LAST LINE
	MOV	#PMAP80,R0	;PRINT STARS
	MAPTYP
;MOVE IN "MODULE"
	MOV	#"MO,(R1)+
	MOV	#"DU,(R1)+
	MOV	#"LE,(R1)+
	MOVB	#TAB,(R1)+	;PUT TAB IN BUFFER
	MOV	R2,R0		;R0=ADR OF NAME
	UNPACK			;DO MOD40 UNPACK
;
;	IF .IDENT IS SPECIFIED THEN INSERT .IDENT
;	AFTER THE OBJECT MODULE NAME IN LOAD MAP
;
	ADD	#BPSYM,R2	;ADVANCE POINTER TEMPORARILY
				;TO NEXT ENTRY AFTER NAME
	MOVB	FLAGS+1(R2),HBYTE-L7
	CMPB	HBYTE-L7,#6	;IS NEXT ENTRY .IDENT?
	BNE	1$		;NO-
	MOVB	#TAB,(R1)+	;YES-INSERT .IDENT
	MOV	R2,R0		;R0=ADR OF NAME
	UNPACK
	BR	PMAP07
1$:	SUB	#BPSYM,R2	;RETRACT POINTER TO NAME
PMAP07:	CMP	(SP),#4		;ARE WE IN NON GLOBAL MODE?
	BEQ	3$		;YES, DO NORMAL ENDING
	CMP	(SP),#2		;HAS THE LINE OVERFLOWED?
	BGE	1$		;YES
	INC	(SP)		;ADVANCE COUNT
	MOVB	#TAB,(R1)+
	MOVB	#VT,(R1)+	;STORE VERTICAL TAB
	BR	2$
1$:	CLR	(SP)
3$:	MOVB	#CR,(R1)+	;PUT IN CR
	MOVB	#LF,(R1)+	;   AND LF
2$:	MOV	#PMAP82,R0	;
	SUB	#PMAP82+6,R1	;GET THE BYTE COUNT
	MOV	R1,PMAP82+4-L7	;SAVE IT AWAY
	MAPTYP
;PRINT EXTRA HEADING IF OBJ-MODULE
	CMP	SCMDT-BEGO07+BEGOVR(R3),#PMAP03-BEGO07+BEGOVR
	BNE	11$
	MOV	#PMAP88,R0
	MAPTYP
11$:	JMP	PMAP02		;GO FOR MORE
;
;	PROG-SECTION NAME
;
PMAP04:	JSR	PC,FINLIN	;TERMINATE PREVIOUS LINE IF NECESSARY
	MOVB	#LANG,(R1)+	; MOV IN "<"
	MOV	R2,R0
	UNPACK			;MOD40 UNPACK
	MOVB	#RANG,(R1)+
	CMPB	FLAGS+1(R2),#LOCAL
	BNE	PMAP17
	MOVB	#L,(R1)+
PMAP17:	MOVB	#TAB,(R1)+
	MOV	BASE(R2),R0	;GET BASE VALUE INTO R0
	OTOA			;OCTAL TO ASCII CONVERSION
	MOVB	#TAB,(R1)+	;INSERT A TAB
	MOV	VALR(R2),R0	;GET SIZE
	OTOA			;DO CONVERSION
	BR	PMAP07

;
;	INTERNAL SYMBOLS AND TRA ARE ILLEGAL
PMAP05:	JSR	PC,FINLIN
	ERR07
;
;	ENTRY SYMBOL
;
PMAP06:	CMP	(SP),#4		;NON GLOBAL MODE?
	BNE	1$		;NO
	CLR	(SP)		;YES , CLEAR THE FLAG
1$:	MOVB	#TAB,(R1)+	;INSERT TAB
	MOV	R2,R0
	UNPACK			;MOD40 UNPACK
	MOVB	#TAB,(R1)+
	MOV	BASE(R2),R0
	OTOA			;CONVERT ABSOLUTE VALUE TO ASCII
	BR	PMAP07
;SPECIAL LINE TERMINATOR
FINLIN:	CMP	2(SP),#4	;WAS IT GLOBAL
	BEQ	1$		;YES
	TST	2(SP)
	BEQ	2$
	MOV	#4,2(SP)	;RESET FLAG
	MOV	#2,DUMIN+4-L7
	MOV	#CRLF,DUMIN+6-L7
	MOV	#DUMIN,R0
	MAPTYP
	CLR	DUMIN+4-L7
	CLR	DUMIN+6-L7
1$:	RTS	PC
2$:	MOV	#4,2(SP)
	RTS	PC
;

	.IFNDF	NOSEG
ENDO07:
SIZO07=ENDO07-BEGO07

;
;*****OVERLAY #9*****
L9=BEGOVR-BEGO09		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO09:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY
;
	JMP	DONE		;ENTRY1
	.ENDC
;
;	ALL OBJ MODULES HAVE BEEN READ.  CREATE TRA BLOCK
;	ON THE LOAD MODULE, FOLLOWED BY TRAILER.
DONE:
	.IFDF	RTH		;BRTH10
	TSTB	NOIOF-L9	;CREATE RTH?
	BEQ	NORTH		;NO-
	SAVREG			;YES
	MOV	#38.,@PUTR0-L9
	MOV	#19.,R4
	MOV	PUTR1-L9,R5
ZERRTH:	CLR	(R5)+
	DEC	R4
	BGT	ZERRTH
;
;           FILL IN RTH
;
	TST	-(R5)
	TSTB	CSICN-L9	;CALL NO FROM CSI ?
	BEQ	LNK181		;NO- USE DEFAULT 
	MOV	CN-L9,(R5)	;YES-
	CLRB	CSICN-L9
	BR	LNK189
LNK181:	MOV	LOWADR-L9,(R5)	;USE LOWADR AS DEFAULT CN
LNK189:	MOV	NAM1-L9,-2(R5)	;FILL IN NAME
	MOV	NAM2-L9,-4(R5)
	CLRB	CSIN-L9
	MOV	TRA-L9,-14(R5)	;FILL IN TRA ADR
	MOV	LOWADR-L9,-16(R5)	;PUT LOW LIM OF PROG
	MOV	LOWADR-L9,-(SP)	;PREPARE STACK LIMIT
	SUB	SS-L9,(SP)
	SUB	#2,(SP)
	MOV	(SP)+,-22(R5)	;FILL IN STACK LIMIT
	MOV	PRIOR-L9,-24(R5)	;FILL IN PRIORITY
	MOV	MT-L9,-30(R5)	;FILL IN MAX TIME
	MOV	#FIO1,R4	;SET PTR TO $OTSV INTO R4
	SRGLOB			;SEARCH FOR FORTRAN INP A PTR
	BR	LNK191		;NOT FOUND
	MOV	R4,-42(R5)	;FOUND- FILL IN
LNK191:	MOV	SLARTH-L9,-44(R5) ;FILL IN LOAD ADDRESS FOR RTH
	IOOP
	TSTB	IOOPER-L9
	BEQ	.+6
	JMP	LINK25-L9
	MOV	R0,PUTR0-L9
	MOV	R1,PUTR1-L9
	RESREG
	.ENDC			;ERTH10
NORTH:	MOV	PUTR0-L9,R0	;GET PTR'S TO OUTPUT BUFFER.
	MOV	PUTR1-L9,R1
	MOV	#2,(R0)		;SET BC
	MOV	TRA-L9,(R1)	;SET TRA
	IOOP			;DUMP
	TSTB	IOOPER-L9
	BEQ	.+6
	JMP	LINK25-L9
;
;	CLOSE LOAD MODULE FILE
;
	TST	LODDEV+6-L9	;ANY LOAD MOD OUTPUT?
	BEQ	LINK05		;NO--
	CLRB	LODOPF-L9		;CLEAR LOD DEV OPEN FLAG
	MOV	#LODDEV,-(SP)
	MOV	(SP),-(SP)
	EMT	CLOSE
;
;	RELEASE LOAD MODULE DATA SET
;
	EMT	RELEAS
;
;	CLOSE KEYBOARD FILE
;
LINK05:	MOV	#INCMD,-(SP)
	MOV	(SP),-(SP)
	EMT	CLOSE
;
;	RELEASE KEYBOARD DATA SET
;
	EMT	RELEAS
;
;	CLOSE TELETYPE FILE
;
	MOV	#OUTCMD,-(SP)
	MOV	(SP),-(SP)
	EMT	CLOSE
;
;	RELEASE TELETYPE DATA SET
;
	EMT	RELEASE

	TSTB	OVLC-L9		;LINKING OVERLAYS?
	BLE	1$		;NO-
	TSTB	OVLF-L9		;YES-WHAT SECTION?
	BEQ	3$
	CLRB	OVLF-L9		;RESIDENT-CLEAR FLAG
	MOV	SYMB-L9,SSYMB-L9	;SAVE RESIDENT
;					 SYMBOL TABLE
	MOV	SYME-L9,SASYME-L9	;POINTERS
	MOV	LOWADR-L9,-(SP)	;SAVE RES LOWADR-2,
	MOV	(SP),OVLTOP-L9
	BR	4$
3$:	MOV	OVLTOP-L9,-(SP)	;OVERLAYS
4$:	SUB	#2,(SP)		;THE DEFAULT TOP OF MEM
	MOV	(SP)+,@SASYME-L9	;FOR THE OVERLAYS
1$:	TSTB	GOF-L9		;EXECUTE LOAD MOD?
	BEQ	2$		;NO-
	.IFNDF	NOSEG
	MOV	#OVRLB,-(SP)	;RELEASE OVERLAY DATASET
	EMT	RELEAS
	.ENDC
	MOV	#RUNBLK,-(SP)	;YES-ISSUE GET EMT
	EMT	GET
2$:	JMP	LINK-L9		;RESTART LINKER
	.IFNDF	NOSEG

ENDO09:
SIZO09=ENDO09-BEGO09

	.ENDC
	.ENDC			;END OF OVRBLD
	.IFNDF	NOSEG

	.CSECT
;BEGINNING OF OVERLAY AREA
;THE SIZE OF THE OVERLAY AREA IS DETERMINED
;BY THE SYMBOL "OVRSIZ"
;
BEGOVR:
;THE BEGINNING REGISTERS OF EACH
;OVERLAY CONTAIN JMP'S TO THE
;ENTRY POINTS OF THE OVERLAY

ENTRY1=.
ENTRY2=.+4
ENTRY3=.+10
ENTRY4=.+14
ENTRY5=.+20
ENTRY6=.+24
ENTRY7=.+30
ENTRY8=.+34
ENTRY9=.+40
	.ENDC

	.IFDF	OVRBLD		;B35
	.IFNDF NOSEG
;
;*****OVERLAY #8*****
L8=BEGOVR-BEGO08		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO08:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
;
	JMP	START8		;ENTRY1
	.ENDC
;
;	PROCESSING FOR PASS2
;
START8:	TSTB	LIBF-L8
	BNE	LNK03
	IOII			;INPUT INIT. SET R0,R1 TO BUFFER.
LNK05:	CLR	GENDF-L8	;NO GSD END SEEN.
LINK76:	BITB	#EOF,-1(R0)	;ERROR?
	BEQ	.+6
	JMP	LINK53		;YES,IGNORE INPUT
	CMPB	#GSDBLK,(R1)	;IS THIS A GSD BLOCK
	BEQ	LINK42		;
	ERR03			;ERROR-MODULE MUST START
				;WITH GSD FOR MODULE NAME
LINK42:	CMPB	#OBJMN,7(R1)	;IS THIS THE NAME?
	BEQ	LINK43
	ERR04			;ERROR.
LINK43:	MOV	PTRG-L8,R2		;SET R2 TO NAME IN SYMBOL TABLE
	TST	(R1)+		;ADVANCE POINTER TO MODULE NAME
	CMP	(R2)+,(R1)+	;IS THE NAME OK?
	BNE	LINK44		;NO-ERROR
	CMP	(R2),(R1)	;TRY SECOND WORD.
	BNE	LINK44		;ERROR.
	CLRB	FILEOR-L8
;	START READING THE NON-GSD BLOCKS.
LINK45:	GNGSD			;GET A NON-GSD BLOCK
				;R0 POINTS TO BC.
				;R1 POINTS TO FIRST BYTE OF BUFFER.
	SUB	#2,(R0)		;DECREMENT BC.
	MOV	(R1)+,R2	;GET BLOCK TYPE
	BITB	#EOF,-1(R0)	;INPUT ERROR?
	BNE	LNK169		;YES,TREAT AS MODULE END
	CMP	#TXTBLK,R2	;TXT?
	BEQ	LINK46		;YES.
	CMP	#MODEND,R2	;MODULE END?
	BEQ	LINK47		;YES
	CMP	#GSDEND,R2	;GSD END?
	BNE	.+6
	INC	GENDF-L8
	CMP	#RLDBLK,R2	;RLD?
	BNE	LINK45		;NO-IGNORE ALL OTHER BLOCKS.
	MOVB	#3,T-L8		;SET T SWITCH TO 3.
	CMP	-(SP),-(SP)	;FAKE DOUBLE PUSH.
	JMP	LINK48		;GO PROCESS RLD.
LNK169:	BR	LINK47
;
;	MODULES OUT OF ORDER
;
LINK44:
	.IFDF	BLKIO
	JSR	PC,@#READST	;GET DEVICE STATUS
	.ENDC
	.IFNDF	BLKIO
	.STAT	#OBJDEV
	.ENDC
	TST	(SP)+
	BPL	LNK151
	CMP	(SP)+,(SP)+
	INCB	FILEOR-L8
	TSTB	CONCAT-L8
	BEQ	LNK150
LNK141:	IOIG
	BITB	#EOF,-1(R0)
	BEQ	.+10
	CLRB	FILEOR-L8
	BR	LNK150
	CMPB	#MODEND,(R1)
	BEQ	.+4
	BR	LNK141
	JMP	LINK75
LNK150:	JMP	LINK53
LNK151:	CMP	(SP)+,(SP)+
	MOV	PTRG-L8,R0
	MOV	#ORDRER,R1
	UNPACK
	MOV	#ORDRM,R0
	TYPE
	CLR	-(SP)
	MOV	#406,-(SP)	;CODE=A006
	IOT
	.IFDF	BLKIO
	JSR	PC,@#CLOSRD	;CLOSE AND RELEASE INPUT
	.ENDC
	.IFNDF	BLKIO
	MOV	#OBJDEV,-(SP)	;CLOSE & RELEASE INPUT
	MOV	(SP),-(SP)
	EMT	CLOSE
	EMT	RELEASE
	.ENDC
	BR	START8		;TRY AGAIN
LNK03:	IOIG
	BR	LNK05
;
;	TXT BLK
;
;	MOVE TXT BLOCK TO A SAVE AREA
;
LINK46:	MOV	#TXTSVB,R2	;ADR OF TXT SAVE AREA
	MOV	R2,-(SP)
	MOV	(R0),(R2)	;MOVE IN BC
	SUB	#2,(R2)+
	SUB	#2,(R0)
	MOV	CURPC-L8,(R2)+	;MOVE IN CURRENT PC
	MOV	R2,-(SP)
	TST	(R1)+		;ADVANCE PTR TO 1-ST
				;  DATA WORD.
LINK59:	DEC	(R0)		;DONE?
	BLT	LINK49		;YES
	MOVB	(R1)+,(R2)+	;MOVE IN A BYTE
	BR	LINK59
LINK49:	CLRB	T-L8
	GNGSD			;GET NEXT NON-GSD BLOCK.
	MOV	(R1)+,R2	;GET BLK TYPE.
	SUB	#2,(R0)
	BITB	#EOF,-1(R0)	;ERROR?
	BNE	LINK62		;YES,TREAT AS MODULE END
	CMP	#RLDBLK,R2	;RLD?
	BEQ	LINK48		;YES
	CMP	#TXTBLK,R2	;TXT
	BEQ	LINK50		;YES
	CMP	#GSDEND,R2	;GSD END?
	BNE	.+6
	INC	GENDF-L8
	CMP	#MODEND,R2	;MODULE END
	BNE	LINK49		;NO-IGNORE ALL ELSE
LINK62:	MOVB	#2,T-L8		;TXT FOLLOWED BY MODULE END.
	BR	LINK51
LNK06:	JMP	LNK10-L8
;
;	ADVANCE TO NEXT MODULE (MOVE PTRG IN SYMBOL TABLE).
;
LINK47:	MOV	PTRG-L8,R2		;GET PTRG
	ADD	#5,R2		;SET TO FLAGS OF A SYMBOL.
LINK52:	ADD	#BPSYM,R2	;MOVE TO NEXT ENTRY.
	CMP	R2,SYME-L8		;TOO FAR
	BHIS	LINK53		;YES
	CMPB	(R2),#OBJMN	;IS ENTRY AN OBJ MODULE NAME?
	BNE	LINK52		;NO-TRY NEXT ONE
	SUB	#5,R2		;YES,DO ANOTHER
	MOV	R2,PTRG-L8	;INPUT FILE
	TSTB	LIBF-L8
	BNE	LNK186
	MOVB	TAPES-L8,-(SP)
	BISB	CONCAT-L8,(SP)+
	BNE	LINK75		;IGNORE GENDF-L8 IF TAPES OR 
				;CONCAT IS ON.
LNK186:	TST	GENDF-L8	;SEEN GSD END?
	BEQ	LINK75		;NO, STAY IN SAME FILE
LINK53:	TSTB	LIBF-L8
	BNE	LNK06
LNK152:	IOIC			;CLOSE OBJECT MODULE FILE
				;AND RELEASE ITS DATA SET
				;IN SECOND PASS
	JMP	LINK97-L8		;YES, DO NEXT FILE		
LINK75:	IOIG		;GET NEXT BLOCK
	JMP	LINK76		;   AND PROCESS.
;
;	TXT FOLLOWED BY TXT
;
LINK50:	MOVB	#1,T-L8
;
;	UPDATE CURPC BY SIZE OF LAST TXT BLK
;
	ADD	@2(SP),CURPC-L8	;USES STACKED R0 FOR POINTER TO
				;LAST TXT BLK BC.
	BR	LINK54		;GO OUTPUT LAST TXT BLK.
;
;	TXT FOLLOWED BY RLD
;
LINK48:	JSR	PC,PRLD00	;PROCESS RLD
LINK51:	CMPB	#3,T-L8		;ANY TXT TO OUTPUT?
	BEQ	LINK55		;NO
;
;	OUTPUT TXT
;
LINK54:	MOV	(SP),R3		;PTR'S TO TXT DATA
	MOV	2(SP),R2	;AND TO TXT BC
	MOV	PUTR0-L8,R4	;PTR'S TO OUTPUT BC
	MOV	PUTR1-L8,R5	;AND TO OUTPUT DATA.
	MOV	-2(R3),(R5)+	;GET LOAD ADDRESS
	ADD	#2,(R4)		;UPDATE OUTPUT BC.
LINK56:	MOVB	(R3)+,(R5)+	;MOVE A DATA BYTE
	INC	(R4)		;OUTPUT BC UPDATE.
	DEC	(R2)		;DONE
	BGT	LINK56		;NO-DO ANOTHER.
	MOV	R0,-(SP)
	MOV	R1,-(SP)
	.IFDF	RTH		;BRTH11
	TSTB	RTF-L8		;DOING RTH?
	BEQ	LNK174		;NO-
	CMP	RTHPTR-L8,PTRG-L8 ;RTH NEXT?
	BNE	LNK174		;NO-
	TST	-(R5)		;YES
	MOV	LOWADR-L8,-(SP)	;PREPARE STACK LIMIT
	SUB	SS-L8,(SP)
	SUB	#2,(SP)
	MOV	(SP)+,-22(R5)
	CLRB	CSISS-L8
	TSTB	CSIMT-L8	;MT FROM CSI?
	BEQ	.+14		;NO-
	MOV	MT-L8,-30(R5)	;YES-
	CLRB	CSIMT-L8
	TSTB	CSICN-L8	;CN FROM CSI?
	BEQ	LNK190		;NO-
	MOV	CN-L8,(R5)	;YES-
	CLRB	CSICN-L8
LNK190:	TSTB	CSIP-L8		;PRIOR FROM CSI?
	.EOT
;TAPE 4
	BEQ	.+14		;NO-
	MOV	PRIOR-L8,-24(R5) ;YES
	CLRB	CSIP-L8
	TSTB	CSIN-L8		;NAME FROM CSI?
	BEQ	LNK171		;NO-
	MOV	NAM1-L8,-2(R5)	;YES-
	MOV	NAM2-L8,-4(R5)
	CLRB	CSIN-L8
LNK171:	MOV	TRA-L8,-14(R5)	;FILL IN TRA ADR
	MOV	LOWADR-L8,-16(R5)	;FILL IN LOW LIM OF PROG
	MOV	#FIO1,R4	;SET PTR TO $OTSV INTO R4
	SRGLOB			;SEARCH FOR IT
	BR	LNK174		;NOT FOUND
	MOV	R4,-42(R5)	;FOUND - FILL IN.
	.ENDC			;ERTH11
LNK174:	IOOP			;OUTPUT THE BUFFER
	TSTB	IOOPER-L8		;OUT ERROR?
	BEQ	.+6
	JMP	LINK25-L8
	MOV	R0,PUTR0-L8	;SAVE R0,R1
	MOV	R1,PUTR1-L8	;FOR NEXT OUTPUT
	MOV	(SP)+,R1
	MOV	(SP)+,R0
LINK55:	CMP	(SP)+,(SP)+	;REMOVE THE STACKED R0,R1
	MOVB	T-L8,R2
	CMP	R2,#TMAX	;INDEX OK?
	BLE	.+4		;YES
	ERR14
	ASL	R2
	JMP	@LINK57-BEGO08+BEGOVR(R2)
LINK57:	.WORD	LINK45-BEGO08+BEGOVR
	.WORD	LINK46-BEGO08+BEGOVR
	.WORD	LINK47-BEGO08+BEGOVR
	.WORD	LINK45-BEGO08+BEGOVR



;
;	SUBROUTINE TO PROCESS RLD
;
;	INPUT --
;		R0 PTS TO RLD BC
;		R1 PTS TO BYTE FOLLOWING RLD BLK WORD
;		STACKED R0 AND R1 POINT TO PREVIOUS TXT BLOCK (IF ANY).
;
PRLD00:	TST	(R0)		;DONE WITH RLD?
	BGT	PRLD01		;NO -
	ADD	@4(SP),CURPC	;YES, UPDATE CURRENT PC
PRLDEX:	RTS	PC
;
;	PROCESS NEXT COMMAND
;
PRLD01:	MOVB	(R1)+,R2	;GET CMD
	MOVB	(R1)+,R3	;GET OFFSET INTO TXT
	MOV	R3,OFFSET	;SAVE IT
	SUB	#2,OFFSET
	ADD	2(SP),R3	;ADD PUSHED TXT POINTER TO
	ADD	#-4,R3		;FORM ACTUAL ADDRESS
	MOV	R2,-(SP)	;STACK CMD
	BIC	#177600,R2	;SAVE LOW 7 BITS
	MOV	PTSECT,R5
	CMP	R2,#CMDMAX
	BLE	.+4
PRLD06:	ERR14
	ASL	R2
	JMP	@RCMDT(R2)	;GO EXECUTE PROPER HANDLER
RCMDT:	+PRLD06,CMD1,CMD2,CMD3,CMD4,CMD5,CMD6
	+CMD7,CMD8,CMD9,CMD2,PRLD06,CMD4,CMD5,CMD6
;
;	CMD #1 -- INTERNAL RELOC
;
CMD1:	MOV	(R1)+,R4	;GET REL VALUE
	ADD	BASE(R5),R4	;RELOCATE IT
	TXTPUT
PRLD02:	SUB	#4,(R0)
	BR	PRLD00
;
;	CMD #2 -- GLOBAL RELOC

;
CMD2:	MOV	R1,R4		;SET ADR OF NAME
	CMP	(R1)+,(R1)+
	SRGLOB			;SEARCH FOR GLOBAL NAME
	ERR09		;ERROR
	TXTPUT
PRLD04:	SUB	#6,(R0)
	BR	PRLD00

;
;	CMD #3 -- INTERNAL DISPLACED RELOC
;
CMD3:	GETPC			;GET PC AT CURRENT PLACE.
	NEG	R4
	ADD	(R1)+,R4	;FORM (X - (.+2))
	BR	PRLD02-2
;
;	CMD #4 -- GLOBAL DISPLACED RELOC
;
CMD4:	GETPC			;GET PC NOW
	MOV	R4,TMP1
	MOV	R1,R4
	CMP	(R1)+,(R1)+
	SRGLOB			;GET GLOBAL VALUE
	ERR09		;ERROR
PRLD05:	SUB	TMP1,R4		;FORM (X-(.+2))
	BR	PRLD04-2
;
;	CMD #5 -- GLOBAL ADDITIVE RELOC
;
CMD5:	MOV	R1,R4
	SRGLOB			;GET GLOBAL VALUE
	ERR09		;ERROR
	CMP	(R1)+,(R1)+
	ADD	(R1)+,R4	;ADDITIVE CONSTANT
	SUB	#2,(R0)
	BR	PRLD04-2
;
;	CMD #6 -- GLOBAL ADDITIVE DISPLACED
;
CMD6:	GETPC			;GET PC NOW
	MOV	R4,TMP1
	MOV	R1,R4
	CMP	(R1)+,(R1)+
	SRGLOB
	ERR09		;ERROR
	ADD	(R1)+,R4
	SUB	#2,(R0)
	BR	PRLD05
;
;	CMD #7 -- SET PC
;
CMD7:	MOV	R1,R4
	CMP	(R1)+,(R1)+
	GETSEC			;GET SECTION POINTER
	ERR11		;FATAL ERROR
	MOV	R4,PTSECT	;SET PTSECT
	MOV	R4,R5
	SUB	#4,(R0)
	BR	CMD8
;
;	CMD #8 -- PC MODIFICATION
;
CMD8:	MOV	BASE(R5),R4	;GET SECTION BASE VALUE
	ADD	(R1)+,R4	;MODIFY
	MOV	R4,CURPC
	TST	(SP)+
	SUB	#4,(R0)
;	PC COMMANDS MUST BE LAST IN RLD
	BLE	PRLDEX
;	IF NOT DONE, NEXT COMMAND MUST ALSO BE PC TYPE
	CMPB	#PCMD1,(R1)
	BEQ	PRLD00
	CMPB	#PCMD2,(R1)
	BEQ	PRLD00
;
;	ERROR --- CMD MUST BE PC TYPE.
;
	ERR10		;FATAL ERROR
;
;	CMD #9---SET PROGRAM LIMITS
;
CMD9:	MOV	LOWADR,R4	;SET LOW LIMIT
	MOV	(SP),-(SP)	;GET TWO COPIES OF FLAG
	TXTPUT
	MOV	TOPMEM,R4	;SET HIGH LIMIT

	.IFDF	RTH		;BRTH12
	TSTB	RTF		;RTF AND NOT NOIOF?
	BEQ	.+14
	TSTB	NOIOF		;RTH WAS PREASSEMBLED?
	BNE	.+6		;NO-
	SUB	RTHSIZ,R4	;YES-SUBSTRUCT ITS SIZE
	.ENDC			;ERTH12
	TXTPUT
	SUB	#2,(R0)		;ADJUST BC
	JMP	PRLD00
	.IFNDF	NOSEG
ENDO08:
SIZO08=ENDO08-BEGO08
	.ENDC
	.ENDC			;E35

	.IFNDF NOSEG
	.=BEGOVR+OVRSIZ
;OVERLAY DEVICE LINK BLOCK
;
	.WORD	0		;ERROR RETURN ADDRESS
OVRLB:	.WORD	0		;LINK POINTER (DDB)
	.RAD50	/OVR/		;LOGICAL DATA SET NAME
	.BYTE	1		;DEVICE SPECIFIED
	.BYTE	0		;UNIT NUMBER
	.RAD50	/SY/		;DEVICE NAME
;
;OVERLAY DEVICE FILE BLOCK
;
	.WORD	0		;ERROR RETURN ADDRESS
	.BYTE	13		;HOW OPEN COEE (OPENC)
	.BYTE	0		;ERROR RETURN CODE
OVRFB:	.RAD50	/LIN/		;FILENAME AND EXTENSION
	.RAD50	/K11/		;IN RADIX 50
	.RAD50	/OVR/		;NOTATION
USERID:	.WORD	0		;USER ID CODE
	.BYTE	233		;PROTECT CODE
ONCE:	.BYTE	377		;ONCE ONLY FLAG
;
;CSI BLOCK FOR OVERLAY DEVICE DATA SET
;
OVRBLK:	.WORD	CMDB		;ADDRESS OF CSI BUFFER (7 WORDS)
	.WORD	OVRLB		;ADDRESS OF LINK BLOCK
	.WORD	OVRFB		;ADDRESS OF FILE BLOCK
;
;OVERLAY DEVICE INPUT TRAN BLOCK
;
OVRTBI:	.WORD	0		;DEVICE BLOCK NUMBER
	.WORD	BEGOVR		;MEMORY START ADDRESS
	.WORD	OVRWRD		;WORD COUNT
OVRIER:	.WORD	4		;FUNCTION (READ)
	.WORD	0		;NUMBER OF WORDS NOT TRAN'D

;SUBROUTINE TO DIVIDE THE TOP WORD OF
;THE STACK BY THE NEXT WORD. EXITS
;WITH THE QUOTIENT ON TOP OF THE
;STACK. THE QUOTIENT IS INCREMENTED BY
;ONE IF THERE IS A REMAINDER.
;	CALLING SEQUENCE:
;		MOV	DIVISOR,-(R6)
;		MOV	DIVIDEND,-(R6)
;		JSR	R7,DIVIDE
;		MOV	(R6)+,QUOTIENT
;R0 IS DESTROYED
DIVIDE:	MOV	#1,R0		;QUOTIENT AT LEAST 1

DIVID1:	SUB	4(R6),2(R6)	;SUBTRACT DIVISOR FROM DIVIDEND
	BLE	DIVID2		;DONE?
	INC	R0		;NO.
	BR	DIVID1
DIVID2:	MOV	R0,4(R6)	;QUOTIENT
	MOV	(R6)+,@R6	;R7
	RTS	R7
;
;THE FOLLOWING TABLE IN THE RESIDENT
;LINKER CONTAINS A ONE WORD ENTRY
;FOR EACH OF THE N OVERLAYS. THE
;1ST WORD OF THE TABLE CONTAINS N*2.
;AS NEW OVERLAYS ARE CREATED, ENTRIES
;MUST BE ADDED TO THE END OF THE TABLE.
;WHEN THE LINKER GETS CONTROL AT
;"LNK", IT WILL PLACE THE STARTING
;PHYSICAL BLOCK NUMBER OF EACH OVERLAY
;IN THE RESPECTIVE ENTRY.
;THE SIGN BIT (BIT 15) OF EACH ENTRY WILL
;INDICATE WHETHER OR NOT THE ASSOCIATED
;OVERLAY IS IN CORE:
;	1=RESIDENT
;	0=NOT RESIDENT
;
RUNTAB:	.WORD	RUNEND-RUNTAB	;N*2
	.WORD	0		;OVERLAY #1
	.WORD	0		;OVERLAY #2
	.WORD	0		;OVERLAY #3
	.WORD	0		;OVERLAY #4
	.WORD	0		;OVERLAY #5
	.WORD	0		;OVERLAY #6
	.WORD	0		;OVERLAY #7
	.WORD	0		;OVERLAY #8
RUNEND:	.WORD	0		;OVERLAY #9
;
;SUBROUTINE TO TRANSFER A REQUESTED
;  OVERLAY FROM THE SYSTEM DEVICE TO THE OVERLAY AREA.
;CALLING SEQUENCE:
;		CONTRL
;		.WORD	N	;WHERE N IS
;				;THE OVERLAY NUMBER
;
;IF THE REQUESTED OVERLAY IS ALREADY RESIDENT,
;CONTROL IS RETURNED IMMEDIATELY TO THE CALLER.
;


;
;IF THE REQUESTED OVERLAY IS NOT RESIDENT:
;	1.  IT IS TRAN'D IN (.TRAN, .WAIT)
;	2.  A CHECK IS MADE FOR ERRORS
;	    DURING TRANSFER
;	3.  RUNTAB IS UPDATED TO REFLECT
;	    WHICH OVERLAY IS NOW RESIDENT
;	4.  RETURN TO CALLER
;
;CONTRL:
SUBR46:	SAVREG			;SAVE REGISTERS 0 THRU 5
	MOV	@16(R6),R1	;OVERLAY NUMBER TO R1
	ASL	R1		;ADJUST TO WORD OFFSET
	MOV	#RUNTAB,R2	;BASE OF TABLE
	ADD	R2,R1		;ADDRESS OF REQUESTED ENTRY
	MOV	@R1,OVRTBI	;SET UP TRAN BLOCK
	BLT	CONTR1		;OVERLAY ALREADY IN
	MOV	#OVRTBI,-(R6)	;.TRAN IN
	MOV	#OVRLB,-(R6)	;THE OVERLAY
	EMT	10
;UPDATE RUNTAB
	MOV	(R2)+,R3	;N*2
CONTR3:	SUB	#2,R3
	BLT	CONTR4		;MORE ENTRIES?
	BIC	#100000,(R2)+	;YES, CLEAR IN FLAG
	BR	CONTR3
CONTR4:	BIS	#100000,@R1	;SET NEW IN FLAG
	RESREG			;RESTORE REGISTERS
	MOV	#OVRLB,-(R6)	;WAIT FOR
	EMT	WTCMD		;COMPLETION
;CHECK FOR ERROR ON TRANSFER
	BIT	#140000,OVRIER
	BEQ	CONTR2
;ERROR ON TRANSFER
	MOV	OVRIER,-(R6)	;PUSH STATUS BYTE
	BIC	#377,@R6	;INFO INTO LOW
	SWAB	@R6		;INFO BYTE AND
	MOV	#ERR8,-(R6)	;CLEAR THE REST.
	JMP	ERROUT
CONTR1:	RESREG			;RESTORE REGS. 0 THRU 5
CONTR2:	ADD	#2,@R6		;INCREMENT PAST ARGUMENT
	RTS	R7		;RETURN TO CALLER
	.ENDC

;
;	BEGIN MAIN PROGRAM
;
;

	.CSECT
LNK:
	.IFDF	DEBUG
	JSR	PC,REPORT
	.ENDC
	BR	5$		;COMMAND STRINGS THROUGH CSI
	INCB	FORTRF		;COMMAND STRINGS FROM FORTRAN
	MOV	SP,BEGCS	;SAVE POINTER TO COMMAND STRING
	;
	;	GET BYTE COUNT OF FORTRAN COMMAND STRING
	;
	MOV	SP,R1
	CLR	R0
3$:	MOVB	(R1)+,CHAR
	CMPB	#LF,CHAR
	BEQ	4$
	INCB	R0
	BR	3$
4$:	INCB	R0
	MOV	R0,FORTBC
5$:	CLR	INCMD
	CLR	OBJDEV
	CLR	MAPDEV
	CLR	LODDEV
	CLR	STBDEV
	CLRB	STBOPF
	CLRB	MAPOPF
	CLRB	LODOPF
	MOVB	#377,NOINIT	;INIT OVERLAY DEVICE FLAG
	.IFNDF	NOSEG
	CLR	OVRLB		;FOR ^C BEGIN
	.ENDC
	.IFNDF	OVRBLD		
	START=LNK		;TRANSFER ADDR.
	.ENDC
	.IFDF	NOSEG
START=LNK
	.ENDC
LINK:	TSTB	FORTRF	;CS FROM FORTRAN?
	BEQ	1$		;NO-
	CMPB	FORTRF,#1	;1ST TIME?
	BEQ	2$		;YES-
	.EXIT			;NO-
2$:	INCB	FORTRF		;MARK 1ST TIME
1$:	DEC	OVLC		;LINKING OVERLAY FILES?
	BLT	INIT1		;NO-
	MOV	SSYMB,SP	;YES-SET STACK POINTER
	MOV	SP,SB		;SET STACK BASE
	;
	;	RESET STACK BASE TO NEW VALUE
	;
	MOV	SB,-(SP)	;NEW STACK BASE ON THE STACK
	MOV	#4,-(SP)	;REQUEST CODE
	EMT	GUT		;EMT CALL
	TST	(SP)+		;CLEAN RETURN VALUE FROM STACK
	;
	;
	MOV	SP,SYMB		;    AND RESTORE SAVED
				;    RESIDENT SYMBOL
	MOV	SASYME,-(SP)	;    TABLE POINTERS
	MOV	(SP),SYMC
	MOV	(SP),SYME
	MOV	(SP),USYME
	MOV	@(SP)+,TOPMEM	;SET DEFAULT TOP OF MEM
	MOV	LIMIT,ENDM	;SET END OF FREE CORE
	BR	INIT2

INIT1:	MOV	LIMIT,SP	;SET SP
	MOV	SP,SB		;SET STACK BASE
	TSTB	FORTRF		;CS FROM FORTRAN?
	BEQ	1$		;NO-
	MOV	BEGCS,SP	;YES-RESET STACK TO NOT TO
				;    DESTROY COMMAND STRING
	;
	;	RESET STACK BASE
	;
1$:	MOV	SB,-(SP)	;PUSH NEW STACK BASE TO STACK
	MOV	#4,-(SP)	;REQUEST CODE
	EMT	GUT		;EMT CALL
	TST	(SP)+		;POP RETURN VALUE FROM STACK
	MOV	SP,ENDM		;CALCULATE SYMBOL TABLE
	SUB	#200.,SP
	MOV	SP,USYME	;INITIAL VALUE FOR END OF SYMBOLS
	MOV	SP,SYMB
	MOV	SP,SYME
	MOV	SP,SYMC
INIT2:
;
;	TRAP HANDLER VECTOR
;
	.TRAP	#0,#TRAPH
	.IFNDF	NOSEG
;
;USE THE COMMAND STRING INTERPRETER (CSI)
;TO DETERMINE THE SYSTEM DEVICE AND
;UNIT OF THIS SYSTEM.
;
	MOV	#ONCE,R0	;ADDRESS OF ONCE ONLY FLAG.
	TSTB	(R0)+		;BRANCH IF ALREADY
	BEQ	OVER2		;DONE ONCE.
;THE FLAG AT ONCE IS CLEARED BY CSI
;DUE TO ITS PROXIMITY TO OVRFB.
;R0 NOW POINTS TO OVRBLK.
	.CSI1	@R0		;ADDRESS OF CMDBUF
;THE LINE IS SYNTACTICALLY ACCEPTABLE, THUS
;THE RETURN FLAG ON TOP OF STACK IS IGNORED.
	MOV	R0,@R6		;ADDRESS OF OVRBLK
	EMT	57		;CSI2
	TST	(R6)+		;CORRECT STACK
OVER2:

;*****SET UP FOR OVERLAYS*****
;
	TSTB	NOINIT		;OVERLAYS ALL
	BEQ	RUN01		;SET UP?
				;NO
	MOV	#OVRLB,R1	;LINK BLOCK
;.INIT OVERLAY DEVICE
	.INIT	R1
;OBTAIN DEVICE STATUS
	.STAT	R1
	CMP	(R6)+,(R6)+	;CORRECT STACK
	;PHYSICAL BLOCK SIZE (WORDS) ON TOP OF STACK

;DIVIDE BLOCK SIZE INTO OVERLAY SIZE TO
;DETERMINE NUMBER OF BLOCKS PER OVERLAY
	MOV	#OVRWRD,-(R6)	;OVERLAY SIZE
	JSR	R7,DIVIDE
	MOV	(R6)+,R5	;BLOCKS PER OVERLAY
;
;DETERMINE THE PHYSICAL STARTING BLOCK
;OF THE CONTIGUOUS FILE.
RUN05:	MOV	#OVRFB,-(R6)	;FILE BLOCK
	CLR	-(R6)
	MOV	R1,-(R6)	;LINK BLOCK
	EMT	14		;.LOOK
	MOV	(R6)+,R4	;STARTING BLOCK
	BNE	RUN03		;DOES FILE EXIST?
	CMP	(R6)+,(R6)+	;CORRECT STACK
	CMP	USERID,#401
	BEQ	RUN04		;ALL DONE.
	MOV	#401,USERID	;TRY [1,1]
	BR	RUN05
RUN04:	MOV	#OVRFB,-(R6)	;LINK11.OVR NOT PRESENT.
	MOV	R1,-(R6)	;PERFORM .OPENC TO FORCE
	EMT	OPN		;FATAL ERROR
RUN03:	CMP	(R6)+,(R6)+	;CORRECT STACK.
;
;PLACE STARTING PHYSICAL BLOCK NUMBER OF
;EACH OVERLAY IN THEIR RESPECTIVE RUNTAB
;ENTRY.  SIGN BIT SET TO 0 FOR NON-RESIDENCY.
;
	MOV	#RUNTAB,R2
	MOV	(R2)+,R3	;NUMBER OF OVERLAYS *2
RUN02:	SUB	#2,R3
	BLT	RUN01		;MORE OVERLAYS?
	MOV	R4,(R2)+	;YES.  STARTING BLOCK # TO
	ADD	R5,R4		;ENTRY.  INCREASE BLOCK #
	BR	RUN02		;BY BLOCKS PER OVERLAY
RUN01:
	.IFDF	DEBUG
	JSR	PC,REPORT
	.ENDC

	CONTRL
	.WORD	2		;OVERLAY #2
	JMP	ENTRY1
	.ENDC
	.IFDF	NOSEG
	JMP	START2
	.ENDC

LINK80:	TSTB	FORTRF		;CSI FROM FORTRAN?
	BEQ	1$		;NO-
	.IFNDF	RSX
	TSTB	MONLIB		;IN MON LIB SEARCH?
	BNE	1$		;YES-
	.ENDC
	MOV	BEGCS,-(SP)	;YES-
	SUB	#20.,(SP)
	BR	2$
1$:	MOV	ENDM,-(SP)	; CHECK FOR ROOM FOR 
	SUB	#BUF,(SP)	; ANOTHER COMMAND STRING
2$:	CMP	USYME,(SP)
	BLO	LINK81
	TST	(SP)+		;NO ROOM- FATAL ERROR
	ERR18
LINK81:	MOV	(SP),ENDM	; GOT ROOM. FIX ENDM,
	MOV	(SP),CMDBUF	; CMDBUF & CINBUF
	MOV	(SP),-(SP)	;PLACE COMMAND BUFFER ON THE STACK
	ADD	#14.,(SP)
	MOV	(SP),CINBUF
	MOV	(SP),R1
	MOV	#84.,(R1)+	;SET MAX BC
	TSTB	FORTRF		;CSI FROM FORTRAN?
	BEQ	1$
	.IFNDF	RSX
	TSTB	MONLIB		;IN MON LIB SEARCH?
	BNE	1$		;YES-
	.ENDC
	MOV	FORTBC,2(R1)	;GET FORTRAN BC
1$:	CLR	(R1)		;SET MODE TO FORMAT ASCII
	.IFNDF	RSX
	TSTB	MONLIB		;IN MON LIB SEARCH?
	.IF DF	OLDLUK
	.IFF
	BNE	LNK200
	.IFT
	BEQ	LINK36		;NO-
	MOV	#4.,2(R1)
	CMP	(R1)+,(R1)+
	MOV	-2(R1),R2	;SET COUNTER TO 20.
	MOV	#MONL+6,R0	;POINT R0 TO CANNED MESSAGE
LNK114:	MOVB	(R0)+,(R1)+	;MOVE CANNED MESSAGE INTO CINBUF
	DEC	R2		;DECREMENT COUNT
	BEQ	LNK115		;GO PROCESS MON LIB
	BR	LNK114
	.ENDC
LINK36:	JMP	LNK113
	.IF DF	OLDLUK
LNK115:	TST	(SP)+
	.CSI1	(SP)
	TST	(SP)+
	MOV	#2,@CMDBUF
	MOV	CMDBUF,BLKI
	.CSI2	#BLKI
	.IFF
LNK200:	CMP	(SP)+,(SP)+
	.ENDC

;
;	INIT INPUT DEVICE
;
	INCB	FLAG
	MOVTAB
	CLRB	FLAG
	.IF NDF	OLDLUK
	CLRB	OBJDEV+5	;SET UNIT ZERO
	MOV	#75250,OBJDEV+6	;SET UP 'SY' ENTRY
	.ENDC
	.IFDF	BLKIO
	JSR	PC,INITRD	;INIT THE INPUT DEVICE
	.ENDC
	.IFNDF	BLKIO
	.INIT	#OBJDEV
	.ENDC
	.IF NDF	OLDLUK
;
;GET MONITOR LIBRARY STARTING BLOCK AND FIND PROPER ENTRY
;
	.GTCIL			;GET LIBRARY ADDRESS
	MOV	(SP),MSTART	;REMEMBER IT
	MOV	(SP)+,TRNBLK	;SET UP AN ADDRESS FOR THE TRAN
	MOV	INA,-(SP)	;GET THE BYTE COUNT
	CLC			;AND
	ASR	(SP)		;CONVERT IT TO A WORD COUNT
	MOV	(SP)+,TRNBLK+4	;WORD COUNT TO TRANSFER
	MOV	#INA+6,TRNBLK+2	;CORE ADDRESS
	.TRAN	#OBJDEV,#TRNBLK	;DO THE TRAN AND PRAY THAT
	.WAIT	#OBJDEV		;WE READ ENOUGH TO USE!!!!
	MOV	#INA+6,R0	;GET BUFFER POINTER
	MOV	#1,R1		;GET NEEDED CONSTANT
1$:	CMP	(R0)+,R1	;IS THIS THE START OF THE CIL LINE?
	BNE	1$		;NO, SKIP OVER TRASH
	ADD	(R0),R0		;POINT TO THE SECOND ENTRY
2$:	CMP	(R0)+,R1	;FIND THE START
	BNE	2$		;ENTRY
	ADD	(R0),R0		;NOW SKIP TO THE THIRD ENTRY
3$:	CMP	(R0)+,R1	;NOW MAKE SURE
	BNE	3$		;WE ARE THERE
	ADD	#14.,R0		;POINT TO THE PROPER DISK ADDRESS
	ADD	(R0),MSTART	;NOW WE HAVE THE ABSOLUTE BLOCK POINTER
	.ENDC
;
;	OBTAIN CURRENT MONITOR TOP
;
	.MONF
	MOV	(SP)+,MONTOP
	ADD	#200,MONTOP
	.IFNDF	OLDLUK
	MOV	MSTART,TRNBLK
	.ENDC
	.IFDF	OLDLUK
	MOV	#4,TRNBLK
	.ENDC
;
;	OBTAIN DEVICE STATUS
;	AND ALLOCATE BUFFER SPACE FOR TRAN
;
	.IFDF	BLKIO
	JSR	PC,READST	;GET THE INPUT STATUS
	.ENDC
	.IFNDF	BLKIO
	.STAT	#OBJDEV
	.ENDC
	CMP	(SP)+,(SP)+
	MOV	(SP)+,BUFSIZ	;BLOCK SIZE
	MOV	SP,SPTEST	;SAVE STACK POINTER
	SUB	MONTOP,SPTEST	;DISTANCE FROM MONTOP TO SP
	MOV	BUFSIZ,TRNBLK+4	;SET WORD COUNT
	ASL	BUFSIZ		;MULTIPLY BLOCK SIZE BY TWO
	CMP	SPTEST,BUFSIZ	;IS THERE BUFFER SPACE?
	BHI	LNK118		;YES-
	ERR18			;NO-

LNK118:	MOV	MONTOP,TRNBLK+2	;SET CORE STARTING ADDR FOR TRAN
	.IFDF	OLDLUK
	MOV	BUFSIZ,BC	;PREPARE MONLIB BC
	NEG	BC
	.ENDC
	MOV	MONTOP,-(SP)
	.IFNDF	OLDLUK
	MOV	(SP),TSIZE	;MRT TABLE SIZE IN BYTES
	ADD	#2,(SP)
	MOV	(SP)+,FDATA
	ADD	#2,INDEX	;SKIP EMT 0,1.
	.ENDC
	.IFDF	OLDLUK
	ADD	#2,(SP)
	MOV	(SP)+,FDATA
	.ENDC
;
;CALCULATE SYMTAB BC
;
	MOV	USYME,-(SP)
	MOV	SYME,-(SP)
	SUB	(SP)+,(SP)
	MOV	(SP)+,STBC
	NEG	STBC
;
;	TRANSFER ABSOLUTE BLOCK AND WAIT ON IT
;
LNK124:
	.TRAN	#OBJDEV,#TRNBLK
	.WAIT	#OBJDEV
	BITB	#EOF,TRNBLK+7
	BEQ	2$
	ERR21
	.IFNDF	OLDLUK
2$:	CMP	@TSIZE,BUFSIZ
	BLT	1$
	SUB	BUFSIZ,@TSIZE	;DECREMENT MRT TABLE SIZE
				;BY BUFSIZ
	BR	LNK122
1$:	TST	TSIZE
	BEQ	LNK123		;DONE WITH MONITOR LIBRARY SEARCH
	CMP	#2,INDEX
	BEQ	3$
	MOV	MONTOP,FDATA
3$:	INCB	LASTDB		;NO MORE TO READ
;
;	NOTE THE ASSUMPTION THAT THE MRT SIZE IS AT MOST TWO 
;	DEVICE BUFFER FULL.
;
	.ENDC
	.IFDF	OLDLUK
2$:	TST	@MONTOP
	BEQ	LNK121
	.ENDC
LNK122:
	.IFNDF	OLDLUK
	MOV	@TSIZE,BC	;FIX BC
	NEG	BC
	.ENDC
	DIRSR			;NO-
	TSTB	LASTDB		;ANY MORE TO READ?
	BNE	LNK123		;NO-
	.IFNDF	OLDLUK
	INC	MSTART		;YES-
	MOV	MSTART,TRNBLK
	.ENDC
	.IFDF	OLDLUK
	MOV	@MONTOP,TRNBLK
	.ENDC
	BR	LNK124		;GO TO READ NEXT BOX.

	.IFDF	OLDLUK
LNK121:	MOVB	#1,LASTDB
	BR	LNK122
	.ENDC
LNK123:
	.IFNDF	OLDLUK
	CLR	INDEX		;REINITIALIZE MRT TABLE INDEX
	CLRB	LASTDB
	.ENDC
	.IFDF	BLKIO
	JSR	PC,RLSRD	;RELEASE INPUT DEVICE
	.ENDC
	.IFNDF	BLKIO
	.RLSE	#OBJDEV		;RELEASE INPUT DEVICE
	.ENDC
	ADD	#BUF,ENDM	;RECLAIM SPACE FROM LAST CSI BUFFER.
	MOVB	#1,SECTIM	;GET PREPARED TO
	MOV	SSYME,SYME	;REPLACE "   " BY
	.IFNDF	NOSEG		;".  "
	CONTRL
	.WORD	4
	JMP	ENTRY1
	.ENDC
	.IFDF	NOSEG
	JMP	LINK13
	.ENDC
	.ENDC
LNK113:	TSTB	FORTRF		;CSI FROM FORTRAN?
	BEQ	1$		;NO-
	MOV	@#CMDBUF,-(SP)	;YES-
	BR	LINK82
1$:	MOV	#NO,R0		; TYPE "#"
	TYPE
	CLRB	BIT2F
	MOV	(SP),R0		; READ COMMAND STRING
	MOV	#INCMD,-(SP)
	EMT	READ
	.WAIT	#INCMD
	BIT	#060000,2(R0)
	BNE	STOP
;
;NOTE- PTR TO BUFFER STILL ON STACK
;      -IT WAS PUT THERE AFTER LINK81-

LINK82:	EMT	CSI1		;DO SYNTAX CHECK
	TST	(SP)
	BEQ	LINK83		;ERROR?
	TSTB	FORTRF		;CS FROM FORTRAN?
	BEQ	1$		;NO-
	MOV	#ERR10,-(SP)	;YES-PRINT F044 EXIT TO MON
	IOT
	.EXIT
1$:	CMPB	#CR,@(SP)
	BEQ	.+4
	INCB	(SP)		;YES - MOVE ?, VT INTO CINBUF
	MOVB	#77,@(SP)
	INCB	(SP)
	MOVB	#13,@(SP)
	MOV	@#CINBUF,R0	;UPDATE: BC=4+LENGTH
	MOV	(SP)+,4(R0)	;END =(SP), BASE =R0+6
	MOV	R0,-(SP)	;LENGTH=END-BASE
	ADD	#5,(SP)
	SUB	(SP)+,4(R0)	;4(R0)=(SP)-(R0+6)
	TYPE
	MOV	#5015,6(R0)	;MOV CR,LF INTO CINBUF
	MOV	#2,4(R0)	;UPDATE BYTE COUNT.
	TYPE			;TYPE A BLANK LINE
	TYPE
	MOV	CMDBUF,-(SP)	;PREPARE STACK
	JMP	LINK81
STOP:	.EXIT
LINK83:	TST	(SP)+
	TSTB	PASS
	BNE	LNK137		; PASS 2 -
	TSTB	FLINE
	BNE	LNK137
	.IFNDF	NOSEG
	CONTRL
	.WORD	3		;OVERLAY #3
	JMP	ENTRY1
	.ENDC
	.IFDF	NOSEG
	JMP	STRT31
	.ENDC
LNK137:	JMP	LINK84

LNK128:	MOVTAB
	IOIC
	.CSI1	@#CMDBUF
	TST	OVLC		;IN OVERLAY SECTION OF
				;ASSOCIATED LINK?
	BGE	LINK84		;YES- TOP OF MEM IS
				;SET ALREADY
	.IFNDF	NOSEG
	CONTRL			;NO-SET TOP OF MEM
	.WORD	3		;OVERLAY #3
	JMP	ENTRY2
	.ENDC
	.IFDF	NOSEG
	JMP	STRT32
	.ENDC


; START PROCESSING THE INPUT FILES FROM COMMAND STRING
;
; CHECK IF PROCESSING MULTIPLE TAPES
;
LINK84:	TSTB	TAPES		; /TA SWITCH ?
	BEQ	LINK89		; NO-
	TST	TAPCT		; YES- COUNT =0 ?
	BNE	LINK90		; NO-
LINK89:	CLR	@CMDBUF		;ASSUME INPUT
	TSTB	FLINE
	BEQ	LINK91
	MOV	CMDBUF,BLKI	;CHECK FOR "<"
	.CSI2	#BLKI
	TST	OBJDEV+6
	BEQ	LINK37
	ERR16			;MULTIPLE "<" IN CSI
LINK37:	BIT	#4,(SP)		;BIT2 SET?
	BEQ	13$		;NO-
	INCB	BIT2F		;YES-
13$:	BIT	#2,(SP)		;BIT1 SET?
	BEQ	14$		;NO-
	ERR19			;YES-

14$:	ASR	(SP)+
	BCS	LINK38		;ODD=>NO MULT "<" IN CSI
	ERR16			;EVEN=> MULT "<" IN CSI
LINK38:	MOV	#2,@CMDBUF	;CHANGE TO OUTPUT ON ALL LINES EXCEPT

				;FIRST
LINK91:	MOV	CMDBUF,BLKI	; SET UP INPUT BLOCK
	.CSI2	#BLKI
LNK159:	MOV	(SP),SCSIRV	; SAVE THE RETURN VALUE
	BIC	#177776,SCSIRV	;SAVE LAST BIT ONLY
	TST	OBJDEV+6	;WAS THERE AN INPUT DEVICE?
	BNE	LINK39		;YES -
	TST	OBJDEV+10	;NO - WAS THERE A SWITCH?
	BNE	LINK39		;YES -
	ASR	(SP)+		;NO -
	BCS	LNK139
	ERR17			;MISSING INPUT SPEC.
LNK139:	TSTB	NOMMS
	BEQ	LNK140
LNK145:	CLRB	NOMMS
LNK140:	MOV	#CRLF,DUMIN+6
	MOV	#2,DUMIN+4
	MOV	#DUMIN,R0
	TYPE
	MOV	CMDBUF,-(SP)
	JMP	LINK81
LINK39:	BIT	#4,(SP)		;BIT2 SET?
	BEQ	15$		;NO-
	INCB	BIT2F		;YES-
15$:	BIT	#2,(SP)		;BIT1 SET?
	BEQ	LNK142		;NO-
	ERR19			;YES-

;
;  PROCESS PRESWITCHES
;
LNK142:	CLRB	TAPES
	CLR	TAPCT
	CMP	#63320,OBJDEV+6
	BNE	LINK92
	INCB	TAPES
	MOV	#1,TAPCT

LINK92:	MOV	#OBJDEV+8.,R1	; PTR TO SWITCH SIZE
LINK95:	TST	(R1)
	BEQ	LINK90		; DONE- NO MORE SWITCHES
	MOV	#PRESW,R0
	SWSR			; RET DISPATCH ADR IN R0
	TST	R0		; IGNORE IF DON'T RECOGNIZE THE SWITCH.
	BEQ	LINK93		;ASSUME IT IS A POST SWITCH.
LINK94:	JSR	PC,(R0)		; GO PROCESS SWITCH
LINK93:	MOV	(R1),-(SP)	; ADVANCE R1 TO NEXT SWITCH
	ASL	(SP)
	ADD	(SP)+,R1	; R1=R1+2*N
	TST	(R1)+
	BR	LINK95
LNK02:	CLRB	LIBF
	CLRB	TAPES
	CLR	TAPCT
	BR	LINK98
LNK180:				;GO CREATE RTH
	.IFNDF	NOSEG
	CONTRL
	.WORD	9.		;OVERLAY #9
	JMP	ENTRY1
	.ENDC
	.IFDF	NOSEG
	JMP	DONE
	.ENDC
LINK90:
	.IFDF	RTH		;BRTH13
	TSTB	NOIOF		;STAND ALONE SW?
	BEQ	.+14		;NO-
	TSTB	PASS
	BNE	LNK180
	JMP	LINK98
	.ENDC			;ERTH13
	TSTB	PASS		;DON'T TRY TO ADVANCE
	BEQ	LNK164		;CSI PTR IN 1ST PASS
LNK168:	DECB	SCOUNT		;ADV CSI PTR THROUGH CLIB
	BLT	LNK165		;SYMTAB FILE SPECS IN 2ND PASS
	INCB	CLFLAG		;CURRENTLY PROCESSING CORE LIBS.
	TSTB	TAPES		;MORE SYMTABS COME. IN TAPES?
	BEQ	LNK166		;NO-
	DEC	TAPCT		;YES-REDUCE TAPE COUNT.
	BLE	LNK167		;END OF TAPE COUNT -GO CLEAR TAPES
	BR	LNK168		;GO TO REDUCE SCOUNT AGAIN

LNK165:	TSTB	TAPES		;LAST SYMTAB COUNTED.FROM TAPES?
	BEQ	LNK164		;NO- START PROCESSING TASKS
	TSTB	CLFLAG		;YES-CLFLAG ON?
	BEQ	LNK164		;NO- START PROCESSING TASKS
	CLRB	CLFLAG		;YES-CLEAR CLFLAG
	TST	TAPCT		;IS TAPE COUNT=0?
	BNE	LNK164		;NO-
	CLRB	TAPES		;YES- CLEAR TAPES
	BR	LNK164		;PROCESS TASKS
LNK167:	CLRB	TAPES		;CLEAR TAPES
LNK166:	TST	SCSIRV		;END OF CSI LINE?
	BNE	.+6		;YES-
	JMP	LINK89		;NO-ISSUE DUMMY CALL TO CSI2
	INCB	FLINE		;INDICATE THAT CURRENT CSI LINE
				;IS NOT THE 1ST LINE
	BR	LINK73		;GO GET NEXT CSI LINE
LNK164:TSTB	LIBF		;TEST LIB. FLAG
	BNE	LNK02
	TSTB	PASS
	BEQ	.+6
	JMP	LINK40		;PASS 2
	GGSD			;GET GSD
LINK97:	TSTB	TAPES		; DOING TAPES ?
	BEQ	LINK98		; NO-
	DEC	TAPCT		;YES- DECREMENT COUNTER
	BGT	LINK90		; IF >0 , DO ANOTHER TAPE
	CLRB	TAPES
;
;  PROCESS POST SWITCHES
;
LINK98:	CLRB	CONCAT		;NO MORE CONCATENATION
	MOV	#OBJDEV+8.,R1	; ADR OF FIRST SWITCH
LINK99:	TST	(R1)		; DONE WITH SWITCHES ?
	BEQ	LINK70		; YES-
	MOV	#POSTSW,R0
	SWSR
	TST	R0		; FIND IT ?
	BNE	LINK71		; YES-
;
; 2 ILLEGAL SWITCH!!
;
	ERR19	
	BR	LINK79
LINK71:	JSR	PC,(R0)		; PROCESS THE SWITCH
LINK79:	MOV	(R1),-(SP)
	ASL	(SP)
	ADD	(SP)+,R1	;R1=R1+2*N
	TST	(R1)+
	BR	LINK99		; DO NEXT SWITCH
;
;   CHECK FOR END OF COMMAND STRING
;
LINK70:	TST	SCSIRV		; CHECK RETURN VALUE FROM CSI2
	BNE	LINK72		; END-
	JMP	LINK84		; NOT END-
LINK72:	INCB	FLINE		; COUNT TO NEXT LINE
	TSTB	PASS		; WHICH PASS?
	BNE	LINK73		; PASS 2-
	JMP	LINK80		; PASS 1-
LINK73:	TSTB	FORTRF		;CS FROM FORTRAN?
	BEQ	1$		;NO-
	SUB	#20.,CMDBUF	;YES-
	BR	2$
1$:	SUB	#BUF,CMDBUF
2$:	MOV	CMDBUF,-(SP)
	JMP	LINK82
	.EOT


;TAPE 5

;
;   PROCESSING FOR PRESWITCHES
;
;   DISPATCH TABLE
;
PRESW:	.BYTE 'T,0		;TOP
	+LINK68
	.BYTE 'B,0		;BOTTOM
	+LINK67
	.BYTE	'L,0		;LIBRARY
	+LINK06
	.BYTE 'O,'D		;DDT
	+LINK65
	.BYTE 'T,'R		;TRANSFER ADDRESS
	+LINK69
	.BYTE 'T,'A		;TAPES
	+LINK58
	.BYTE 'C,'C		;CONCATENATED FILE
	+LINK74
	.BYTE	'O,'V		;OVERLAY
	+LNK194
	.BYTE	'I,'D		;IDENT
	+LNK196
	.IFDF	RTH		;BRTH24
	.BYTE	'R,'T		;RTH
	+LNK175
	.ENDC			;ERTH24
	-1			;END OF TABLE
BEGSTB:	INCB	SCOUNT		;INCREMENT SYMTAB COUNT
	TSTB	NSTBF		;READ A TASK ALREADY?
	BEQ	.+4		;NO-OK
	ERR24			;YES-ERROR
	CMP	(R0),#2		;ANY SYMTAB TO INPUT?
	BLO	LNK153		;NO-
	MOV	SYME,R3		;YES-
LNK154:	CMPB	#STBEND,(R1)	;REACHED END OF SYMTAB?
	BEQ	LNK153		;YES-
	CMPB	#STBBLK,(R1)	;NO-SYMTAB BLOCK?
	BEQ	.+4		;YES-OK
	ERR25			;NO-ERROR
	MOV	R3,-(SP)
	ADD	(R0),(SP)

	CMP	(SP),ENDM	;CLEAN STACK LATER
	BLOS	.+4		;THERE IS ROOM FOR BLOCK
	ERR18			;S223, NO ROOM FOR BLOCK.
	TST	(R1)+		;IGNORE CONTROL INFO.
	SUB	#4,(SP)		;UPDATE BC
LNK156:	CMP	R3,(SP)		;STB BLOCK COMPLETED?
	BHI	LNK155		;YES-GO GET ANOTHER BLOCK.
	MOV	(R1)+,(R3)+	;NO-TRANSFER 1 WORD
	BR	LNK156		;GO CHECK, BLOCK FINISHED?
LNK155:	IOIG			;GET ANOTHER BLOCK
	TST	(SP)+		;CLEAN STACK NOW
	BR	LNK154		;GO PROCESS NEW BLOCK.
LNK153:	IOIC			;CLOSE INPUT FILE
	TST	-(R3)
	MOV	R3,SYMC		;UPDATE
	MOV	R3,SYME		;SYMBOL TABLE
	MOV	R3,USYME	;POINTERS
	MOV	(R3),TOPMEM	;SET DEFAULT TOP OF MEM
	RESREG			;SAVREG IN GGSD
	RTS	PC
;
;TOP
;
LINK68:	TSTB	PASS

	BNE	LNK01		;GET OUT IF PASS 2
	ONEVAL
	.O2BIN	2(R1)		;CONVERT OCTAL TO BINARY
	INCB	TOPF
	CLRB	BOTF
	MOV	(SP),TOPMEM	;SET NEW TOP
	ASR	(SP)+
	BCC	.+4
	ERR19
LNK04:	TST	(SP)+		;IGNORE PTR TO ASCII.
LNK01:LNK11:
	MOV	(R1),-(SP)	;FORM ADDRESS OF SWITCH
	ASL	(SP)
	ADD	R1,(SP)
	CLR	@(SP)+		;CLEAR THE SWITCH
LINK02:	RTS	PC
	.IFDF	RTH		;BRTH14
;
;REAL TIME
;
LNK175:	MOV	R1,R2		;SAVE PTR TO SW SIZE
	MOV	(R1),R5
	CMP	R5,#SWSMAX
	BLE	.+4
	ERR14
	ASL	R5
	JMP	@SWSDT(R5)	;GO TO PROPER SWITCH VALUE
SWSDT:	+SWSER,SWS1,SWS2,SWS3,SWS4,SWS5,SWS6
SWS6:	MOV	#SS,R3		;NO-PROCESS STACK SIZE
	MOV	#SWS5,RTADR
	RTVALS
	INCB	CSISS		;SS FROM CSI
	MOV	SS,-(SP)	;ODD STACK SIZE ?
	ASR	(SP)+
	BCC	SWS5		;EVEN
	INC	SS		;ODD, MAKE EVEN
SWS5:	MOV	#MT,R3
	MOV	#SWS4,RTADR	;PROCESS MAX TIME
	RTVALS
	INCB	CSIMT		;MT FROM CSI
SWS4:	MOV	#CN,R3
	MOV	#SWS3,RTADR	;PROCESS CALL NO
	RTVALS
	INCB	CSICN		;CN FROM CSI
SWS3:	MOV	#PRIOR,R3
	MOV	#ENDCH,RTADR	;PROCESS PRIORITY
	RTVALS
	INCB	CSIP		;PRIOR FROM CSI
ENDCH:	TST	-2(R3)		;PRIORITY < OR = 0?
	BLE	.+12		;YES-ERROR
	CMP	#4,-2(R3)	;NO-PRIORITY >4?
	BGE	SWS2		;NO-OK
	ERR27			;YES-ERROR
SWSER:	MOV	#REMDER,R0	;PRINT /RT SW REMINDER
	TYPE
	TST	(SP)+
	MOV	CMDBUF,-(SP)	;ASK FOR CSI AGAIN
	JMP	LINK81
SWS2:	MOV	#NAM1,R3
	CMPB	#72,@2(R1)	;IS VALUE:?
	BEQ	FIXFL		;YES
	MOV	2(R1),-(SP)	;NO- PROCESS NAME
	MOV	#RATOBI,-(SP)	;DO A RADIX 50 PACK
	EMT	CONV
	MOV	(SP)+,(R3)+
	MOV	#RATOBI,-(SP)	;2ND WORD
	EMT	CONV
	MOV	(SP)+,(R3)+
	TST	(SP)+
	INCB	CSIN		;NAME FROM CSI
FIXFL:	INCB	RTNOVA

SWS1:	INCB	RTF
	TST	OBJADR		;FILE NAME GIVEN?
	BEQ	.+4		;NO-
	BR	SAVPTR		;YES-DO IO
	MOV	#106,-(SP)	;NO-GET SYSTEM DEV.
	EMT	41
	CMP	(SP)+,OBJDEV+6	;SYST DEV=CURRENT INP DEV?
	BEQ	.+4
	BR	SAVPTR		;NO- DO IO
	INCB	NOIOF		;YES-NO IO
	MOV	#44,RTHSIZ	;SET RTH SIZE.
	BR	CLRSW
SAVPTR:	TSTB	PASS		;SET PTR TO RTH IN SYMTAB
	BNE	.+10
	MOV	SYME,RTHPTR
CLRSW:	TSTB	RTNOVA
	BNE	.+4
	TST	-(R1)
	CLRB	RTNOVA
	CMP	(R1)+,(R1)+	;CLEAR THE SWITCH
	CLR	(R1)
	RTS	PC
	.ENDC			;ERTH14
;
;	IDENT
;
;	IF THIS SWITCH IS SET WITH THE 1ST INPUT FILE SPECIFICATION
;	THEN THE .IDENT FROM THIS SPECIFICATION IS PUT INTO THE
;	LINKER'S SYMBOL TABLE AND LOAD MAP AND ALL SUBSEQUENT
;	.IDENTS ARE IGNORED BY THE LINKER,I.E. THEY ARE NEITHER
;	COPIED INTO THE SYMBOL TABLE NOR PRINTED IN THE LOAD MAP
;
LNK196:	INCB	IDF		;SET ID FLAG
	NOVAL
	JMP	LINK01


;
;  BOTTOM
;
LINK67:	TSTB	PASS
	BNE	LNK176		;IGNORE IF PASS 2 OR TOP SET
	ONEVAL
	.O2BIN	2(R1)		;CONVERT OCTAL TO BINARY
	INCB	BOTF		;SET FLAG AND
	CLRB	TOPF
	MOV	(SP),BOTMEM	;    VALUE
	ASR	(SP)+
	BCC	.+4
	ERR19
	JMP	LINK04		;RETURN
LNK176:	JMP	LNK01
;
;	OVERLAY
;
LNK194:	INCB	OVLF		;SET OVLF FLAG
	SUB	#BUF,ENDM	;PROVIDE SPACE FOR 1ST CSI BUF
				;FOR 1ST OVL FILE OF ASSOC LINK
	TSTB	PASS
	BNE	LNK176		;IGNORE IF PASS 2
	ONEVAL
	.D2BIN	2(R1)		;CONVERT DECIMAL TO BINARY
	MOV	(SP)+,OVLC	;SET COUNT
	JMP	LINK04		;RETURN
	INBLN=INB-INA
;
;	LIBRARY
;
LINK06:	INCB	FREADF		;THIS IS THE 1ST READ
	INCB	LIBF		;SET LIB FLAG
	MOV	R1,SWSIZE	;SAVE PTR TO SW SIZE
	NOVAL
	MOV	(SP),SPRETV	;SAVE STACK RET VALUE
	TSTB	PASS

	BEQ	LNK129
	.IFDF	BLKIO
	JSR	PC,INITRD	;INIT INPUT DATA SET
	.ENDC
	.IFNDF	BLKIO
	.INIT	#OBJDEV		;INIT OBJ. MOD. DATA SET
	.ENDC
	MOV	#ERRETL,OBJADR-4
	TST	OBJADR+4
	BNE	.+10
	MOV	#0,OBJADR+4	;SET DEFAULT EXT
	.=.-4
	.RAD50	/OBJ/
	.=.+2
DOOVER:
	.IFDF	BLKIO
	JSR	PC,OPENRD	;OPEN THE READ DATA SET
	.ENDC
	.IFNDF	BLKIO
	.OPEN	#OBJDEV,#OBJADR
	.ENDC
	BR	LINK07
ERRETL:	CMP	#401,OBJADR+6
	BNE	.+14
	CLR	OBJADR-4
	CLR	OBJADR+6
	BR	DOOVER
	MOV	#401,OBJADR+6
	BR	DOOVER
LNK129:	MOVTAB
	MOV	#INA,IN
	.IFDF	BLKIO
	JSR	PC,READIT	;DO A
	.ENDC
	.IFNDF	BLKIO

	.READ	#OBJDEV,#INA
	.WAIT	#OBJDEV
	.ENDC
LINK41:	TSTB	FREADF		;LOOP,1ST READ COMMING?
	BEQ	LINK96		;NO-
	CLRB	FREADF		;CLEAR 1ST READ FLAG
LINK23:	MOV	IN,-(SP)
	ADD	#INBLN,(SP)
	CMP	(SP)+,#INB
	BLOS	LNK109
LNK105:
	.IFDF	BLKIO
	JSR	PC,READIT
	.ENDC
	.IFNDF	BLKIO
	.READ	#OBJDEV,#INA
	.ENDC
	MOV	#INA,IN
	BR	LINK96
LNK109:
	.IFDF	BLKIO
	JSR	PC,READIU
	.ENDC
	.IFNDF	BLKIO
	.READ	#OBJDEV,#INB
	.ENDC
	MOV	#INB,IN
LINK96:
	.IFNDF	BLKIO
	.WAIT	#OBJDEV
	.ENDC
	MOV	IN,R0
	CMP	(R0)+,(R0)+	;IGNORE FORM. BIN. CODE
	READER
	MOV	(R0)+,BC	;GET BYTE COUNT
	NEG	BC		;GET  -BC
	CMP	#10,(R0)	;DIR ENDED?
	BEQ	LINK26		;YES-GET OUT
	CMP	#1,(R0)		;GSD BLOCK?
	BNE	LINK23		;NO-
	ADD	#7,R0		;YES-OBJ MOD NAME BLOCK?
	MOVB	(R0)+,HBYTE
	CMPB	HBYTE,#0
	BNE	LNK100		;NO-
	MOV	-6(R0),FNAME	;YES-SAVE CURRENT OBJ MOD. NAME
	MOV	-4(R0),SNAME	;IN DIRECTORY
	MOV	IN,INSAVE
	INCB	FBBF		;MARK THIS BLOCK AS 1ST READ
LNK100:	TST	(R0)+		;
	ADD	#10,BC		;PREP BC
	MOV	R0,FDATA	;SAVE PTR TO 1ST DATA
	MOV	USYME,-(SP)
	MOV	SYME,-(SP)
	SUB	(SP)+,(SP)	;SAVE SYMTAB BC
	MOV	(SP)+,STBC
	NEG	STBC
	DIRSR
	TST	DIRSRV		;RET VAL: 0=FAIL,1=SUCCEED
	BEQ	LNK101		;FAILED-GO TO READ NEXT BLOCK
	BR	LNK102		;SUCCEEDED

LINK07:	JMP	LNK117
LINK26:	JMP	LNK110
LNK101:	TSTB	FBBF
	BEQ	LNK108
	CLRB	FBBF
	INCB	SBBF
	MOV	#2,CNT
	BR	LINK23
LNK108:	TSTB	SBBF
	BEQ	LINK23
	CLRB	SBBF
	BR	LINK23
LNK102:	TSTB	FBBF		;IS 1ST BB FLAG STILL ON?
	BNE	LNK103		;YES-GO GET GGSD,"IN" OK
	TSTB	SBBF
	BNE	LNK106
	BR	LNK107
LNK106:	MOV	IN,-(SP)
	MOV	INSAVE,IN
	MOV	(SP)+,INSAVE
	BR	LNK103
LNK107:	JSR	R5,RDEOT
	TSTB	TAPES
	BEQ	.+4
	ERR28
	IOIC			;CLOSE & RELEASE OBJ DEV
	.IFDF	BLKIO
	JSR	PC,INITRD
	.ENDC
	.IFNDF	BLKIO
	.INIT	#OBJDEV		;INIT,OPEN INPUT
	.ENDC
	TST	OBJADR+4
	BNE	.+10
	MOV	#0,OBJADR+4

	.=.-4
	.RAD50	/OBJ/
	.=.+2
	.IFDF	BLKIO
	JSR	PC,OPENRD
	.ENDC
	.IFNDF	BLKIO
	.OPEN	#OBJDEV,#OBJADR
	.ENDC
LNK104:
	.IFDF	BLKIO
	JSR	PC,READIT
	.ENDC
	.IFNDF	BLKIO
	.READ	#OBJDEV,#INA
	.WAIT	#OBJDEV
	.ENDC
	MOV	#INA,IN
	MOV	IN,R0
	CMP	(R0)+,(R0)+	;IGNORE 1ST 2 WORDS OF HEADER
	READER
	MOV	(R0)+,BC
	NEG	BC		;GET BC
	CMP	#1,(R0)+	;GSD BLOCK?
	BNE	LNK104		;NO-HADE TO BE GSD END
	CMP	(R0)+,FNAME	;YES-1ST PART OF SYMBOL MATCH?
	BNE	LNK104		;NO-
	CMP	(R0)+,SNAME	;YES-2ND PART OF SYM MATCH?
	BNE	LNK104		;NO-
	TSTB	(R0)+		;YES
	MOVB	(R0)+,HBYTE	;WAS SYMBOL OBJ MOD NAME?
	CMPB	HBYTE,#0

	BNE	LNK104		;NO-
LNK103:	GGSD			;YES-GO GET GGSD "IN" OK
	JMP	LINK96		;GO TO WAIT ON LAST READ
LNK110:	JSR	R5,RDEOT
	IOIC			;CLOSE & RELEASE OBJ DEV
	MOV	SWSIZE,R1	;SAVE PTR TO LIB SW SIZE
	MOV	(R1),-(SP)	;FORM ADDRESS OF SWITCH
	ASL	(SP)
	ADD	R1,(SP)
	CLR	@(SP)+		;CLEAR THE SWITCH
	MOV	SPRETV,(SP)	;RESTORE STACK RET VALUE
	RTS	PC
LNK117:	TSTB	FREADF		;1ST READ?
	BEQ	LNK10		;NO-
	CLRB	FREADF		;YES-
LNK08:	MOV	#INA,IN
	.IFDF	BLKIO
	JSR	PC,READIT
	.ENDC
	.IFNDF	BLKIO
	.READ	#OBJDEV,#INA
	.WAIT	#OBJDEV
	.ENDC
	MOV	IN,R0
	CMP	(R0)+,(R0)+
	READER
	TST	(R0)+
	CMP	#10,(R0)
	BNE	LNK08
LNK09:
	.IFDF	BLKIO
	JSR	PC,READIT
	.ENDC
	.IFNDF	BLKIO
	.READ	#OBJDEV,#INA
	.ENDC
	MOV	#INA,IN
LNK10:
	.IFNDF	BLKIO
	.WAIT	#OBJDEV
	.ENDC
	MOV	IN,R0
	ADD	#3,R0
	MOVB	(R0)+,HBYTE
	BITB	#100,HBYTE	;EOF OF LIBR SEEN?
	BNE	LNK110
	BITB	#EOF,HBYTE
	BEQ	.+4
	ERR15
	TST	(R0)+
	CMP	#1,(R0)		;GSD?
	BNE	LNK09		;NO-
	MOV	PTRG,R1		;YES-
	TST	(R0)+		;ADVANCE PTR IN READIN BUFF
	CMP	(R0)+,(R1)+	;1ST MATCH?
	BNE	LNK09		;NO-
	CMP	(R0)+,(R1)+	;YES-2ND MATCH ALSO?
	BNE	LNK09		;NO-
	TSTB	(R0)+
	MOVB	(R0)+,HBYTE
	CMPB	HBYTE,#0
	BNE	LNK09		;LIB ENTRY NOT OMN
LINK40:	.IFNDF	NOSEG
	CONTRL
	.WORD	8.		;OVERLAY #8
	JMP	ENTRY1
	.ENDC
	.IFDF	NOSEG
	JMP	START8
	.ENDC
;
;	CC SWITCH--CONCATENATION
;

LINK74:	INCB	CONCAT
	NOVAL
	BR	LINK01

;
;  TAPES
;
LINK58:	ONEVAL
	.D2BIN	2(R1)		;CONVERT DECIMAL TO BINARY
	INCB	TAPES
	MOV	(SP)+,TAPCT	;SET COUNT
LINK04:	JMP	LNK04		;EXIT
LINK01:LINK11:	JMP	LNK01
;
;	TRANSFER ADDRESS
;
LINK69:	CMP	(R1),#2		;DOES IT HAVE A VALUE?
	BLO	LINK08		;NO VALUE-
	ONEVAL
	TSTB	PASS
	BNE	LINK01		;IGNORE IF PASS 2
	CMPB	@2(R1),#'A	;IS FIRST CHAR A # OR A LETTER?
	BLO	LINK09		;NUMBER-
	.RADPK	2(R1)		;DO A RAD50 PACK
	MOV	(SP)+,TRABLK+4
	MOV	#RATOBI,-(SP)	;SECOND WORD
	EMT	CONV
	MOV	(SP)+,TRABLK+6
	INCB	STRA
	INCB	TRAF
	BR	LINK04
;	NUMBER

LINK09:	.O2BIN	2(R1)		;CONVERT OCTAL
	MOV	(SP),TRA
	ASR	(SP)+
	BCC	.+4
	ERR19
	INCB	FTRA
	INCB	TRAF
	BR	LINK04
LINK08:	TSTB	PASS		;IGNORE ON PASS 2
	BNE	LINK11
	INCB	UTRA
	BR	LINK11
;
;	/D- DEBUG FILE
;
LINK65:	INCB	ODTF
	TSTB	PASS
	BNE	LINK11
	NOVAL
	INCB	DDTF
	BR	LINK11

;
;  PROCESSING FOR POST SWITCHES
;
;  DISPATCH TABLE
;
POSTSW:	.BYTE	'E,0		;EXIT
	+LINK12
	.BYTE	'U,0		;UNDEFINES
	+LINK10
	.BYTE	'G,'O		;GO
	+LNK195
	.WORD	0		; PRESWITCH
	+LINK02
	-1			;END OF TABLE
;
;  U SWITCH- LIST UNDEFINES
;
LINK10:	NOVAL
	MOV	R0,-(SP)	;SAVE R0,R1
	MOV	R1,-(SP)
	MOV	SYME,R0
	MOV	R0,R1
	CMP	USYME,R0	;ANY UNDEFINES?
	BEQ	LINK03		;NO-
	JSR	PC,LINK14	;YES- GO PRINT THEM
LINK03:	MOV	(SP)+,R1
	MOV	(SP)+,R0
	JMP	LINK02		;EXIT
;
;  USE PART OF PMAP TO PRINT UNDEFINES
;
LINK14:	INCB	PMAP11
	SAVREG
	MOV	#PMAP84,R0	;PRINT HEADING
	TYPE
	MOV	R1,R0		;GET PTR TO END OF SYMBOLS
	.IFNDF	NOSEG
	CONTRL
	.WORD	7		;OVERLAY #7
	JMP	ENTRY2
	.ENDC

	.IFDF	NOSEG
	JMP	PMAP10
	.ENDC
;
;	GO
;
LNK195:	INCB	GOF		;SET GO FLAG


;
;	E SWITCH-FORCE UNDEFINES TO 0 AND PROCEED TO PASS 2.
;
LINK12:	NOVAL
	TST	(SP)+		;IGNORE RETURN ADDRESS
	TSTB	PASS
	BNE	LNK07		;SPECIAL ACTION ON PASS 2
	.IFNDF	NOSEG
	CONTRL
	.WORD	4
	JMP	ENTRY1
	.ENDC
	.IFDF	NOSEG
	JMP	LINK13
	.ENDC
LNK07:
	.IFNDF	NOSEG
	CONTRL
	.WORD	9.		;OVERLAY #9
	JMP	ENTRY1
	.ENDC
	.IFDF	NOSEG
	JMP	DONE
	.ENDC
	.IFNDF	NOSEG
	CONTRL
	.WORD	4		;OVERLAY #4
	JMP	ENTRY1
	.ENDC
	.IFDF	NOSEG
	JMP	LINK13
	.ENDC
EXOVL4:	TSTB	MAPF		;WANT A MAP
	BEQ	.+4		;NO
	PMAP			;PRINT IT

;	DON'T PRINT IF A MAP WAS PRINTED
	TSTB	MAPF
	BNE	OUTPST
	.IFDF	RTH		;BRTH15
	TSTB	RTF
	BEQ	.+10
	MOV	#RTHB,R0
	TYPE
	.ENDC			;ERTH15
	MOV	#TRAM,R0
	TYPE

OUTPST:	TSTB	SYMTAB		;IS SYMBOL TABLE TO BE OUTPUT?
	BEQ	LINK29		;NO -
	MOV	#STBER,STBADR-4	;SETUP ERR RET
	.INIT	#STBDEV		;INIT SYMTAB OUTPUT
	TST	STBADR+4
	BNE	.+10
	MOV	#0,STBADR+4
	.=.-4
	.RAD50	/STB/
	.=.+2
	.DELET	#STBDEV,#STBADR
STBER:	CLR	STBADR-4
	INCB	STBOPF		;OPEN SYMTAB FILE
	TST	STBADR+4
	BNE	.+10
	MOV	#0,STBADR+4
	.=.-4
	.RAD50	/STB/
	.=.+2
	.OPEN	#STBDEV,#STBADR
OUTBL=OUTB-OUTA
	IOOI
	MOV	SYMB,R2		;SET UP SYMTAB POINTER.
	CMP	R2,SYME		;ANYTHING TO OUTPUT?
	BHIS	LINK28		;NO -
LNK148:	MOV	#9.,(R1)+	;PUT SYMTAB CODE
	INC	(R0)
	INC	(R0)		;INCREMENT BC

LNK149:	MOV	(R2)+,(R1)+	;MOVE ENTRY FROM
	MOV	(R2)+,(R1)+	;SYMTAB TO OUTPUT
	MOV	(R2)+,(R1)+	; BUFFER
	MOV	(R2)+,(R1)+
	MOV	(R2)+,(R1)+
	ADD	#BPSYM,(R0)	;UPDATE BC
	MOV	(R0),-(SP)
	ADD	#BPSYM,(SP)	;IS COUNT + 10 <
	CMP	(SP)+,#172	;BUFFER LENGTH?
	BHI	LNK158		;YES -
	MOV	R2,-(SP)	;NO - IS CUMMULATING
	ADD	#BPSYM,(SP)	;COUNT + 10 < SYME?
	CMP	(SP)+,SYME
	BHI	.+4		;YES - GO TO OUTPUT BUFFER
	BR	LNK149		;NO - GO TO MOVE NEXT EXTRY
LNK158:	IOOP			;OUTPUT A BUFFER OF SYMTAB
	TSTB	IOOPER		;CHECK FOR OUTPUT ERROR
	BEQ	.+6
	JMP	LINK25
	MOV	R2,-(SP)	;IS CUMMULATIVE COUNT
	ADD	#BPSYM,(SP)	;+10. > SYME?
	CMP	(SP)+,SYME
	BLOS	LNK148		;NO - GO TO START TO FILL NEXT BUF
	MOV	LOWADR,-(SP)
	SUB	#2,(SP)
	MOV	#9.,(R1)+	;OUTPUT THE DEFAULT TOP
	ADD	#4,(R0)		;OF MEM AS THE LAST BLOCK
				;OF THE SYMBOL TABLE
	MOV	(SP)+,(R1)+
	IOOP
	TSTB	IOOPER
	BEQ	.+6
	JMP	LINK25
	MOV	#10.,(R1)+	;YES - PUT SYMTAB END CODE
	INC	(R0)
	INC	(R0)
	IOOP			;OUTPUT LAST BUFFER
	TSTB	IOOPER
	BEQ	.+6
	JMP	LINK25
;
;CLOSE SYMBOL TABLE FILE AND RELEASE DATA SET.
;
LINK28:	MOV	#STBDEV,-(SP)
	MOV	(SP),-(SP)
	EMT	CLOSE
	EMT	RELEASE
	CLRB	STBOPF
	CLRB	SYMTAB

LINK29:	TSTB	BELOW0
	BEQ	.+4
	ERR22
	INCB	PASS
	CLRB	FLINE		;BACK TO FIRST LINE
	.IFNDF	NOSEG		;OF CSI INPUT
	CONTRL
	.WORD	1		;OVERLAY #1
	JMP	ENTRY1
	.ENDC
	.IFDF	NOSEG
	JMP	START1
	.ENDC

;
;	LOAD MODULE OUTPUT ERROR--DIE
;
LINK25:	MOVB	IOOPER,HBYTE
	MOV	#CONVER,R0
	INCB	NOTINP
	ERR15

;
;	TRAP HANDLER AND JUMP TABLE
;
TRAPH:	MOV	@SP,2(SP)	;STACK RTN ADDRESS.
	SUB	#2,@SP		;FORM ADR OF TRAP INSTRUCTION
	MOV	@(SP)+,-(SP)	;GET TRAP INSTRUCTION.
	BIT	#1,(SP)		;ERROR DIAGNOSTIC?
	BNE	ERRMSG		;YES
	ADD	#JTABLE-TRAP,@SP	;GET TABLE INDEX.
	MOV	@(SP)+,PC	;GO TO SUBROUTINE.
ERRMSG:	SUB	#TRAP+1,(SP)	;GET TABLE POSITION
	CMP	(SP),#BIGMSG	;IS THIS A SPECIAL?
	BHI	1$		;YES
	ASL	(SP)		;TIMES TWO
	ADD	#MSGTAB,(SP)	;ADD START ADDRESS OF TABLE
3$:	CLR	-(SP)		;ISSUE
	MOV	@2(SP),-(SP)	;THE MESSAGE
	IOT
	ADD	#2,(SP)		;POINT TO DISPATCH ADDRESS
	TST	@(SP)		;IS IT A SIMPLE RETURN?
	BNE	2$		;NO
	TST	(SP)+
	RTS	PC		;YES

2$:	MOV	@(SP)+,-(SP)	;GET THE ROUTINE ADDRESS
	JMP	@(SP)+		;GO WHERE THE USER WANTS
1$:	ADD	#BIGTAB-BIGMSG-1,(SP) ;GET ACTUAL ADDRESS
	BR	2$		;GO TO THE ROUTINE
;
;	JUMP TABLE
;
JTABLE:	JT:
UNPACK=.-JT+TRAP			;MOD40 UNPACK
	.WORD	UNPA00
OTOA=.-JT+TRAP			;OCTAL TO ASCII CONVERRSION
	.WORD	OTOA00
SAVREG=.-JT+TRAP			;SAVE REGISTERS
	.WORD	SAVR00
RESREG=.-JT+TRAP			;RESTORE REGISTERS
	.WORD	RESR00
TXTPUT=.-JT+TRAP			;PUT INTO TXT BLOCK
	.WORD	TXTP00
GETPC=.-JT+TRAP			;GET CURRENT PC VALUE
	.WORD	GETP00
TYPE=.-JT+TRAP			;TYPE A BUFFER ON TTY
	.WORD	TYPE00
SQUISH=.-JT+TRAP			;REMOVE WORDS FROM TABLE
	.WORD	SQUI00
UNSQUISH=.-JT+TRAP			;MAKE A HOLE IN TABLE
	.WORD	UNSQ00
PMAP=.-JT+TRAP			;PRINT LOAD MAP
	.WORD	PMAP00
MAPTYP=.-JT+TRAP		;TYPE ON MAP DEVICE
	.WORD	MAPT00
IOII=.-JT+TRAP			;OBJ MODULE INPUT INIT.
	.WORD	IOII00
IOIG=.-JT+TRAP			;OBJ MODULE INPUT GET
	.WORD	IOIG00
IOIC=.-JT+TRAP			;OBJ MODULE INPUT CLOSE AND RELEASE
	.WORD	IOIC00
IOOI=.-JT+TRAP			;LOAD MODULE OUTPUT INIT
	.WORD	IOOI00
IOOP=.-JT+TRAP			;LOAD MODULE OUTPUT PUT.
	.WORD	IOOP00
GGSD=.-JT+TRAP			;GET GSD
	.WORD	GGSD00
GNGSD=.-JT+TRAP			;GET NON-GSD BLOCK.
	.WORD	GNGS00
SRGLOB=.-JT+TRAP			;GET VALUE OF GLOBAL
	.WORD	SRGL00
PTGLOB=.-JT+TRAP			;GET PTR TO GLOBAL
	.WORD	PTGL00
INSYME=.-JT+TRAP			;INSERT AT SYME
	.WORD	INSY00
SRMODN=.-JT+TRAP			;SEARCH FOR MODULE NAME
	.WORD	SRMO00
INUSYM=.-JT+TRAP			;INSERT UNDEFINED SYMBOL
	.WORD	INUS00
SYMOVF=.-JT+TRAP			;CHECK FOR SYMBOL OVERFLOW (FATAL)
	.WORD	SYMO00
GETSEC=.-JT+TRAP			;GET SECTION NAME POINTER

	.WORD	GETS00
SWSR=.-JT+TRAP		;SWITCH SEARCH
	.WORD	SWSR00
INPTRH=.-JT+TRAP	;INSERT AT PTRH
	.WORD	INPT00
DIRSR=.-JT+TRAP		;DIRECTORY SEARCH
	.WORD	DIRS00
MOVTAB=.-JT+TRAP
	.WORD	MOVT00
NOVAL=.-JT+TRAP
	.WORD	NOV00
ONEVAL=.-JT+TRAP
	.WORD	ONEV00
READER=.-JT+TRAP
	.WORD	READ00
	.IFNDF	NOSEG
CONTRL=.-JT+TRAP		;RUN TIME OVERLAY CONTROLLER.
	.WORD	SUBR46
	.ENDC
	.IFDF	RTH		;BRTH23
RTVALS=.-JT+TRAP		;CONVERTS AND SAVES
	.WORD	RTVA00		;VALUES OF /RT SW
CONSAV=.-JT+TRAP		;CONVERTS & SAVES
	.WORD	CONS00		;VALUES OF SWITCHES.
	.ENDC			;ERTH23

;
;ERROR MESSAGE PROTOTYPES GO HERE
;
ERR02=TRAP+1
ERR03=ERR02+2
ERR04=ERR03+2
ERR06=ERR04+2
ERR07=ERR06+2
ERR09=ERR07+2
ERR10=ERR09+2
ERR11=ERR10+2
ERR12=ERR11+2
ERR13=ERR12+2
ERR14=ERR13+2
ERR16=ERR14+2
ERR17=ERR16+2
ERR18=ERR17+2
ERR19=ERR18+2
ERR20=ERR19+2
ERR22=ERR20+2
ERR23=ERR22+2
ERR24=ERR23+2
ERR25=ERR24+2
ERR26=ERR25+2
ERR27=ERR26+2
ERR28=ERR27+2
;
;THE FOLLOWING MESSAGES HAVE SPECIAL HANDLING
;
BIGMSG=ERR28-TRAP
ERR01=BIGMSG+TRAP+2

ERR05=ERR01+2
ERR08=ERR05+2
ERR15=ERR08+2
ERR21=ERR15+2
;
;THE TABLE MSGTAB MUST PARALLEL THE ERROR TABLE EXACTLY IN ORDER
;
MSGTAB:
	2243,LINK	;2
	2213,ERMF	;3-NO GSD
	2214,ERMF	;4-FIRST IN GSD NOT OBJ MOD. NAME
	1324,0		;6-TOO MANY CSECT ENTRIES
	2210,ERMF	;7-SYMBOL TABLE ERROR
	2211,ERMF	;9-GLOBAL SEARCH FAILURE IN RLD
	2212,ERMF	;10-PC MOD NOT LAST IN RLD
	2215,ERMF	;11-CAN'T FIND SECTION NAME
	2216,LINK	;12-CAN'T FIND TRA
	2217,LINK	;13-CAN'T FIND SECTION FOR TRA
	2220,LINK	;14-JUMP INDEX OUT OF RANGE
	2226,LINK	;16-BAD SYNTAX IN CSI LINE
	2206,LINK	;17-MISSING INPUT SPEC
	2223,LINK	;18-NO ROOM IN CSI BUFFER
	2203,LINK	;19-TOO MANY SWITCHES
	2204,LINK	;20
	2205,LINK	;22
	1322,0		;23
	2250,LINK	;24-BAD CORE LIB. POSITION
	2253,LINK	;25-CATCH ALL
	1323,0		;26-CSECT TOO LARGE
	1325,0		;27-BAD RTH
	2255,LINK	;28-

BIGTAB:	ER0100		;1-SYMBOL OVERFLOW
	ER0500		;5-MODULE NAME NOT UNIQUE
	ER0800		;8
	ER1500		;15
	.IFNDF	RSX
	ER2100		;21
	.ENDC
	.EOT




;TAPE 6
RDEOT:	TSTB	TAPES		;PAPER TAPE LIBRARY?
	BEQ	CLREL		;NO-GO TO CLOSE & RELEASE
REREAD:	IOIG			;YES-READ UNTIL EOT.
	.IFNDF	BLKIO
	.WAIT	#OBJDEV
	.ENDC
	BITB	#EOF,-1(R0)	;END OF TAPE?
	BEQ	REREAD		;NO-KEEP ON READING
CLREL:	RTS	R5		;YES-CLOSE & RELEASE OBJ DEV
MOVT00:	SAVREG
	MOV	ENDM,D1


	SUB	USYME,D1


	MOV	USYME,D2


	SUB	SP,D2

	MOV	USYME,R4
	MOV	R4,R0
	MOV	D1,R1
	ADD	R1,R0		;R0 CONTAINS NEW USYME
	ASR	R1		;INCREMENTS IN WORDS
	MOV	D2,R2
	ASR	R2
	BGT	LINK87		;DONE?
LINK88:	ASL	R1		;YES-
	ADD	R1,SP
	ADD	R1,SB
	;
	;	RESET STACK BASE TO NEW VALUE
	;	IN THE MONITOR SYSTEM VECTOR TABLE
	;
	MOV	SB,-(SP)	;NEW STACK BASE ON THE STACK
	MOV	#4,-(SP)	;REQUEST CODE
	EMT	GUT		;EMT CALL
	TST	(SP)+		;CLEAN RETURN VALUE FROM STACK
	;
	;
	ADD	R1,SSYMB
	ADD	R1,SASYME
	ADD	R1,SYMB
	ADD	R1,SYMC
	ADD	R1,SYME
	ADD	R1,SSYME

	ADD	R1,USYME
	ADD	R1,PTRG
	ADD	R1,PTRH
	.IFDF	RTH		;BRTH16
	ADD	R1,RTHPTR
	.ENDC			;ERTH16
	BR	LNK132
LNK138:	RESREG
	RTS	PC
LINK87:	MOV	-(R4),-(R0)	;NO-
	DEC	R2
	BGT	LINK87
	BR	LINK88
ERRET1:	CMP	#401,OBJADR+6
	BNE	.+14
	CLR	OBJADR-4
	CLR	OBJADR+6
	BR	LNK144
	MOV	#401,OBJADR+6
	BR	LNK144
LNK132:	TSTB	FLAG
	BNE	LNK138
	.IFDF	BLKIO
	JSR	PC,INITRD
	.ENDC
	.IFNDF	BLKIO
	.INIT	#OBJDEV
	.ENDC
	JSR	PC,DEVCH
	TSTB	ODTF
	BNE	LNK192
	TSTB	LIBF
	BEQ	LNK143
LNK192:	MOV	#ERRET1,OBJADR-4
	TST	OBJADR
	BNE	LNK143
	MOV	#57164,OBJADR

LNK143:	TST	OBJADR+4
	BNE	.+10
	MOV	#0,OBJADR+4
	.=.-4
	.RAD50	/OBJ/
	.=.+2
LNK144:
	.IFDF	BLKIO
	JSR	PC,OPENRD
	.ENDC
	.IFNDF	BLKIO
	.OPEN	#OBJDEV,#OBJADR
	.ENDC
	CLR	OBJADR-4
	CLRB	ODTF
	MOV	#102,-(SP)
	EMT	FMS
	MOV	(SP)+,MONTOP
	ADD	#SPLEN,MONTOP
	MOV	SP,D1
	SUB	MONTOP,D1	;MON CHECKED FOR OVF ALREADY
	.IFNDF	RSX		;BRSX
	SUB	#1000,D1	;ALLOW FOR FILE MANAGER
	.ENDC			;ERSX
	BHIS	LINK34		;AT CLOSE TIME
	ERR18			;NO SPACE FOR FILE MANAGER
LINK34:	MOV	SP,R4
	MOV	R4,R0
	MOV	D1,R1
	SUB	R1,R0
	SUB	R1,SP
	SUB	R1,SB
	;
	;	RESET STACK BASE TO NEW VALUE
	;	IN THE MONITOR SYSTEM VECTOR TABLE
	;
	MOV	SB,-(SP)	;NEW STACK BASE ON THE STACK
	MOV	#4,-(SP)	;REQUEST CODE
	EMT	GUT		;EMT CALL
	TST	(SP)+		;CLEAR RETURN VALUE FROM STACK
	;
	;
	SUB	R1,SSYMB
	SUB	R1,SASYME
	SUB	R1,SYMB
	SUB	R1,SYMC
	SUB	R1,SYME

	SUB	R1,USYME
	SUB	R1,PTRG
	SUB	R1,PTRH
	.IFDF	RTH		;BRTH17
	SUB	R1,RTHPTR
	.ENDC			;ERTH17
	ASR	R1
	MOV	D2,R2
	ASR	R2
	BLE	LNK134
LNK133:	MOV	(R4)+,(R0)+
	DEC	R2
	BGT	LNK133
LNK134:	RESREG
	RTS	PC

;
;	TEST FOR NO VALUE
;
NOV00:	CMP	(R1),#1
	BR	VALUE
;
;	TEST FOR ONE VALUE
;
ONEV00:	CMP	(R1),#2
VALUE:	BEQ	.+4
	ERR19
	RTS	PC
;
;	READ ERROR CHECK
;
READ00:	MOVB	-1(R0),-(SP)
	BIC	#-3-1,(SP)+
	BEQ	.+4
	ERR15
	BITB	#EOF,-1(R0)	;ERROR?
	BEQ	.+4
	ERR15			;YES -
	RTS	PC		;NO -
;
;	IO EXEC FOR OBJ MODULE AND LOAD MODULE
;
;
;	INPUT INIT
;
	INBLN=INB-INA

IOII00:
	MOV	#INA,IN		;SET INPUT BUFFER POINTER
;
;	INITIALIZE OBJECT MODULE DATA SET
;
	.IFDF	BLKIO
	JSR	PC,INITRD
	.ENDC
	.IFNDF	BLKIO
	.INIT	#OBJDEV
	.ENDC
	JSR	PC,DEVCH
;
;	OPEN OBJECT MODULE FILE
;
	TSTB	ODTF
	BEQ	LNK147
	MOV	#ERRET2,OBJADR-4
	TST	OBJADR
	BNE	LNK147
	MOV	#57164,OBJADR
LNK147:	TST	OBJADR+4
	BNE	.+10
	MOV	#0,OBJADR+4	;SET DEFAULT EXTENSION
	.=.-4
	.RAD50	/OBJ/
	.=.+2
LNK146:
	.IFDF	BLKIO
	JSR	PC,OPENRD
	.ENDC
	.IFNDF	BLKIO
	.OPEN	#OBJDEV,#OBJADR
	.ENDC
	CLR	OBJADR-4
	CLRB	ODTF
	.IFDF	BLKIO
	JSR	PC,READIT
	.ENDC
	.IFNDF	BLKIO
	.READ	#OBJDEV,#INA	;START FIRST READ
	.ENDC
	BR	IOIG00

ERRET2:	CMP	#401,OBJADR+6
	BNE	.+14
	CLR	OBJADR-4
	CLR	OBJADR+6
	BR	LNK146
	MOV	#401,OBJADR+6
	BR	LNK146

;
;	INPUT GET
;
IOIG00:	MOV	R2,-(SP)	;SAVE R2
	MOV	IN,R2		;GET BUFFER POINTER
	MOV	R2,R0
	CMP	(R0)+,(R0)+	;SET R0 = IN+4
	MOV	R0,R1
	TST	(R1)+		;SET R1=IN+6
	ADD	#INBLN,R2	;ADVANCE POINTER TO NEXT BUFFER.
	CMP	R2,#INB		;TOO FAR?
	BLOS	IOIG01		;NO
	MOV	#INA,R2		;READ INTO INA
IOIG01:	MOV	R2,IN		;READ INTO INB
	.IFDF	BLKIO
	JSR	PC,XXREAD
	.ENDC
	.IFNDF	BLKIO
	.READ	#OBJDEV,R2
	.ENDC

	MOVB	-1(R0),R2	;GET LAST STATUS
	BIC	#-47-1,R2	;SAVE LOW 3 BITS, AND BIT 5
	BEQ	.+4
	ERR15
	MOV	(SP)+,R2	;RESTORE R2
	RTS	PC


;
;	SUBROUTINE IOIC
;
;	CLOSE INPUT FILE AND RELEASE INPUT DEVICE
;
;	CLOSE INPUT FILE
IOIC00:
	.IFDF	BLKIO
	JSR	PC,CLOSRD
	.ENDC
	.IFNDF	BLKIO
	MOV	#OBJDEV,-(SP)

	MOV	(SP),-(SP)
	EMT	CLOSE
;
;	RELEASE INPUT DEVICE
;
	EMT	RELEAS
	.ENDC
	RTS	PC

;
;	OUTPUT INIT
;
IOOI00:	CLRB	OUTB+3
IOOI02:	MOV	#OUTA,R0	;SET OUTPUT POINTER
	MOV	R0,OUT
IOOI01:	CMP	(R0)+,(R0)+	;R0=OUT+4
	CLR	(R0)		;INITIALIZE BC
	MOV	R0,R1
	TST	(R1)+		;R1=OUT+6
	TSTB	SYMTAB		;WHAT TO OUTPUT NEXT?
	BEQ	LNK161		;LOAD MODULE-
	MOV	STBDEV+6,TEST	;SYMTAB - PREPARE TO
	MOV	#STBDEV,PUT	;OUTPUT SYMTAB
	BR	LNK162
LNK161:	MOV	LODDEV+6,TEST	;PREPARE TO OUTPUT
	MOV	#LODDEV,PUT	;LOAD MODULE
LNK162:	RTS	PC
;
;	OUTPUT PUT
;

IOOP00:	MOV	OUT,R0		;GET PTR TO CURRENT BUFFER
	CLRB	IOOPER
	CMP	R0,#OUTA	;BUFFER A?
	BEQ	IOOP01
	TST	TEST		;ANY OUTPUT?
	BEQ	IOOP02		;NO--
	.WRITE	PUT,#OUTB
	MOVB	OUTA+3,IOOPER
	BR	IOOP02
IOOP01:	TST	TEST		;ANY OUTPUT?
	BEQ	IOOP02		;NO--
	.WRITE	PUT,#OUTA
	MOVB	OUTB+3,IOOPER
IOOP02:	BICB	#-147-1,IOOPER ;SAVE BITS 0,1,2,5,6
	ADD	#OUTBL,R0	;ADVANCE TO NEXT BUFFER
	MOV	R0,OUT
	CMP	R0,#OUTB	;TOO FAR
	BLOS	IOOI01		;NO
	BR	IOOI02		;YES


;
;	GNGSD--GET NON GSD BLOCK
;
GNGS00:	IOIG
	CMPB	#GSDBLK,(R1)	;GSD BLOCK?
	BEQ	GNGS00		;YES - IGNORE
	RTS	PC		;ELSE - EXIT.

;
;RESIDENT READ GSD
GGSD00:	.IFNDF	NOSEG
	CONTRL
	.WORD	5		;OVERLAY #5
	JMP	ENTRY1
	.ENDC

	.IFDF	NOSEG
	JMP	START5
	.ENDC


;
;	RESIDENT PRINT LOAD MAP
PMAP00:	.IFNDF	NOSEG
	CONTRL
	.WORD	7
	JMP	ENTRY1
	.ENDC

	.IFDF	NOSEG
	JMP	START7
	.ENDC

;
;	SWITCH SEARCH ROUTINE
;
;	INPUT-R0=ADR OF DISPATCH TABLE
;	     -R1=ADR OF SWITCH HEAD TO SEARCH FOR
;	OUTPUT-R0=ADR OF SWITCH ROUTINE. IF CAN'T FIND THE SWITCH,
;	          RETURN R0=0.
;
SWSR00:	SAVREG
	MOV	(R1),-(SP)
	ASL	(SP)		; SWITCH CHARACTERS
	ADD	(SP)+,R1
	CLR	(SP)		;INITIAL CLEAR OF SAVED R0
SWSR02:	CMP	(R1),(R0)+	;IS IT THIS ONE?
	BEQ	SWSR01		;YES-
	TST	(R0)+		;NO-SKIP ADR
	TST	(R0)		;END OF TABLE?
	BPL	SWSR02		;NO-
SWSR03:	RESREG		;YES-EXIT
	RTS	PC

SWSR01:	MOV	(R0),(SP)	;SET SAVED R0 TO ADDRESS
	BR	SWSR03		;  OF HANDLER & EXIT.

;
;	SAVE	REGISTERS
;

SAVR00:	MOV	R5,-(SP)	;SAVE THEM
	MOV	R4,-(SP)
	MOV	R3,-(SP)
	MOV	R2,-(SP)
	MOV	R1,-(SP)
	MOV	R0,-(SP)
	JMP	@12.(SP)	;EXIT.
;
;	RESTORE REGISTERS
;

RESR00:	MOV	(SP)+,12.(SP)	;STACK RETURN ADDRESS
	MOV	(SP)+,R0	;RESTORE THEM
	MOV	(SP)+,R1
	MOV	(SP)+,R2
	MOV	(SP)+,R3
	MOV	(SP)+,R4
	MOV	(SP)+,R5
	RTS	PC		;EXIT
;SUBROUTINE OTOA (OCTAL TO ASCII CONVERSION)
;	ASSUMES	1)  NUMBER IN REGISTER ON ENTRY(R0)
;		2)  BUFFER STORAGE REQD. PTR SET (R1)
;		3)  STACK TOP RATHER THAN 3RD REG.
;	ON EXIT:    CONVERSION IN BUFFER, PTR AT NEXT BYTE
;		    NUMBER REGISTER CLEARED
;		    TOP OF STACK CLEAN
;
OTOA00:	MOV	#2230,-(SP)	;SET LP CNT & 1ST DIG BITS
OTOA01:	ASL	R0		;GET BIT FROM NUMBER...
	ROLB	@SP		;...& MOVE INTO ASCII DIGIT
	BCC	OTOA01		;MARKER OUT AT OTHER END?
	MOVB	@SP,(R1)+	;IF SO STORE CHAR IN BUFFER
	MOVB	#23,@SP
	ASL	@SP		;DONE 6 DIGITS?
	BCC	OTOA01
	TST	(SP)+		;YES-CLEAN UP STACK
	RTS	PC		;... & EXIT
;
;	RESIDENT LIBRARY SEARCH ROUTINE
DIRS00:	.IFNDF	NOSEG
	CONTRL
	.WORD	6		;OVERLAY #6
	JMP	ENTRY1
	.ENDC

	.IFDF	NOSEG
	JMP	START6
	.ENDC


;
;	MOD40 UNPACK
;
;	INPUT:	R0=ADR OF MOD40 NUMBER (2 WORDS)
;		R1=ADR OF ASCII STRING (6 BYTES)
;
;	OUTPUT:	R1 POINTS ONE PAST LAST GENERATED CHARACTER
;
;
;	IF N IS THE MOD40 NUMBER, THEN
;		N=C1*50^2+C2*50+C3
;	THUS, N/50^2 IS C1 AND THE REMAINDER IS C2*50+C3
;	THE REMAINDER IS DIVIDED BY 50 TO GET C2 ETC.
;
UNPA00:	SAVREG
	MOV	#-2,R4		;MAJOR LOOP COUNT
UNPA07:	MOV	#-3,R5		;MINOR LOOP COUNT
	MOV	(R0),R0		;GET MOD40 WORD
	MOV	#COEFF,R2	;PTR TO COEFFICIENT TABLE
UNPA06:	CLR	R3		;0 QUOTIENT
;	DIVIDE BY COEFFICIENTS

UNPA02:	CMP	R0,(R2)	;DONE WITH DIVIDE
	BLO	UNPA01		;YES
	SUB	(R2),R0		;NO-SUBTRACT COEFF.
	INC	R3		;ADD 1 TO QUOTIENT
	BR	UNPA02
;	DIVIDE DONE.  QUOT IN R3, REMAINDER IN R0
;	CONVERT TO AN ASCII CHARACTER

UNPA01:	TSTB	R3
	BEQ	UNPA03		;"BLANK"
	CMPB	R3,#33
	BEQ	UNPA05		;"$"
	BGT	UNPA04		;"." OR "0-9"
	ADD	#40,R3		;"A-Z"
UNPA03:	ADD	#16,R3
UNPA04:	ADD	#11,R3
UNPA05:	ADD	#11,R3
	MOVB	R3,(R1)+	;STORE CHARACTER
	TST	(R2)+		;ADVANCE TO NEXT COEFF.
	INC	R5		;DONE 3 CHARS?
	BLT	UNPA06		;NO-DO MORE
	MOV	(SP),R0		;RESTORE ORIGINAL R0 AND
	TST	(R0)+		;MOVE TO NEXT WORD

	INC	R4		;DONE 2 WORDS
	BLT	UNPA07		;NO

;	DONE--PUT CURRENT R1 ONTO THE STACK
	MOV	R1,2(SP)
	RESREG
	RTS	PC
;
;	COEFFICIENT TABLE
;
COEFF:	+1600.			;40.^2
	+40.			;40.^1
	+1.			;40.^0


;
;	SUBROUTINE TXTPUT
;
;	PUT INFO INTO TXT BLOCK
;	THE RLD COMMAND IS STACKED
;
;		THIS ROUTINE REMOVES 1 WORD
;		FROM THE STACK,SP

TXTP00:	TST	2(SP)		;BYTE OR WORD COMMAND
	BMI	TXTP01		;GO IF BYTE COMMAND.
	MOVB	R4,(R3)+	;PUT IN FIRST BYTE
	SWAB	R4		;PREPARE FOR SECOND BYTE.
TXTP01:	MOVB	R4,(R3)+	;PUT IN BYTE
	TST	2(SP)		;BYTE OR WORD?
	BPL	TXTP02		;WORD
	SWAB	R4
	BEQ	TXTP02		;OK.
	ERR08			; BYTE RELOC ERROR!
TXTP02:  
	MOV	(SP)+,(SP)	;MOVE RETURN ADDRESS DOWN
	RTS	PC		;RETURN

;
;	SUBROUTINE GETPC
;	GET PC FOR CURRENT PLACE IN TXT BLOCK
;
GETP00:	MOV	CURPC,R4	;GET PC AT ENTRY TO BLOCK
	ADD	OFFSET,R4	;ADD CURRENT PLACE.
	RTS	PC

;
;	SYMOVF---SYMBOL TABLE OVERFLOW CHECK
;
SYMO00:	MOV	ENDM,-(SP)
	SUB	#BPSYM,(SP)
	CMP	USYME,(SP)+

	BLO	SYMO01
	ERR01			;DIE!!
SYMO01:	RTS	PC		;OK.

;
;	SRMODN---SEARCH FOR A MODULE NAME.
;
;	INPUT:	R4 POINTS TO MOD4O NAME
;	OUTPUT: R4 POINTS TO THE NAME IF FOUND
;
;	CALL:	SRMODN
;		BR		;FOUND
;		BR		;NOT FOUND
;
SRMO00:	SAVREG	
	MOV	SYMB,R0		;GET POINTER TO START OF TABLE
SRMO01:	CMP	R0,SYME		;DONE
	BLO	SRMO02		;NO
	RESREG			;YES - NOT FOUND
	ADD	#2,(SP)		;ADJUST RETURN ADDRESS
	RTS	PC		;EXIT
SRMO02:	CMPB	#OBJMN,FLAGS+1(R0) ;IS THIS AN OBJ MODULE NAME?
	BEQ	SRMO03		;YES - SEE IF NAME IS SAME
SRMO04:	ADD	#BPSYM,R0	;NO - TRY NEXT ONE
	BR	SRMO01
SRMO03:	CMP	(R4),(R0)	;FIRST WORD OK?
	BNE	SRMO04		;NO - GO TO NEXT ENTRY
	CMP	2(R4),2(R0)	;SECOND WORD OK?
	BNE	SRMO04		;NO - GO TO NEXT ENTRY
;	FOUND!!
	MOV	R0,8.(SP)	;PUT CURRENT R0 ONTO STACK
	RESREG
	RTS	PC

;
;	PTGLOB---SEARCH FOR GLOBAL & RETURN A POINTER TO IT.
;
;	INPUT:  R4=POINTER TO NAME
;	OUTPUT:  R4=POINTER TO ENTRY IF FOUND.
;
;	CALL	PTGLOB
;
;		BR		;NOT FOUND
;		BR		;FOUND

PTGL00:	SAVREG
	MOV	(R4),R0		;IS THIS THE SPECIAL
	BIS	2(R4),R0	;CASE OF 6 BLANKS?
	BEQ	PTGL01		;YES
	MOV	SYMB,R0		;SET LIMITS FOR SEARCH
	BR	PTGL02
PTGL01:	MOV	PTRG,R0		;START AT CURRENT OBJ MODULE IF 6 BLANKS
PTGL02:	CMP	R0,USYME	;DONE SEARCHING
	BLO	PTGL03		;NO-
	RESREG			;YES - EXIT
	RTS	PC
PTGL03:	CMP	(R4),(R0)	;CHECK FIRST WORD
	BNE	PTGL04		;NO MATCH.
	CMP	2(R4),2(R0)	;TRY SECOND WORD
	BNE	PTGL04		;NO MATCH.
;	MATCH---
	CMPB	#OBJMN,FLAGS+1(R0) ;FILTER OUT OBJ MODULE NAMES.
	BEQ	PTGL04
	MOV	R0,8.(SP)
	RESREG
	ADD	#2,(SP)
	RTS	PC
;	NO MATCH--
PTGL04:	ADD	#BPSYM,R0	;ADVANCE R0 TO NEXT ENTRY
	BR	PTGL02		;TRY AGAIN.
;
;	GETSEC--GET POINTER TO SECTION NAME.
;
;	INPUT:  R4 PTS TO NAME.
;	OUTPUT:  R4 PTS TO PROPER ENTRY
;
;	CALL:	GETSEC
;		BR		;NOT FOUND

;
GETS00:	PTGLOB			;FIND GLOBAL NAME
GETS01:	RTS	PC		;NOT FOUND.
;	FOUND, INSURE THAT IT IS A SECTION NAME.
	CMPB	#SECTN,FLAGS+1(R4)
	BEQ	GETS02
	CMPB	#LOCAL,FLAGS+1(R4)
	BNE	GETS01		;NOT A SECTION NAME
GETS02:	ADD	#2,(SP)		;SECT NAME. ADJUST RETURN
	RTS	PC
	.EOT


;	TAPE 7
;
;	SRGLOB---SEARCH FOR GLOBAL AND RETURN VALUE IN R4
;
;	INPUT:  R4=ADR OF GLOBAL NAME
;	OUTPUT:  R4=VALUE
;
;	CALL	SRGLOB
;		BR		;NOT FOUND
;
;
SRGL00:	PTGLOB			;GET POINTER TO GLOBAL
	RTS	PC		;NOT FOUND
	MOV	BASE(R4),R4	;FETCH VALUE
	ADD	#2,(SP)
	RTS	PC		;EXIT

;
;	INUSYM--INSERT AS UNDEFINED
;
;	INPUT:  R4=ADR OF WHAT TO INSERT INTO UNDEFINED AREA
;
;
INUS00:	MOV	R0,-(SP)	;STACK R0
	MOV	USYME,R0
	MOV	(R4)+,(R0)+	;MOVE IN THE UNDEFINED SYMBOL
	MOV	(R4)+,(R0)+
	MOV	(R4)+,(R0)+
	MOV	(R4)+,(R0)+
	ADD	#BPSYM,USYME
	SYMOVF			;OVERFLOW?
	MOV	(SP)+,R0
	RTS	PC
;
;	INSYME
;
;	INSERT AN ENTRY AT SYME.  R4 POINTS TO THE ENTRY.
;	ADJUST POINTERS SYME AND USYME
;
;

INSY00:	SAVREG
	MOV	R4,R2
	MOV	SYME,R4
INSY01:	UNSQUISH		;MAKE A HOLE AT SYME
	ADD	#BPSYM,SYME
	ADD	#BPSYM,USYME

	MOV	(R2)+,(R4)+	;MOVE IN THE SYMBOL
	MOV	(R2)+,(R4)+
	MOV	(R2)+,(R4)+
	MOV	(R2)+,(R4)+
	SYMOVF			;SYMBOL OVERFLOW?
	RESREG
	RTS	PC
;
;	INSERT AN ENTRY AT (PTRH)+BPSYM
;	INSERT THE ENTRY ALPHABETICALLY
;	R4 POINTS TO THE ENTRY
;	UPDATE POINTERS SYME,USYME
;
INPT00:	SAVREG
	MOV	R4,R2		;SET PTRS
	MOV	PTRH,R4
INPT01:	ADD	#BPSYM,R4	;START LOOP LOOKING FOR END OF SECTION
				;OR AN ENTRY WHICH IS>THEN PRESENT 
				;ENTRY
	CMP	R4,SYME		;CHECK FOR END OF SYMBOLS
	BHIS	INPT02
	CMPB	FLAGS+1(R4),#SYMN
	BNE	INPT02
	CMP	(R4),(R2)		;DOUBLE PREC COMP
	BHI	INPT02
	BLO	INPT01
	CMP	2(R4),2(R2)	;IF 1ST WORDS EQUAL,TRY 2ND WORDS
	BLOS	INPT01		;TRY AGAIN
;	INSERT AT (R4)
INPT02:	CMP	R4,PTRG	;UPDATE PTRG IF INSERTING BELOW PTRG
	BHI	.+10
	ADD	#BPSYM,PTRG
	BR	INSY01		;GO INSERT AT R4

;
;	UNSQUISH---MAKE A HOLE IN TABLE
;
;	INPUT:  R4 POINTS WHERE TO MAKE HOLE.
;


UNSQ00:	SAVREG
	MOV	USYME,R0	;SOURCE POINTER
	MOV	R0,R1
	ADD	#BPSYM,R1	;TEST POINTER
UNSQ01:	CMP	R0,R4		;DONE?
	BHI	UNSQ02		;NO
	RESREG
	RTS	PC
UNSQ02:	MOV	-(R0),-(R1)	;BLOCK MOVE
	MOV	-(R0),-(R1)
	MOV	-(R0),-(R1)
	MOV	-(R0),-(R1)
	MOV	-(R0),-(R1)
	BR	UNSQ01		;DO NEXT ONE.
;
;	SQUISH---REMOVE AN ENTRY FROM TABLE.
;
;	INPUT:  R4=ADR OF WHERE TO REMOVE ENTRY
;

SQUI00:	SAVREG
	MOV	R4,R0
	MOV	#BPSYM,R1
	ADD	R1,R0
	ASR	R1
SQUI01:	CMP	R0,USYME	;DONE
	BLO	SQUI02		;NO--
	RESREG			;YES-EXIT
	RTS	PC
SQUI02:	MOV	R1,R2		;SET COUNTER = BPSYM/2
SQUI03:	MOV	(R0)+,(R4)+	;BLOCK TRANSFER
	DEC	R2
	BGT	SQUI03
	BR	SQUI01		;DO NEXT ONE.
;
;
;
;	COPY THE PHYSICAL DEVICE NAME
;	FROM THE MONITOR TO THE OBJDEV.
;	THIS WAY THE OBJDEV WILL BE CONSISTENT
;	WITH THE MONITOR IN CASE THE OBJDEV
;	WAS ASSIGNED TO A SPECIFIC PHYSICAL
;	DEVICE

DEVCH:
	.IFDF	BLKIO
	JSR	PC,READST
	.ENDC
	.IFNDF	BLKIO
	.STAT	#OBJDEV
	.ENDC
	TST	(SP)+
	MOV	(SP)+,OBJDEV+6
	TST	(SP)+
	RTS	PC

;	CANNED MESSAGES
LNKNM:	+LNKNMA-LNKNM-6		;<CRLF>LINK-11<CRLF>
	.BYTE	FASC,0
	+LNKNMA-LNKNM-6
	.ASCII	/LINK /
	VRSION
	.BYTE	CR,LF
LNKNMA:	.EVEN
;


;
;	BUFFER CONTAINING "#"
;
NO:	+NOA-NO-6		;  #
	.BYTE	FASC,0
	+NOA-NO-6
	.ASCII	/#/
	.BYTE	VT
NOA:	.EVEN

;
;	SYMBOL OVERFLOW - FATAL
;
ER0100:	SUB	#8.,R4		;PTR TO SYMBOL
	MOV	PTRG,R0		;ADR OF MODULE NAME
	MOV	#USMA,R1
	UNPACK			;UNPACK MODULE NAME
	MOV	R4,R0
	MOV	#USMB,R1
	UNPACK			;UNPACK SYMBOL NAME
	MOV	#USM,R0
	TYPE			;TYPE MESSAGE
	ERR18		;RESTART

ERMF:	MOV	#OBJADR,R0
	MOV	#ERFILA,R1
	UNPACK
	MOV	OBJADR+4,CONVER
	CLR	CONVER+2
	MOV	#CONVER,R0
	MOV	#ERFILB,R1
	UNPACK
	CLR	CONVER
	MOV	OBJDEV+6,CONVER+2
	MOV	#CONVER,R0
	MOV	#ERFILC,R1
	UNPACK
	MOV	#ERFIL,R0
	TYPE
	JMP	LINK
;
;	MOD NAME NOT UNIQUE
;
ER0500:	MOV	R2,R0		;PTR TO NAME
	MOV	#MNNUA,R1
	UNPACK
	MOV	#MNNU,R0
	TYPE
	CLR	-(SP)
	MOV	#1300,-(SP)
	IOT
	RTS	PC
;
;	BYTE RELOCATION ERROR -- NOT FATAL
;
ER0800:	SAVREG
	GETPC			;PUT CURRENT PC INTO R4
	SUB	#2,R4
	MOV	R4,-(SP)
	MOV	#1301,-(SP)
	IOT
	RESREG
	RTS	PC		;RETURN

;
;	INPUT CHECKSUM ERROR AND/OR INPUT BUFFER OVERFLOW
;
ER1500:	MOV	-2(R0),-(SP)
	BIC	#377,@SP
	SWAB	@SP
	MOV	#2202,-(SP)	;CODE=S202
	IOT
	TSTB	NOTINP
	BNE	ER1501
	JMP	ERMF

ER1501:	CLRB	NOTINP
	JMP	LINK
	.IFNDF	RSX
ER2100:	MOV	TRNBLK+6,-(SP)
	BIC	#377,@SP
	SWAB	@SP
	MOV	#2207,-(SP)	;CODE=S207
	.ENDC
ERROUT:	IOT			;PRINT ERROR MESSAGE.
	JMP	LINK


	.IF DF	RTH
;SUBROUTINE RTVALS: CONVERTS VALUES OF RT
;		    SWITCH Z SAVES THEM
;		R3:CONTAINS PTR TO SAVE REG
;		R4:CONTAINS PTR TO EXIT
RTVA00:	CMPB	#72,@2(R1)		;IS VALUE :?
	BNE	.+14			;YES-
	TST	(R3)+
	TST	(R1)+
	TST	(SP)+
	JMP	@RTADR
	CONSAV				;NO-CONVERT & SAVE
	TST	(R1)+
	RTS	PC
;SUBROUTINE CONSAV:CONVERTS & SAVES VALUE OF SWITCHES
;		R3:CONTAINS PTR TO SAVE REG.
CONS00:	MOV	2(R1),-(SP)
	MOV	#DETOBI,-(SP)
	EMT	CONV
	MOV	(SP)+,(R3)+
	TST	(SP)+
	RTS	PC
REMDER:+REMDRA-REMDER-6			;/RT SW FORMAT REMINDER
	.BYTE	FASC,0
	+REMDRA-REMDER-6
	.BYTE	CR,LF
	.ASCII	'/RT:NAME:PRIORITY:CALL NO:MAX TIME:'
	.ASCII	'STACK SIZE/E'
	.BYTE	CR,LF
REMDRA:	.EVEN
RTHB:	+RTHE-RTHB-6
	.BYTE	FASC,0
	+RTHE-RTHB-6
	.ASCII	/RTH/
	.BYTE	CR,LF
RTHE:	.EVEN
	.ENDC			;ERTH18
;
;	SUBROUTINE TYPE
;
;	TYPE MSG ON TTY
;		PTR IN R0
;
TYPE00:	.WRITE	#OUTCMD,R0
	.WAIT	#OUTCMD

MAPT03:	RTS	PC		;EXIT
;
;	TYPE MSG ON MAP DEVICE
;		PTR IN R0
;
MAPT00:	.WRITE	#MAPDEV,R0
	.WAIT	#MAPDEV
	BITB	#EOF,3(R0)	;ANY ERROR?
	BEQ	MAPT03		;NO
	CMP	(R0)+,(R0)+
	INCB	NOTINP
	ERR15
;
;	DEFINE 5 DATA SET LINK BLOCKS.
;
;
;	LINK BLOCK FOR KEYBOARD (INPUT)
;
	0
INCMD:	0
	.RAD50	/CMI/		;KEYBOARD
	1
	.RAD50	/KB/		;KEYBOARD


;
;	LINK BLOCK FOR TELETYPE (OUTPUT)
;
	0
OUTCMD:	0
	.RAD50	/CMO/		;TELETYPE
	1
	.RAD50	/KB/		;TELETYPE
;
;	LINK BLOCK FOR MAP DEVICE (OUTPUT)
;
	0			;ERROR RETURN
MAPDEV:	0
	.RAD50	/MAP/		;MAP OUTPUT DEVICE
	1
	.RAD50	/LP/		;LINE PRINTER
;
;	LINK BLOCK FOR OBJECT MODULE (INPUT)
;
	0			;ERROR RETURN

OBJDEV:	0
	.RAD50	/I1/		;OBJECT MODULE INPUT DEVICE
	31.
	.RAD50	/PR/		;HIGH SPEED P.T. READER
	.=.+60.			;ROOM FOR 30 WORDS OF SWITCHES.
;
;	LINK BLOCK FOR LOAD MODULE (OUTPUT)
;
	0			;ERROR RETURN
LODDEV:	0
	.RAD50	/O1/		;LOAD MODULE OUTPUT DEVICE
	1
	.RAD50	/PP/		;HIGH SPEED P.T. PUNCH
;
;	LINK BLOCK FOR SYMBOL TABLE OUTPUT
;
	0
STBDEV:	0
	.RAD50	/STB/
	1
	.RAD50	/PP/
;
;	PTR BLOCKS FOR CSI2
;
;	LOAD MODULE
;
BLKO:	0			;FILLED IN DYNAMICALLY TO POINT
				;TO CURRENT CSI BUFFER
	+LODDEV
	+LODADR
;
;	MAP
;
BLKM:	0
	+MAPDEV
	+MAPADR
;
;	INPUT
;
BLKI:	0
	+OBJDEV
	+OBJADR
;
;	SYMBOL TABLE
;
BLKS:	0
	+STBDEV
	+STBADR
;
;	RUN BLOCK USED BY GET EMT
;
RUNBLK:	+ACTION			;ADDRESS OF ACTION WORD
	+LODADR			;ADDRESS OF FILE BLOCK
	+LODDEV			;ADDRESS OF LINK BLOCK



;
;	DEFINE 5 DATA SET FILE BLOCKS.
;
;
;	FILE BLOCK FOR MAP DEVICE
;
	0			;ERROR RETURN
	OPENO

MAPADR:	0
	0
	0
	0
	0
;
;	FILE BLOCK FOR OBJECT MODULE
;
	0			;ERROR RETURN
	OPENI
OBJADR:	0
	0
	0
	0
	0


;
;	FILE BLOCK FOR LOAD MODULE
;
	0			;ERROR RETURN
	OPENO
LODADR:	0
	0
	0
	0
	0
;
;	FILE BLOCK FOR SYMBOL TABLE OUTPUT FILE
;
	0
	OPENO
STBADR:	0
	0
	0
	0
	0
	.IFNDF	RSX
;
;	TRAN BLOCK
;
TRNBLK:	4			;STARTING BLOCK #
	0			;STARTING ADDRESS IN CORE
	100			;# OF WORDS, PRESET FOR DF
	4			;INPUT
	0			;FOR MONITOR USE
	.ENDC
;
;	DATA AREA
;

SB:	0			;STACK BASE
SYMB:	0			;SYMBOLS BEGINNING
SYMC:	0			;TASK SYMBOLS BEGINNING
SYME:	0			;SYMBOLS END
USYME:	0			;SYMBOLS END OF UNDEFINES
ENDM:	0
OVLTOP:	.WORD	0		;TOP OF OVERLAYS
OVLC:	.WORD	0		;THE NUMBER OF OVERLAY FILES
SSYMB:	.WORD	0		;SAVED RESIDENT SYMB,RES SYMB BEG
SASYME:	.WORD	0		;SAVED RESIDENT SYME
NOINIT:	.BYTE	0		;INIT OVERLAYS IF NON-ZERO
OVLF:	.BYTE	0		;CURRENT LOAD MODULE IS THE RESIDENT
FORTRF:	.BYTE	0		;COMMAND STRING FROM FORTRAN
CHAR:	.BYTE	0		;BYTE REGISTER USED TO OBTAIN
				;BYTE COUNT OF COMMAND STRING
				;FROM FORTRAN
	.EVEN
FORTBC:	.WORD	0		;FORTRAN COMMAND STING BYTE COUNT
BEGCS:	.WORD	0		;SAVED POINTER TO BEGINNING
				;OF FORTRAN COMMAND STING
;
;START OF DATA AREA WHICH IS CLEARED
;
STCLR:
;
	.IFNDF	RSX
MONLIB:	.BYTE	0		;MON LIB SEARCH FLAG
SECTIM:	.BYTE	0		;CHANGE "   " TO ".  "
LASTDB:	.BYTE	0		;LAST DIR BOX FLAG
	.ENDC
	.EVEN
PTRH:	0			;POINTER TO CURRENT SECTION
SSYME:	0			;SAVED SYME FOR PMAP
RTHPTR:	0			;POINTER TO PTH
PASS:	.BYTE	0		;PASS FLAG
MAPF:	.BYTE	0		;MAP LIST FLAG
				;MAP DEVICE CODE
IOOPER:	.BYTE	0		;OUTPUT MODULE ERROR FLAG
CONCAT:	.BYTE	0		;CONCATENATION FLAG
PTRG:	0			;PTR TO MODULE NAME
CURPC:	0			;CURRENT PC
PRSIZE:	0			;PROGRAM SIZE IN BYTES
PTSECT:	0			;PTR TO CURRENT SECTION LEADER
LOWADR:	0			;LOWEST ADDRESS LOADED.
PUTR0:	0			;SAVE AREA FOR R0,R1 OF
PUTR1:	0			;OUTPUT BUFFERS
T:	.BYTE	0		;T SWITCH (SEE LABEL LINKS7).
PMAP11:	.BYTE	0		;SWITCH FOR LISTING UNDEFINES

OFFSET:	0		;OFFSET FOR RLD TXT COMMAND.
TMP1:	0
				;LOAD MODULE DEVICE
TRAF:	.BYTE	0		;TRA FLAG (0=NONE SEEN YET)
TAPES:	.BYTE	0		;TAPES SWITCH
	TAPCT:	0			;TAPE COUNTER
SSP:	0		;SAVED SP FOR PMAP
BOTMEM:	0		;BOTTOM OF MEMOTY
TOPF:	.BYTE	0	;TOP SPECIFIED FLAG
BOTF:	.BYTE	0	;BOTTOM FLAG
GENDF:	0		;GSD END SEEN FLAG
DDTF:	.BYTE	0		;D SWITCH
SDDTRA:	.BYTE	0		;DDT TRA SEEN FLAG
FLINE:	.BYTE	0		;FIRST CSI LINE FLAG
UTRA:	.BYTE	0		;USE THIS FILE FOR TRA

FTRA:	.BYTE	0		;FORCED TRA
STRA:	.BYTE	0		;SYMBOLIC TRA
MAPOPF:	.BYTE	0		;MAP OPEN FLAG
LODOPF:	.BYTE	0		; LOAD MOD OPEN FLAG
FREADF:	.BYTE	0		;1ST READ FLAG
REINIT:	.BYTE	0		;INIT OR OPEN NEXT?
INTMOV:	.BYTE	0		;MOVE SYMTAB AWAY FROM NEWMT
FLAG:	.BYTE	0
LIBF:	.BYTE	0		;LIBRARY FLAG
FILEOR:	.BYTE	0		;DEVICE IS FILE ORIENTED
BELOW0:	.BYTE	0		;PROGRAM TO BE LINKED BELOW 0
ODTF:	.BYTE	0		;TRY TO OPEN ODT FILE
NOTINP:	.BYTE	0		;EOM NOT IN INPUT
NSTBF:	.BYTE	0		;1ST NON STB FILE WAS SEEN
STBOPF:	.BYTE	0		;SYMBOL TABLE DEVICE IS OPEN
NOMMS:	.BYTE	0		;NO OUTPUT, MAPE, OR SYMTAB
SYMTAB:	.BYTE	0		;SYMBOL TABLE OUTPUT FLAG
SCOUNT:	.BYTE	0		;# OF SYMTABS READ IN 1ST PASS
SAMECS:	.BYTE	0		;LARGER SIZE SAME NAMED CSECT F
CLFLAG:	.BYTE	0		;CURRENTLY PROCESSING COR LIBS
BIT2F:	.BYTE 0			;CSI2 FILLED IN SYSTEM DEV
				;FOR DEFAULT DEV
GOF:	.BYTE	0		;EXECUTE LOAD MODULE FLAG
IDF:	.BYTE	0		;ONLY HANDLE 1ST .IDENT
	.IFDF	RTH		;BRTH19
RTF:	.BYTE	0		;RTH
NOIOF:	.BYTE	0		;NO I/O.
RTNOVA:	.BYTE	0		;=1 IF /RT SW WITH NO VALUE
CSISS:	.BYTE	0		;STACK SIZE FROM CSI
CSIMT:	.BYTE	0		;MAX TIME FROM CSI
CSICN:	.BYTE	0		;CALL NO FROM CSI
CSIP:	.BYTE	0		;PRIORITY FROM CSI
CSIN:	.BYTE	0		;NAME FROM CSI
	.EVEN
;DO NOT SEPARATE NEXT 4 WORDS.
SS:	.WORD	0		;STACK SIZE
MT:	.WORD	0		;MAX TIME
CN:	.WORD	0		;CALL NO
PRIOR:	.WORD	0		;PRIORITY
NAM1:	.WORD	0		;LOAD MODULE
NAM2:	.WORD	0		;NAME
RTADR:	.WORD	0		;REG USED IN /RT SW PROCESSING
SLARTH:	.WORD	0		;RTH LOAD ADR
	.ENDC			;ERTH19
	.EVEN
TEST:	.WORD	0		;AID IN IOOP
PUT:	.WORD	0		;AID IN IOOP
D1:	0			;ENDM-USYME
D2:	0			;USYME-SYMB
FBBF:	0			;1ST BINARY BLOCK FLAG
SBBF:	0			;2ND BINARY BLOCK FLAG
FNAME:	0			;SAVED 1ST PART OF O. M. N.
SNAME:	0			;SAVED 2ND PART OF O. M. N.
INSAVE:	0			;SAVED IN
CNT:	0			;COUNT FOR PREREAD BUFFERS
BUFSIZ:	0			;BUFFER SIZE FOR TRAN
NEWMT:	0			;NEW MONITOR TOP
SPTEST:	0			;SAVED VALUE OF SP
BC:	.WORD	0		;BC FOR DIR SEARCH

;DON'T SEPARATE NEXT 3 WORDS
LBYTE:	.BYTE	0		;LOW BYTE
HBYTE:	.BYTE	0		;HIGH BYTE
CONVER:	0,0			;2 WORDS TO AID TO CONVERT
				;1 WORD FROM MOD40
SVSTBC:	.WORD	0		;SAVED SYMTAB BC

SWSIZE:	.WORD	0		;SAVED LIB SW SIZE
SPRETV:	.WORD	0		;STACK RET VALUE
DIRSRV:	.WORD	0		;DIR SEARCH RET VALUE
FDATA:	.WORD	0
STBC:	.WORD	0
NOOUTP:	.BYTE	0		;NO OUTPUT REQUESTED
NOONOM:	.BYTE	0		;NO OUTPUT NO MAP REQUESTED
MONTOP:	0			;TOP OF MONITOR
CMDBUF:	0			;PTR TO CURRENT CSI BUFFER
CINBUF:	0			;PTR TO CSI LINE BUFFER HEADER
SCSIRV:	0			;SAVED CSI RETURN VALUE
MAINF:	.BYTE	0	;TWO MAIN. (OVERLAYS)
DATAF:	.BYTE	0	;TWO DATA. (OVERLAYS)
TXTSVB:	0,0		;SAVE AREA FOR TXT BLOCKS
MSTART:	.WORD	0		;MONLIB.SYS STARTING BLOCK
TSIZE:	.WORD	0		;DECREASING MRT TABLE SIZE
INDEX:	.WORD	0		;INCREASING INDEX IN MRT TABLE
	.=.+128.
;
;END OF AREA TO BE CLEARED
;
ENDCLR:
;
TOPMEM:	HGHMEM-ALODSZ		;TOP OF MEMORY
LIMIT:	.LIMIT
	.IF DF	RTH
FIO1:	.RAD50	/$OT/		;$OTSV,FORTRAN IMPURE AREA
FIO2:	.RAD50	/SV /		;PTR IN RAD50
RTHSIZ:	.WORD	0		;RTH SIZE
	.ENDC
FIL:	.RAD50	/$S$/		;DEFAULT
NAM:	.RAD50	/Y$M/		;SYMBOL TABLE
EXT:	.RAD50	/STB/		;OUTPUT
DEV:	.RAD50	/SY/		;PARAMETERS
MAIN1:	.RAD50	/MAI/		;MAIN. IN RADIX 50
MAIN2:	.RAD50	/N. /
DATA1:	.RAD50	/DAT/		;DATA. IN RADIX 50
DATA2:	.RAD50	/A. /
;
;	MESSAGE 
;
	.IF DF	OLDLUK
MONL:	+MONLA-MONL-6		;SY:MONLIB.LDA[1,1]<CRLF>
	.BYTE	FASC,0
	+MONLA-MONL-6
	.ASCII	'SY:MONLIB.LDA[1,1]'
	.ASCII	'/E'
	.BYTE	CR,LF
MONLA:	.EVEN
	.ENDC
;
TRAM:	+TRAMX-TRAM-6
	.BYTE	FASC,0
	+TRAMX-TRAM-6
	.BYTE	CR,LF
	.ASCII	/TRANSFER ADDRESS: /

TRAMA:	.=.+6
	.BYTE	CR,LF
	.ASCII	/LOW LIMIT: /
TRAMB:	.=.+6
	.BYTE	CR,LF
	.ASCII	/HIGH LIMIT: /
TRAMC:	.=.+6
	.BYTE	CR,LF
TRAMX:	.EVEN


;
;	SAVE AREA FOR TRANSFER ADDRESS
TRABLK:	.=.+10.
	TRA=.-2		;TRA IS IN LAST WORD
;

;	DDT TRANSFER ADDR

DDTTRA:	.=.+10.
	TRADDT=.-2


IN:	0

INA:	INBLN-6			;MAX
	.BYTE	FBIN,0		;MODE
	0			;BC
;
;THE FOLLOWING CSI BUFFER AND LINE BUFFER 
;WILL BE INPUT ONCE TO THE CSI TO CAUSE
;THE SET UP OF THE OVERLAY DEVICE LINK
;BLOCK WITH THE DEFAULT (SYSTEM) DEVICE.
;
	.IF NDF	NOSEG
CMDB:	.WORD	2		;OUTPUT DATA SET SPECIFICATION.
	.=.+14			;RESERVE 6 WORDS.
	.WORD	14		;MAXIMUM BYTE COUNT.
	.WORD	0		;FORMATTED ASCII MODE.
	.WORD	14		;ACTUAL BYTE COUNT.
	.ASCII	/LINK11.OVR/	;FILENAME/EXTENSION.
	.BYTE	15		;CARRIAGE RETURN.
	.BYTE	12		;LINE FEED.
	.ENDC
	.=.+186.		;DATA
INB:	INBLN-6			;MAX
	.BYTE	FBIN,0		;MODE
	0			;BC
	.=.+186.		;DATAOUT:	0

OUTA:	OUTBL-6
	.BYTE	FBIN,0
	0
	.=.+128.

OUTB:	OUTBL-6
	.BYTE	FBIN,0
	0
	.=.+128.MULMSG:	MULMSE-MULMSG-6		;MAX
	.BYTE	FASC,0		;MODE
	MULMSE-MULMSG-6		;BC
	.BYTE	CR,LF
MULMSB:	.=.+6
	.ASCII	/,/
MULMSA:	.=.+6
	.BYTE	CR,LF
MULMSE:	.EVEN
;
;	OUTPUT BUFFERS FOR PMAP
;
PMAP80:	.WORD	PMAP81-PMAP80-6	;MAX
	.BYTE	FASC,0		;MODE/STATUS
	.WORD	PMAP81-PMAP80-6	;BC
	.ASCII	/**********/	;OUTPUT MESSAGE
	.BYTE	CR,LF
PMAP81:	.EVEN
PMAP82:	.WORD	PMAP83-PMAP82-6	;MAX
	.BYTE	FASC,0		;MODE/STATUS
	.WORD	0		;BC
	.=.+72.			;DATA
PMAP83:	.EVEN
PMAP84:	.WORD	PMAP85-PMAP84-6	;MAX
	.BYTE	FASC,0
	.WORD	PMAP85-PMAP84-6	;BC
	.ASCII	/UNDEFINED REFERENCES/
	.BYTE	CR,LF
PMAP85:	.EVEN
PMAP86:	PMAP87-PMAP86-6
	.BYTE	FASC,0
	+PMAP87-PMAP86-6
	.BYTE	CR,LF
	.IFNDF	RSX
	.ASCII	/LOAD MAP  /
NAME:	.ASCII	/XXXXXX./
EXTEN:	.ASCII	/XXX  /
ID:	.ASCII	/        /
TIME:	.ASCII	/00:00:00  /
DATE:	.ASCII	/00-XXX-70/
	.ENDC
	.IFDF	RSX
	.ASCII	/LOAD MAP/
	.ENDC
	.BYTE	CR,LF
PMAP87:	.EVEN
PMAP88:	PMAP89-PMAP88-6
	.BYTE	FASC,0
	+PMAP89-PMAP88-6
	.ASCII	/SECTION	     	ADDRESS	SIZE/
	.BYTE	CR,LF
PMAP89:	.EVEN
  


;
;	SYMBOL OVERFLOW MESSAGE
;
USM:	USME-USM-6
	.BYTE	FASC,0
	USME-USM-6
	.BYTE	CR,LF
USMA:	.=.+6
	.ASCII	/,/
USMB:	.=.+6
	.BYTE	CR,LF
USME:	.EVEN
;
;	LOAD MODULE OUTPUT ERROR
;
LMOE:	LMOEE-LMOE-6
	.BYTE	FASC,0
	LMOEE-LMOE-6
	.BYTE	CR,LF
	.ASCII	/?LOAD MODULE EOM/
	.BYTE	CR,LF
LMOEE:	.EVEN


;
;	MODULE NAME NOT UNIQUE
;
MNNU:	MNNUE-MNNU-6
	.BYTE	FASC,0
	MNNUE-MNNU-6
	.BYTE	CR,LF
MNNUA:	.=.+6
	.BYTE	CR,LF
MNNUE:	.EVEN


ORDRM:	ORDRMA-ORDRM-6
	.BYTE	FASC,0
	ORDRMA-ORDRM-6
	.BYTE	CR,LF
ORDRER:	.ASCII	/       /
	.BYTE	CR,LF
ORDRMA:	.EVEN
;	DUMMY INPUT BUFFER FOR <CR,LF>
DUMIN:	+2			;MAX BC
	.BYTE	FASC,0		;FORMATTED ASCII
	0		;BC
	0		;DATA
;
;	ERROR MESSAGE WITH FILE NAME
;
ERFIL:	ERFILE-ERFIL-6
	.BYTE	FASC,0
	ERFILE-ERFIL-6
	.BYTE	CR,LF
ERFILC:	.=.+6
	.ASCII	/:/
ERFILA:	.=.+6
	.ASCII	/./
ERFILB:	.=.+6
	.BYTE	CR,LF
ERFILE:	.EVEN
	.END	START	;STARTING ADDRESS=LNK OR STARTB



  