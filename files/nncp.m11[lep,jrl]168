;	ELF75C.4
	.TITLE	NCP -- ELF NCP TOP-LEVEL
	.LIST	ME
	.NLIST	CND
	.GLOBL	$CLSCW		; CLOSE CONNX IN CLOSE-WAIT
	.GLOBL	$IHQ,$HIQ,$IQF,$IHQP
	.GLOBL	$SHL,$HTRST,$ENQ,$DEQ,$GFMQE,$FMQE,$MQFMT,$ALOCW
	.GLOBL	$QDEL		; DELETE ENTRY FROM QUEUE
	.GLOBL	$LLDEL		; DELETE ENTRY FROM LINKED LIST
	.GLOBL	$RFCLS,$SBCLS,$SINOP,$GLINK,$FLINK
	.GLOBL	$DISMQ
	.GLOBL	$SNDRS,$SNDRP,$HLIST
	.GLOBL	$FCTBL,$BLDCT,$ICT
	.GLOBL	$RCFLO,$SNFLO,$INCAL,$DECAL
	.GLOBL	$NSIOC,$NCXS
	.GLOBL	$DMPMG,$DEBUG
	.GLOBL	$ETCST,$MALCL,$EXMCH,$MATSK
	.GLOBL	$HHENQ,$HIENQ
	.GLOBL	$SLL,$LSLST
	.GLOBL	$IMIPI,$IMOPI,$NCPI
	.GLOBL	$IMPIN,$IMPOU
	.GLOBL	$FREEB
	.GLOBL	$NSEM
	.GLOBL	$NSINI
	.GLOBL	$NCLOG		;OPERATOR LOG MESSAGE PROCEDURE
	.GLOBL	$DUMDV		; MSG DUMP DEVICE # (IN NDM'S IORB)
	.GLOBL	$DEAD		; NCP DISCONNECTED FROM NETWORK
	.GLOBL	$NSTAT		; NCP CONTROL/STATUS -- ENABLE
	.GLOBL	$DLNK1,$DHOS1

	$CNFIG
	$DFREG
	.PAGE

;			THE FOLLOWING TABLE MAINTAINS
;			ALL INFORMATION RELATIVE TO THE STATE
;			OF A CONNECTION.

;			[ CONNECTION TABLE ]

	$DFCT
	$DFCCT
	$DFSCC
	$DFHTE
	$DFIFN
	$NSDEF			; NCP CONNX STATE DEFINITIONS
	$NPARM			;SPECIFY NCP PARAMETERS

;			HOST STATUS BIT ASIGNMENTS

HSRIP	=	1		; HOST RESET-IN-PROCESS
MQELEN	=	10+<N.XNCP*4>	; MESSAGE QUEUE EL. LENGTH

	.NLIST ME
	.LIST	MEB

	.PAGE
	.SBTTL	NCP -- PROCESS SYNCHRONIZATION OPCODES

OPNCM	=	0		;MESSAGE RECEIVED IN IMP-HOST QUEUE
OPNCDD	=	1		;IMP CONNECTION FAILURE (IMP DEAD)
OPNTIM	=	2		;NCP INIT TIMER EXPIRATION
OPNCXS	=	4		; NCP CHANGE IN CONNX STATE
OPNNUL	=	6	; NULL SIGNAL (RTS PC)

OPROM	=	0		;NET OUTPUT PROCESS, MSG ON $HIQ
OPROD	=	5		;NOTIFICATION THAT IMP GOING DOWN
;				 (NCP NOTIFIES IMP OUTPUT PROCESS)

;			NCP PROCESS PRIORITIES
IIPRI	=	4	;IMP INPUT PROCESS PRIORITY
IOPRI	=	4
NCPRI	=	4	;NCP INPUT PROCESS PRIORITY
INPRI	=	4	;INITIALIZATION PRIORITY

	.PAGE
	.SBTTL	ELF NCP INITIALIZATION PROCEDURE

	.CSECT	$NCP
$NINIT:	$PUSH	R0,R1
	$CREAP	#NI00I,#INPRI,#0,#0,#0
	$POP	R1,R0		;RESTORE REGS
	RTI			;AND RETURN TO SYS INIT

NI00I:	JSR	PC,$NSINI		; INITIALIZE NCP STORAGE


;			NOW INIT MESSAGE QUEUE ELEMENTS FOR NCP

	MOV	#$IQF+MQELEN+2,R0	; ADDRESS OF FREE MESSAGE QUEUE LIST
	MOV	$IQF+2,R3	; NUMBER OF FREE ELEMENTS
	MOV	#MQELEN,R4	; MQE LENGTH, BYTES, TO R4
	MOV	R0,$IQF		; SETUP POINTER TO FIRST MQE
2$:	MOV	R0,(R0)		; INIT TO POINT TO NEXT
	ADD	R4,(R0)		; POINT MQE TO NEXT IN CHAIN
	ADD	R4,R0		; THEN BUMP POINTER
1$:	$LOOP	R3,2$		; LOOP FOR EACH MQE
	SUB	R4,R0		; BACKUP ON LAST ONE
	CLR	(R0)		; AND RESET LINK FROM LAST TO 0
	CLR	$IHQ		; RESET IMP HOST QUEUE
	CLR	$HIQ		; RESET HOST-IMP QUEUE
	CLR	$LSLST		; INIT LISTEN LIST
	MOV	#$HLIST,R1	; POINTER TO HOST TABLE LIST
	MOV	(R1)+,R4	; ENTRY LENGTH
	MOV	(R1)+,R3	; NUMBER OF ENTRIES
3$:	JSR	PC,$HTRST	; RESET THE HOST-TBL ENTRY
	ADD	R4,R1		; ADVANCE HTE POINTER
	$LOOP	R3,3$		; FOR EACH SYSTEM HOST TBL ENTRY

;			NOW INIT NCP LOGGING DEVICE

	MOV	(PC)+,R0
	.RAD50	'TTY'		;SYSTEM TTY DEFINITION
	MOV	$DUMDV,R1	; LOAD MSG DUMP DEVICE #
	$DFDEV	R0,R1

	$CREAP	#$IMPIN,#IIPRI,#0,#0,#0 ;START INPUT PROCESS
	MOVB	R0,$IMIPI	;SET INPUT PROCESS ID
	$CREAP	#$IMPOU,#IOPRI,#0,#0,#0 ;START OUTPUT PROCESS
	MOVB	R0,$IMOPI	;SET OUTPUT PROCESS ID
	$CREAP	#$NCP,#NCPRI,#0,#0,#0 ;START NCP MESSAGE PARSER
	MOVB	R0,$NCPI	;SET NCP PROCESS ID
	$ISEM			;ALLOC NCP SYNCHRONIZATION SEMAPH
	MOVB	R0,$NSEM	;SET NCP SEMAPHORE
	.PAGE
;			INIT EMT EXITS FOR NCP
;			(VSM, CAP, EMTCD, XFER ADDR)

	.GLOBL	$N.CON,$N.LSN,$N.CLS
	$SEMTX	#0,#0,#1,#$N.CON	;CONNECT -- EMT 1
	$SEMTX	#0,#0,#2,#$N.LSN	;LISTEN -- EMT 2
	$SEMTX	#0,#0,#3,#$N.CLS	;CLOSE -- EMT 3

	.IF EQ	N.XNCP-1
	.GLOBL	$NXCON,$NXLSN,$NXCLS
	.GLOBL	$FXCTB
	$SEMTX	#0,#0,#4,#$NXCON	;XCON -- EMT 4
	$SEMTX	#0,#0,#5,#$NXLSN	;XLSN -- EMT 5
	$SEMTX	#0,#0,#6,#$NXCLS	;XCLS -- EMT 6
	.ENDC
	$SEMTX	#0,#0,#7,#$NPSET	;SET NCP PARAMETERS - EMT 7
	.GLOBL	$NUICP
	$SEMTX	#0,#0,#10,#$NUICP	; USER ICP - EMT 10


NI000:	$WAIT			;WAIT FOR TERMINATION OF A PROCESS
	$ZAP	$IMOPI		;TERMINATE IMP OUTPUT PROCESS
	$ZAP	$IMIPI		;TERMINATE IMP INPUT PROCESS
	$ZAP	$NCPI		;TERMINATE NCP.
	JMP	NI00I		; RESTART NCP INITIALIZATION


	.PAGE
	.SBTTL	$NPSET -- SET NCP PARAMETERS


;			***  $NPSET  ***

;			THIS NCP PRIMITIVE SETS NCP PARAMETERS
;			AND REQUESTS INFORMATION, SUCH AS NCP  IMP STATUS,
;			AND STATISTICS.

;			IT ASSUMES THE FOLLOWING:

;			R0 LSB = FUNCTION CODE (OPERATION TO BE PERFORMED)
;			R0 MSB = FUNCTION MODIFIER, ISED IN SOME OPERATIONS
;			R1 = PARAMETER, OR VALUE RETURNED.

;			$NPSET FUNCTIONS ARE CURRENTLY ASSAGNED AS FOLLOWS:

;				0) SET/RESET NCP DEBUG MODE
;				1) SET HOST DEBUG LIMITS (LSB IS LOW HOST ADDR,
;					MSB IS HIGH HOST ADDR IN R1.)
;				2) SET LINK DEBUG LIMITS (LSB IS LOW LINK NR,
;					MSB IS HIGH LINK NR IN R1.)
;				3) SET LOGGING DEVICE NAME (RAD50, IN R1).
;				4) SET LOGGING DEVICE NUMBER, IN R1. 
;					CAUSES NCP TO DEFINE ASSOCIATED DEVICE.
;				5) OBTAIN NCP STATISTICS.  NCP STATISTICS
;				   IDENTIFIER ASSUMED IN HIGH BYTE R0, RETURNED
;				   VALUE IN R1.
;				6) CLEAR NCP STATUS FLAGS
;				7) SET NCP STATUS FLAGS.  OP'S 6 & 7
;					ASSUME MASK IN R1.  NCP STATUS FLAGS ARE
;					CURRENTLY ASSIGNED AS FOLLOWS:
;					$NSTAT  BIT 0, NCP LOCAL LOOP ENABLE
;					$NSTAT  BIT 7 ,  NCP DISABLE.(DRAIN)
;				10) OBTAIN HOST ADDR OF SELF IN R1.
;				11) RE-INITIALIZE NCP, CLOSING ALL CONNECTIONS
;				12) EVALUATE NCP FREE MESSAGE QUEUE DEPTH
;				13) OBTAIN CONNECTION STATE VALUE
;				14) OBTAIN IMP/HOST LIVE/DEAD STATUS
;				15) ASSIGN NCP CONNECTION
;				16) FLUSH HOST
;				17) UNIMPLEMENTED

$NPSET:	$PUSH	R0		;SAVE CALLER R0
	BIC	#-NFUNCS,R0	;OBTAIN FUNCTION CODE
	ASL	R0		;BYTE DISPLACEMENT ON BRANCH TABLE
	JMP	@NPTBL(R0)	;JUMP THRU TABLE

NPTBL:	.WORD	NDBSET		;SET DEBUG MODE
	.WORD	DHLIM		;SET HOST LIMITS
	.WORD	DLLIM		;SET LINK LIMITS
	.WORD	DLDNA		;SET LOGGING DEV NAME
	.WORD	DLDNR		;SET LOGGING DEVICE NUMBER
	.WORD	NPNOP		;NCP STATISTICS
	.WORD	NCLRS		;CLEAR NCP STATUS BITS
	.WORD	NSETS		;SET NCP STATUS BITS
	.WORD	NSELF		;OBTAIN HOST ADDR OF SELF
	.WORD	NPRST		;NCP INITIALIZE REQUEST
	.WORD	NPQSIZ		; OBTAIN NR MQE'S ON IQF
	.WORD	NPCST		; OBTAIN NCP CONNECTION STATUS
	.WORD	NPIST		; OBTAIN IMP STATUS
	.WORD	NPASSG		; ASSIGN NCP CONNECTION
	.WORD	NPFLH		; FLUSH HOST
	.WORD	NPNOP		;UNIMPLEMENTED
NFUNCS	=	.-NPTBL/2	;NUMBER OF ALLOWED OP'S




NDBSET:	MOVB	R1,$DEBUG	;SET DEBUG MODE
NPNOP:
NPRTN:	$POP	R0		;RESTORE CALLER REG 0
	RTI			;AND RETURN

DHLIM:	MOV	R1,$DHOS1	;SET HOST LIMITS FOR DEBUG MESSAGES
	BR	NPRTN

DLLIM:	MOV	R1,$DLNK1	;SET LINK LIMITS FOR DEBUG MESSAGES
	BR	NPRTN

DLDNA:	MOV	R1,$DUMDV-2	;SET LOGGER DEVICE NAME
	BR	NPRTN

DLDNR:	MOV	R1,$DUMDV	;SET LOGGING DEVICE NUMBER
	MOV	$DUMDV-2,R0	;SET DEV NAME
	$DFDEV	R0,R1	;AND DEFINE NCP LOGGING DEVICE
	BR	NPRTN

NSELF:	MOV	#HADDR,R1	;GET HOST ADDRESS IN R1
	BR	NPRTN

NSETS:	BISB	R1,$NSTAT
	BR	NPRTN

NCLRS:	BICB	R1,$NSTAT	;CLEAR HOST STATUS BITS
	BR	NPRTN

NPQSIZ:	MOV	#$IQF,R0	;OBTAIN ADDRESS OF FREE QUEUE HEAD
	CLR	R1		;CLEAR TALLY REGISTER
1$:	MOV	(R0),R0		;SEARCH FOR END OF LIST
	BEQ	NPRTN		;RETURN WHEN HIT END
	INC	R1		;INCREMENT NUMBER OF ELEMENTS IN LIST
	BR	1$		; LOOP FOR ALL QUEUED ELEMENTS.

NPIST:	JSR	PC,NPTST	; TEST IMP UP/DOWN
	MOV	R0,R1		; SETUP PARAMETER REG
	BR	NPRTN

NPCST:	$P	$NSEM		; INTERLOCK WITH NCP PROCESS
	$PUSH	R2,R3,R4	; SAVE CALLER
	MOV	R1,R0		; SOCKET NUMBER SPEC. TO R0
	JSR	PC,$EXMCH	; PERFORM EXHAUSTIVE SEARCH
	CLR	R1		; SET VALUE AND INIT FOR BISB
	TST	R2		; CT VALUE RETURNED?
	BNE	2$		; BRANCH IF SOCKET FOUND TO BISB
	JSR	PC,$SLL		; ELSE SEARCH LISTEN LIST
	BEQ	1$		; NO, SKIP BISB
2$:	BISB	CTSTAT(R2),R1	; PUT CONNECTION STATE IN R1
1$:	$POP	R4,R3,R2	; RESTORE REGISTERS
	$V	$NSEM		; RELEASE INTERLOCK
	BR	NPRTN		; AND RETURN

NPASSG:	$P	$NSEM		; INTERLOCK WITH NCP
	$PUSH	R2,R3,R4,R1
	MOV	CCTLCL(R1),R0	; SOCKET NUMBER TO R0
	JSR	PC,$EXMCH	; FIND LOCAL SOCKET
	BEQ	1$		; RETURN IF CAN'T
	MOV	@SP,R1		; RETURN CCT VALUE
	MOV	CCTOP(R1),R1	; GET PID/OP
	SWAB	R1		; PLACE PROCESS ID IN LOW BYTE
	BNE	2$		; BRANCH IF NOT 0 SPEC.
	$GAPID			; GET ACTIVE PID
	BISB	R0,R1		; SET IN R1
2$:	MOV	R1,CTPCI(R2)	; AND STORE FOR NCP
1$:	$POP	R1,R4,R3,R2
	$V	$NSEM		; RELEASE SEMAPHORE
	BR	NPRTN		; AND THAT'S IT.

NPRST:	$PUSH	R1		; SAVE CALLER
	JSR	PC,NPTST	; TEST IMP UP/DOWN
	BNE	1$		; BRANCH IF FAILURE
	$SIGNL	$IMOPI,#OPROD,#0 ; WAKEUP OUTPUT PROCESS
1$:	$POP	R1,R0		; RESTORE
	RTI

NPFLH:	$PUSH	R1,R2,R3,R4,R5
	$P	$NSEM		; ALLOCATE NCP
	JSR	PC,NPTST	; CHECK NCP OPERATIONAL
	BNE	1$
	MOV	R1,R0		; HOST ADDRESS TO R0
	BLE	1$		; ILLEGITIMATE!
	JSR	PC,$SHL		; FIND  AN HTE
	BEQ	1$		; CAN'T GET HTE
	$PUSH	R1		; SAVE HTE ON STACK
	MOV	(R1),R0		; OBTAIN HOST ADDRESS
	MOV	#WCCCLS,R1	; ERROR CODE TO R1
	JSR	PC,HRESET	; RESET THE HOST TABLES
	$POP	R1		; HTE ADDRESS AGAIN
	BISB	#HSRIP,HTEST(R1) ; INDICATE RESET-IN-PROGRESS
	MOV	(R1),R0		; HOST ADDRESS TO R0
	JSR	PC,$SNDRS	; SEND A HH 'RST' MESSAGE
1$:	$V	$NSEM		; RELEASE THE NCP
	$POP	R5,R4,R3,R2,R1,R0 ; UNSAVE REGS
	RTI			; AND RETURN
NPTST:	MOVB	$DEAD,R0
	BISB	NITCNT,R0
	RTS	PC
	.PAGE
	.SBTTL	NCP INPUT PROCESS -- MESSAGE DEQUEUE ROUTINE

$NCP:	$P	$NSEM		;ALLOCATE NCP INTERLOCK
NCP0:	MOV	#IHMUP,R0		;ADDRESS OF MESSAGE
	MOV	#IHMUPL,R1	;LENGTH, BYTES
	JSR	PC,$NCLOG	;MESSAGE TO OPERATOR
IHNCP:	CLR	R0		; INIT FOR BISB, AND FOR BRANCH
	TST	$IHQ		; IS THERE SOMETHING QUEUED UP ??
	BNE	IHMSG		; YES, PROCESS IT.
	BISB	$NSEM,R0	; SET SEM ID IN R0
	$V	R0		; RELEASE NCP SEMAPHORE
	$WAIT			; WAIT FOR A NEW OP
	$PUSH	R0		; SAVE RESULT
	$P	$NSEM		; GRAB THE NCP SEMAPHORE (INTERLOCK)
	$POP	R0		; RESTORE PID/OPCODE
	BIC	#177770,R0	;OPCODE TO R0
	ASL	R0
IHMSG:	JSR	PC,@NTABL(R0)	; INTERPRET INPUT OP-CODE
	BR	IHNCP		; BACK FOR NEXT...

;		OPC 0 = REGULAR MESSAGE RECEIVED IN IHQ
;		OPC 1 = IMP DEAD
;		OPC 2 = NCP TIMER FOR INITIALIZATION
;		OPC 3 = NCP SIO COMPLETION
;		OPC 4 = NCP CHANGE IN CONNX STAT
;		OPC 5 = NCP IMP ALIVE STATUS.

NTABL:	.WORD	IHOLE	; INPUT MESSAGE FROM IMP
	.WORD	IHNCP0	; NOTIFICATION THAT IMP HAS GONE DOWN
	.WORD	NCTIME	; NCP INITIALIZATION TIMER
	.WORD	$NSIOC	; NCP IPP SIO COMPLETION
	.WORD	$NCXS   ; CHANGE CONN STATE
	.WORD	NCPUP	; IMP UP STATUS
	.WORD	IHRT	; NULL RETURN


IHNCP0:	MOV	#IHMDN,R0	; IMP IS DOWN MSG
	MOV	#IHMDNL,R1
	JSR	PC,$NCLOG	; LOG IT.

;			NOW CLOSE ANY ACTIVE CONNECTIONS

	MOV	#$HLIST,R4	; ADDRESS OF HOST LIST
	MOV	(R4)+,R2	; ENTRY LENGTH
	MOV	(R4)+,R3	; NUMBER OF HOST ENTRIES
1$:	MOV	(R4),R0		; ENTRY (HOST ADDR) TO R0
	BEQ	2$		; BRANCH IF UNDEFINED HOST
	MOV	#WCCDED,R1	; INDICATE CONNECTED IMP DEAD
	$PUSH	R2,R3,R4	; SAVE REGS
	JSR	PC,HRESET	; RESET ANY ACTIVE CONNECTIONS
	$POP	R4,R3,R2	; RESTORE THEM
2$:	ADD	R2,R4		; BUMP BY ENTRY LENGTH
	$LOOP	R3,1$		; FOR EACH DEFINED HOST
3$:	$TSTQ
	BEQ	6$		; FALL OUT IF NO ENTS ON Q
	$WAIT
	BR	3$
6$:	MOV	#$HIQ,R2	; ADDR OF HOST:IMP QUEUE
	JSR	PC,$DEQ		; REMOVE ELEMENT
	BEQ	4$
	JSR	PC,$DISMQ	; FREE STORAGE
	BR	6$
4$:	MOV	#$IHQ,R2	; IMP-HOST QUEUE
	JSR	PC,$DEQ
	BEQ	5$
	JSR	PC,$DISMQ
	BR	4$
5$:	TST	(SP)+		; POP RETURN ADDR
	BR	NCP0		; AND RESTART
IHOLE:	MOV	#$IHQ,R2	;GET ADDRESS OF IMP/HOST QUEUE
	JSR	PC,$DEQ		;DEQ MESSAGE
	BEQ	IHRT		;WAIT IF QUEUE NULL
	MOV	R0,$IHQP		;SAVE MESSAGE QUEUE POINTER
	MOV	R0,-(SP)	;SAVE POINTER TO M Q E
	MOVB	#'R,R1		;INDICATE RECEIVE MSG
	JSR	PC,$DMPMG
	MOV	(SP),R0		;OBTAIN MQE AGAIN
	JSR	PC,IHPRC	;PROCESS IMP-HOST MSG
	TST	$IHQP		;HAS ANYONE TAKEN MESSAGE?
	BEQ	IHDROP		;OK, FORGET IT
	$POP	R0		; BASE OF MQE AGAIN
	JSR	PC,$DISMQ	; DISCARD MQE & BUFFER
IHRT:	RTS	PC		; SCAN THE LIST
IHDROP:	TST	(SP)+		;STRAIGHTEN STACK
	RTS	PC		; AND SCAN THE IMP/HOST QUEUE

;			*** IMP/HOST MESSAGE PROCESSOR ***
	.SBTTL	IHPRC -- IMP/HOST MESSAGE PROCESSOR

IHPRC:	MOV	-(R0),R4	;BUFFER ADDRX TO R4
	TST	-(R0)		;SKIP POOLID
	MOV	-(R0),R1	;LENGTH
	MOV	R4,IHMA		;STORE MESSAGE ADDRESS
	MOV	(R4),R0		; SOURCE HOST AND SUBTYPE TO R0
	BIC	#^C40377,R0	; CLEAR ALL BUT PSEUDO-HOST, HOST ADDR
	MOV	(R4)+,R3	; SUBTYPE
	SWAB	R3		; TO LOW BYTE OF R3
	BIC	#177760,R3	;TRIM TO GET INDEX
	ASL	R3		;ON ADDRESS LIST
	JSR	PC,@IHVL(R3)	;CALL PROPER HANDLER
	RTS	PC		;RETURN

IHVL:	.WORD	IHREG	; 0	REGULAR MESSAGE
	.WORD	IHERL	; 1	ERROR IN LEADER
	.WORD	IHIGD	; 2	IMP GOING DOWN
	.WORD	IHREG	; 3	SPECIAL - TREAT AS REGULAR FOR NOW
	.WORD	IHN	; 4	NOP
	.WORD	IHRFN	; 5	RFNM
	.WORD	IHUD	; 6	UNDEFINED
	.WORD	IHDD	; 7	DESTINATION DEAD
	.WORD	IHERD	; 8	ERROR IN DATA
	.WORD	IHICT	; 9	INCOMPLETE XMISSION
	.WORD	IHIRS	; 10	INTERFACE RESET
	.REPT	5
	.WORD	IHUD	; 11-15	UNDEFINED
	.ENDR
	.PAGE
	.SBTTL	IHREG -- REGULAR MESSAGE PROCESSOR

;			*** HOST-HOST REGULAR MESSAGE ***


HHMBS	=	4	; OFFSET IN HH MSG TO BYTE SIZE (S)
HHMBC	=	6	; OFFSET IN HH MSG TO BYTE COUNT (C)
HHMTXT	=	10	; OFFSET IN HH MSG TO TEXT

	.CSECT	$NCP

;			HOST ADDR ASSUMED IN R0
IHREG:	$PUSH	R4		;SAVE PTR TO LINK
	JSR	PC,$SHL		;GET HTE PTR
	BEQ	IHHR		;UNKNOWN HOST
	MOV	R1,IHTE		;HTE POINTER
	$POP	R4		;RESTORE PTR TO LINK
	MOV	(R4)+,R0	;LINK TO HI BYTE R0
	SWAB	R0		;PUT LINK NR IN LO BYTE
	BEQ	HHICTL		;CHECK FOR CONTROL LINK
	MOV	HTECTI(R1),R2	;INPUT CHAIN ON HOST TO R2
	.IF EQ	N.XNCP-1	;XNCP OPTION INSTALLED?
	CMPB	R0,#XLNK	;IS THIS EXPERIMENTAL LINK?
	BHIS	IHRXCT		;ITS EXPERIMENTAL CONNECTION
	.ENDC

;			MESSAGE ON A CONNECTION

	JSR	PC,$FCTBL	;FIND HIS CT
	BEQ	IHMUDL		;UNDEFINED LINK
	MOV	$IHQP,R0	;MQE TO R0
	CLR	R3		; SETUP TO OBTAIN BYTE SIZE
	BISB	CTBSIZ(R2),R3	; CT BYTE SIZE TO R3
	MOV	-(R0),R1	; MESSAGE ADDRESS TO R1
	CMPB	R3,HHMBS(R1)	; SAME AS S FIELD OF INCOMING MSG?
	BNE	IHMUDL		; NO, DISCARD IT!
	DEC	CTMCT(R2)	; DECREMENT MESSAGE COUNT
	BMI	ALLER1		; IF WENT NEGATIVE, ABORT
	MOV	HHMBC(R1),R4	; BYTE COUNT TO R4
	ASR	R3
	ASR	R3
	ASR	R3		; DIVIDE BYTE SIZE BY 8.
	BR	1$		; AND DIVIDE BYTE COUNT BY BYTE SIZE/8
2$:	ASL	R4		; SHIFT BYTE COUNT (*2)
1$:	ASR	R3		; SHIFT UNTIL WE HIT A BIT
	BCC	2$		; ZEROS -> KEEP SHIFTING
	MOV	R4,R0		; INPUT BYTE COUNT IN R0
	ADD	#HHMTXT,R1	; BEGIN OF TEXT, R1
L10:	$PUSH	R0,R1		; SAVE COUNT, POINTER
	MOV	#N.ISIZ,R0	; SIZE OF INTERMEDIATE BUFFER
	JSR	PC,$ALOCW	; ALLOCATE A BUFFER
	JSR	PC,$MQFMT	; FORMAT IT
	MOV	R4,R3		; MQE PTR TO R3
	MOV	R1,R4		; NEW BUFFER ADDR TO R4
	$POP	R1,R0		; RECOVER ADDR, COUNT
	$PUSH	R3		; SAVE MQE POINTER
	MOV	R0,R3		; COUNT TO R3 (REMAINING IN MSG)
	CMP	R3,#N.ISIZ-2	; GREATER THAN INTERMED. SIZE?
	BLE	1$		; NO, DON'T TRIM
	MOV	#N.ISIZ-2,R3	; TRIM
1$:	SUB	R3,R0		; DECREMENT COUNT REMAINING
	MOV	R3,(R4)+	; MOVE COUNT TO OUTPUT BUFFER
	ASR	R3		; DIVIDE BY 2 AND
	ADC	R3		; ROUND UP
2$:	MOV	(R1)+,(R4)+	; MOVE MESSAGE TO INTERMED. BUFFER
	MOVB	1(R1),-1(R4)	; AND RE-FORMAT AS. NECC.
	CMPB	#10,CTBSIZ(R2)	; BYTE-ORIENTED CONN. ?
	BEQ	3$		; YES, NO SWAP NECC.
	SWAB	-2(R4)		; SWAP MESSAGE
3$:	$LOOP	R3,2$		; FOR EACH INPUT WORD
	$POP	R3		; OBTAIN MQE POINTER
	$PUSH	R0		; SAVE BYTES TO GO
	MOV	R3,R0		; MQE POINTER TO R0 FOR ENQ
	MOV	-(R3),R3	; ADDRESS OF MSG TO R3
	MOV	(R3),R3		; ITS LENGTH, BYTES
	ASR	R3		; DIVIDE BY 2 & ROUND UP
	ADC	R3
	MOV	R3,-6(R0)	; PUT WORD COUNT IN MQE
	$PUSH	R2		; SAVE CT POINTER
	ADD	#CTQ,R2		; ADDRESS OF CONN QUEUE
	JSR	PC,$ENQ		; STICK MESSAGE ON USER'S CONN QUEUE
	$POP	R2,R0		; POP CT PTR, BYTES-TO-GO VAL
	TST	R0		; ANY MORE BYTES?
	BGT	L10		; YES, KEEP GOING
	JSR	PC,$RCFLO	; ALLOW RECEIVE FLOW CONTROL
IHMUDL:	RTS	PC		; RETURN
ALLER1:	CLR	CTMCT(R2)	; REPAIR VIOLATED MESSAGE COUNT
	BR	IHMUDL		; TO KEEP IT AT 0

IHHR:	$POP	R4		;RECOVER R4
	RTS	PC		;RETURN

	.IF NE	N.XNCP		; XNCP DEFINED ?
IHRXCT:	JSR	PC,$FXCTB	;HANDLE XNCP INPUT
	BEQ	1$		; COULDN'T FIND CT -- RETURN.
	MOV	$IHQP,R0	; GOT IT -- SET POINTER TO MQE
	$PUSH	R2		;SAVE CT POINTER
	ADD	#CTQ,R2		;GET PTR TO QUEUE
	CLR	$IHQP		;IM TAKING RESPONSIBILITY
	JSR	PC,$ENQ		;BY STICKING HIM ON INPUT QUEUE
	$POP	R2		;CT AGAIN IN R2
	JSR	PC,$RCFLO	;MAINTAIN FLOW CONTROL
1$:	RTS	PC		; RETURN
	.ENDC


;			R4 POINTS TO HH MESSAGE
;			(AFTER LEADER)

;				;R1 IS HTE POINTER
HHICTL:	CMP	#10,(R4)+	; ENSURE BYTE SIZE 8 FOR CONTROL LNK
	BNE	HHXIT		; IF NOT, THROW MESSAGE AWAY
	MOV	(R4)+,R2	;BYTE COUNT TO R2
	BLE	HHXIT		; DISCARD IF INSENSIBLE BYTE COUNT
	CMP	R2,#120.	; COMPARE TO MAX BYTE COUNT
	BGT	HHXIT		; EXIT IF TOO LARGE
	MOV	R4,-(SP)	;SAVE IT
	MOV	R2,-(SP)	;AND BYTE CNT
	ASR	R2		;GET WORD COUNT
HHSWP:	SWAB	(R4)+
	DEC	R2		;SWAP BYTES IN TXT
	BGE	HHSWP		;LOOP TO SWAP THEM
	MOV	(SP)+,R2
	MOV	(SP)+,R4
	TSTB	(R4)+		;GET ADDR FIRST BYTE
HHNCMD:	MOVB	(R4)+,R3	;GET CODMMAND CODE
	BIC	#177760,R3	;MASK TO GET INDEX
	DEC	R2		;DECREMENT BYTE COUNT
	ASL	R3		;IN WORDS
	JSR	PC,@HHICV(R3)	;TO H-H INPUT INTERPRETER
	MOV	IHTE,R1		;RECOVER HTE POINTER
	TST	R2		;ANY BYTES LEFT?
	BGT	HHNCMD		;BACK TO INTERPRET NEXT COMMAND
HHXIT:	RTS	PC		;BACK TO GET NEXT MSG

HHICV:	.WORD	HHNOP	; 0	NOP
	.WORD	HHRTS	; 1	RTS
	.WORD	HHSTR	; 2	STR
	.WORD	HHCLS	; 3	CLS
	.WORD	HHALL	; 4	ALL
	.WORD	HHGVB	; 5	GVB
	.WORD	HHRET	; 6	RET
	.WORD	HHINR	; 7	INR
	.WORD	HHINS	; 8	INS
	.WORD	HHECO	; 9	ECO
	.WORD	HHERP	; 10	ERP
	.WORD	HHERR	; 11	ERR
	.WORD	HHRST	; 12	RST
	.WORD	HHRRP	; 13	RRP
	.WORD	HHIUN,HHIUN	;  UNDEFINED

IHERL:
IHIGD:
IHN:
IHUD:
IHERD:	RTS	PC	; ERROR IN DATA


;			THE FOLLOWING CODE PLACES A SET OF
;			HOST/IMP NOP MESSAGES ON THE $HIQ
;			UPON NOTIFICATION THAT THE IMP HAS
;			COME ALIVE.

NCPUP:	MOV	#4,HINCNT	; SET TALLY FOR NR NOPS
1$:	JSR	PC,$SINOP	; SEND A HOST-IMP NOP MSG
	DEC	HINCNT		; TALLY
	BGT	1$		; N TIMES...
	RTS	PC		; AND RETURN FOR NEW NCP OP

	.PAGE
;			***  IHIRS  ***

;			IMP-HOST INTERFACE-RESET
;			PROCESSOR.  INITIALIZES IMP-HOST
;			CONNECTION
;			THIS PROCEDURE INITIALIZES THE
;			ELF HOST ON THE NETWORK BY SENDING
;			HOST-HOST PROTOCOL "RESET" MESSAGES
;			TO ALL KNOWN HOSTS ON THE NETWORK.
;			TO AVOID SATURATION OF ELF SYSTEM
;			BUFFER SPACE, A TIMER IS USED TO
;			PROVIDE A GAP BETWEEN RESET
;			MESSAGES.


IHIRS:				;GO TO LIVE STATUS
	BISB	#2,$NSTAT	; INDICATE NCP INITIALIZING
	MOV	#IUMSG,R0	;ADDR OF IMP-UP MSG
	MOV	#IUMSGL,R1	;ITS LENGTH
	JSR	PC,$NCLOG

	MOV	#4.,HINCNT	;HOST/IMP NOP COUNT=4
HINIT:	JSR	PC,$SINOP	;SEND AN IMP NOP MESSAGE
	DEC	HINCNT		;DECREMENT HOST/IMP COUNT
	BGT	HINIT		;INIT HOST/IMP CONNECTION
	MOV	#$HLIST,R1	;RESET ALL HOSTS WE KNOW ABOUT
	MOV	(R1)+,NITLEN	;HTE ENTRY LENGTH
	MOV	(R1)+,NITCNT	;HTE ENTRY COUNT
	MOV	R1,NITPTR	;HTE POINTER
SRS00:	$STIME	#OPNTIM,#NINTVL	;SET INITIALIZATION TIMER
	RTS	PC		; BACK TO HANDLE MORE MESSAGES
NCTIME:	TSTB	$DEAD		; HAS IMP CONNECTION GONE DOWN?
	BNE	2$		; YES, DON'T TRANSMIT MSGS
	MOV	NITPTR,R1	; HTE POINTER TO R1
	MOV	(R1),R0		;HOST ID TO R0
	BEQ	1$		; BY-PASS IF NULL ENTRY
	$PUSH	R0,R1		; SAVE HTE POINT, HOST ADDR
	MOV	#WCCCLS,R1	; CLOSED FLAG TO R1
	JSR	PC,HRESET	; RESET THE HOST
	$POP	R1,R0		; AND RESTORE THE REGS
	BISB	#HSRIP,HTEST(R1) ; INDICATE RESET INITIATED
	JSR	PC,$SNDRS	;RESET THE HOST
1$:	ADD	NITLEN,NITPTR
	DEC	NITCNT
	BGT	SRS00		;AND LOOP FOR ALL OF THEM
	BICB	#2,$NSTAT	; CLEAR NCP-INITIALIZING FLAG
	MOV	#NUPMSG,R0	;NCP INIT COMPLETED
	MOV	#NUPMSL,R1	;AND ITS LENGTH
	JSR	PC,$NCLOG		;LOG IT...
2$:	RTS	PC
	.PAGE
	.SBTTL	IHRFN -- IMP-HOST RFNM PROCESSOR

IHRFN:	$PUSH	R4		;SAVE CURRENT HH MSG ADDR
;				;HOST ID IS IN R0
	JSR	PC,$SHL		;FIND HTE ADDR
	BEQ	IHRFNR		;BR IF HE DOESNT EXIST
	MOV	R1,IHTE		;SAVE HIS HTE PTR
	$POP	R4		;RESTORE POINTER TO LINK
	MOV	(R4)+,R0	;GET LINK CODE
	SWAB	R0		;PUT LINK IN LOW BYTE
	BEQ	HRFCTL		;CHECK FOR RFNM ON CONTROL LINK
	.IF EQ	N.XNCP-1	;XNCP OPTION INSTALLED?
	CMPB	R0,#XLNK	;IS THIS EXPERIMENTAL LINK?
	BHIS	IHRXNC		;YES, HANDLE BY XNCP
	.ENDC
	MOV	HTECTO(R1),R2	;SET HEAD OF OUTPUT LINKLIST
	JSR	PC,$FCTBL	;FIND CT ENTRY BY LINK ID
	BEQ	IHRFR2		;CANT FIND HIM
;				ITS A RFNM ON A CONNECTION
	MOV	R2,IHCT		;SAVE CT POINTER
	MOV	CTMQA(R2),R0	;GET OLD MQE POINTER IN R0
	BEQ	IHRFNU		;AVOID IMP ERROR
	JSR	PC,$DISMQ	;GO FREE OLD QUEUE ELEMENT
	MOV	IHCT,R2		;RESTORE CT POINTER
	MOVB	CTSTAT(R2),R3	;GET CONN STATE
	BIC	#177760,R3	;MASK OFF EXTRANEOUS BITS
	ASL	R3		;GET OFFSET IN WORDS
	JSR	PC,@IHRFTB(R3)	;JUMP TO RFNM PROCESSOR
IHRFNU:	RTS	PC		;RETURN
IHRFNR:	$POP	R4		;RESET STACK
	RTS	PC		;RETURN
	.IF EQ	N.XNCP-1	;XNCP OPTION?
IHRXNC:	JMP	IHRXCT		; HANDLE EXPERIMENTAL LINK RFNM
	.ENDC

;				BRANCH-TABLE FOR RFNM

IHRFTB:	.WORD	IHRFNU,IHRFNU,IHRFNU,IHRFNU
	.WORD	IHRFN4,IHRFN5,IHRFN6
	.WORD	IHRFNU,IHRFNU,IHRFNU

;				RFNM RCD FOR OPEN CONNECTION

IHRFN6:	ADD	#CTQ,R2		;ADD OFFSET TO QUEUE
	JSR	PC,$DEQ		;FETCH NEXT MSG TO BE SENT
	BEQ	IHRNNQ		;NONE IN QUEUE
	MOV	IHCT,R2		;CT POINTER TO R2
	MOV	R0,CTMQA(R2)	;NEW MQE POINTER ACTIVE
	JSR	PC,HIENQ	;PUT ON HOST-IMP QUEUE
	RTS	PC
IHRNNQ:	MOV	IHCT,R2		;OBTAIN BASE OF CT AGAIN
	CLR	CTMQA(R2)	;CLEAR INDICATOR INDIC ACTIVE
	JSR	PC,$SNFLO	;PROCESS FLOW CONTROL
IHRFR2:	RTS	PC		;AND RETURN

HRFCTL:	MOV	HTMQA(R1),R0	;SETUP TO FREE OLD ACTIVE QUEUE
	BEQ	IHRFNU		;NO FREE NONEXIST MQE
	JSR	PC,$DISMQ	;FREE IT (MQE IS IN R0)
	MOV	IHTE,R2		;GET HTE PTR IN R2
	ADD	#HTCLQ,R2	;OBTAIN BASE CTRL LINK Q IN R2
	JSR	PC,$DEQ		;ANY NEW ENTS
	BEQ	HRF02
	MOV	IHTE,R1		;OBTAINE HTE PTR AGAIN
	MOV	R0,HTMQA(R1)	;NEW ACTIVE PTR FOR CTRL LINK
	JSR	PC,HIENQ	;GOT ONE, STICK ON HOST/IMP QUEUE
	RTS	PC			;AND RETURN

HRF02:	MOV	IHTE,R1		;OBTAIN HTE ADDR AGAIN
	CLR	HTMQA(R1)	;INDIC NO ACTIVE ENTRY
	RTS	PC		; RETURN

IHRFN5:		; RFNM RECEIVED WHILE IN DRAIN-WAIT STATE
	CLR	R0		; INDICATE CLOSE MESSAGE TO BE SENT
	$PUSH	R2		; SVE CT POINTER
	JSR	PC,$RFCLS	; SEND CLS MESSAGE
	$POP	R2
	MOV	#STCLWR,R0	; GO TO CLOSE-WAIT-REMOTE
	JSR	PC,$ETCST	; SET CONNEX STATE
	RTS	PC		; AND RETURN

IHRFN4:		; RFNM RECEIVED WHILE IN CLOSE-WAIT-LOCAL
	MOV	CTCCT(R2),R0	; OBTAIN CCT ADDRESS
	MOVB	#WCCCLS,CCTCC(R0) ; SET REMOTE CLOSE ERROR CODE
	JSR	PC,NCSIGN	; SIGNAL USER PROCESS
	RTS	PC		;AND RETURN

	.PAGE
	.SBTTL	IHICT -- INCOMPLETE TRANSMISSION PROCESSOR

;			***  IHICT  ***

;			RECEIVES CONTROL ON A TYPE
;			9 IMP-HOST MESSAGE (INCOMPLETE
;			TRANSMISSION).  TAKES
;			MESSAGE WHICH WAS ACTIVE
;			AND RE-TRANSMITS IT BY PLACING
;			IT ON THE HOST/IMP QUEUE
;			THROUGH A CALL TO $HIENQ.


IHICT:	$PUSH	R4		;SAVE PTR TO MESSAGE
	JSR	PC,$SHL		;SEARCH FOR HTE POINTER
	BEQ	IHRFNR		;TO RFNM ERROR ABORT
	MOV	R1,IHTE		;SAVE HTE POINTER
	$POP	R4		;RELOAD MSG POINTER
	MOV	(R4)+,R0	;GET LINK IN R0
	SWAB	R0
	BEQ	IHICTL		;CHECK FOR ICT ON CONTROL LINK
	.IF EQ	N.XNCP-1	;XNCP OPTION INSTALLED?
	CMPB	R0,#XLNK	;IS THIS EXPERIMENTAL LINK NR
	BHIS	IHRIXC		;YES, PROCESS AS EXPERIMENTAL CONNX
	.ENDC
	MOV	HTECTO(R1),R2	;GET BEGINNING OUT CONN. LIST
	JSR	PC,$FCTBL	;FIND OUT CONN W/ THIS LINK
	BEQ	IHICT2		;CANT FIND
	MOV	R2,IHCT		;CT POINTER TO SAVE
	MOV	CTMQA(R2),R0	;PUT BACK ON HOST IMP QUEUE
IHICT3:	BEQ	IHICT2		;AVOID IMP ERRORS
	JSR	PC,$HIENQ	;ENQ IT
IHICT2:	RTS	PC		;AND RETURN

IHICTL:	MOV	HTMQA(R1),R0	;GET MQE PTR FOR CTRL LINK
	BR	IHICT3		;BACK TO STICK ON HOST/IMP QUEUE
	.IF EQ	N.XNCP-1	;XNCP OPTION?
IHRIXC:	JMP	IHRXCT		; HANDLE ICT AS REGULAR MSG FOR XNCP
	RTS	PC		;AND RETURN
	.ENDC
	.PAGE
	.SBTTL	IHDD -- IMP HOST 'DESTINATION DEAD'

IHDD:	$PUSH	R4		;SAVE PTR TO MSG
	MOV	(R4),R1		;ERROR CODE TO R1
	BIC	#177776,R1	;USE LOW BIT OF SUBTYPE FIELD
	BIS	#WCCID,R1	;FORM ERROR CODE
	JSR	PC,HRESET	;RESET THAT HOST WITH THAT ERROR CODE
IHDDRT:	$POP	R4		;RESTORE PTR TO MSG
	RTS	PC		;AND RETURN
	.PAGE
	.SBTTL	HHECO -- HOST/HOST ECHO PROCESSOR

NERP = 12		;CODE FOR ECHO REPLY
HHECO:	MOV	R2,-(SP)	;SAVE R2
	MOV	R4,-(SP)	;AND R4
	CLR	R0		;SET POOL 0
	JSR	PC,$ALOCW	;ALLOCATE AND WAIT
	MOV	(SP)+,R4	;RESTORE R4
	MOV	R1,HHIM		;SAVE NEW MSG ADDR
	JSR	PC,HHCLDR	;COPY LEADER TO NEW BUFFER
	MOV	#NERP,(R1)+	;SETUP ECHO REPLY
	CLRB	(R1)+		; CLEAR PADDING FIELD
	MOVB	(R4)+,(R1)	; SET ECHO REPLY DATA
	MOV	R4,-(SP)	;SAVE R4
	MOV	HHIM,R1		;LOAD BASE OF MESSAGE
	CLR	R0		;INDICATE POOL 0
	MOV	#6,R2		;COUNT (WORDS)
	JSR	PC,$MQFMT	;GET A MSG QUEUE EL AND FORMAT IT
	MOV	R4,R0		;SETUP FOR ENQ
	MOV	IHTE,R1		;GET HTE ADDR
	CLR	R2		;INDICATE CONTROL LINK
	JSR	PC,HHENQ	;PLACE ON QUEUE
	MOV	(SP)+,R4	;RESTORE R4
	MOV	(SP)+,R2	;AND R2
	DEC	R2		;INDICATE NR ADDNL BYTES TAKEN
	RTS	PC		;RETURN TO INTERPRETER

HHRST:	MOV	(R1),R0		;HOST ADDRX TO R0
	$PUSH	R4,R2,R0	;SAVE MSG POINTER, COUNT, HOST ADDR
	BITB	#HSRIP,HTEST(R1) ; IS RESET IN PROGRESS FOR THIS HOST ?
	BNE	1$		; YES, BY-PASS RESET OF HOST-TABLES
	MOV	#WCCCLS,R1	;SET ERROR CODE FOR CONNECTIONS
	JSR	PC,HRESET	;RESET ALL CONNECTIONS FOR HOST
1$:	$POP	R0		;RESTORE HOST ADDRESS
	JSR	PC,$SNDRP	;SEND RESET-REPLY
	$POP	R2,R4	;RESTORE MSG POINTER, COUNTER
	RTS	PC
HHGVB:			; GIVE-BACK
HHRET:			; RETURN
HHERR:			; ERROR (HOST-HOST)
HHIUN:	CLR	R2		;DISCARD HH MSG
HHNOP:			; HOST-HOST NOP
	RTS	PC

;			***  INTERRUPT BY RECEIVER (INR)  ***
;			***   ASSUME HTE ADDRESS IN R1	  ***


HHINR:	$PUSH	R2		; INTERRUPT BY RECEIVER
	MOV	HTECTO(R1),R2	; OBTAIN OUTPUT CONNX CHAIN PTR
HHINR2:	BEQ	2$		; BRANCH IF NONE EXIST
	MOVB	(R4),R0		; LINK NUMBER TO LOW BYTE R0
	$PUSH	R4		; SAVE POINTER TO STRING
	JSR	PC,$FCTBL	; FIND CT
	BEQ	1$		; BRANCH IF CAN'T FIND IT
	MOV	CTCCT(R2),R1	; CCT ADDRESS TO R1
	BEQ	1$		; NO ASSOCIATED CONNECTION
;				  (NOTE THAT THE ABOVE BRANCH
;				  REFLECTS A VIOLATION OF PROTOCOL.
	MOVB	#WCCINT,CCTCC(R1) ; SET INTERRUPT COND CODE
	MOV	CTPCI(R2),R0	; PROCESS ID IN LOW BYTE, OPCODE IN HI
	$SIGNL	R0,R0,R1	; SIGNAL ASSOC USER PROCESS
1$:	$POP	R4		; RESTORE POINTER TO STRING
2$:	$POP	R2		; RESTORE COUNTER (BYTES)
HHERP:	INC	R4		; ECHO REPLY HANDLER
	DEC	R2		; DECREMENT COUNTER
	RTS	PC		; AND RETURN

;			***  INTERRUPT BY SENDER  ***

HHINS:	$PUSH	R2		; SAVE COUNTER
	MOV	HTECTI(R1),R2	; POINTER TO INPUT CONNEXTION LIST
	BR	HHINR2		; AND BACK TO SIGNAL NECCESS. PROC.


;			RESET REPLY PROCESSOR

HHRRP:	BICB	#HSRIP,HTEST(R1) ; CLEAR RESET IN PROGRESS FLAG
	RTS	PC
	.PAGE
	.SBTTL	HOST-RESET -- RESET ALL CONNECTIONS TO HOST

;			ASSUME:
;			R0 = HOST ADDRESS
;			R1 = ERROR CODE (CCT COMPL CODE)

HRESET:	$PUSH	R1		;SAVE ERROR CODE
	JSR	PC,$SHL		;FIND HTE ADDR IN R1
	BEQ	IHPNX3		;BRANCH IF UNDEFINED HOST
	$PUSH	R1		;SAVE HTE POINTER
	MOV	R1,R2		;HTE PTR TO R2
	CLRB	HTEST(R1)	; INIT HOST STATUS BYTE
IHD00:	ADD	#HTCLQ,R2	;GET BASE OF CNTRL LINK Q
	JSR	PC,$DEQ		;FETCH ANY ENTS IF THEY EXIST
	BEQ	IHF002		;AREN'T ANY
	JSR	PC,$DISMQ	;FREE MQE AND ITS ASSOC BUF
	MOV	@SP,R2		;HTE PTR TO R2
	BR	IHD00		;LOOP TO FREE ALL MSGS ON CLQ
IHF002:	MOV	@SP,R1		;HTE PTR
	MOV	HTMQA(R1),R0	;FREE ANY ACTIVE QUEUE ENT IF SO
	BEQ	IHD01		;NOPE
	CLR	HTMQA(R1)	;CLEAR ACTIVE PTR
	JSR	PC,IMQCH	; CONDITIONALLY DELETE ACTIVE MQE
IHD01:	$POP	R1,R0		;POP HTE AND ERROR CODE
	MOV	HTECTI(R1),R2	;GET PTR TO INPUT CONNECTIONS
	BEQ	IHPNXT		;NO INPUTS
	CLR	HTECTI(R1)	;INDIC NO MORE INPUT CONNS
	JSR	PC,IHDNX0	;FREE (CLOSE) INPUT CONNS
IHPNXT:	MOV	HTECTO(R1),R2	;ANY OUTPUT CONNS?
	BEQ	IHPNX2		;NOPE
	CLR	HTECTO(R1)	;INDIC NO MORE OUTPUT CONNS
	JSR	PC,IHDNX0	;RELEASE OUTPUT CONNS
IHPNX2:	$PUSH	R2		; SAVE CALLER R2
	MOV	#$HIQ,R2	; DELETE ELEMENTS FROM HOST-IMP Q
	JSR	PC,IMDQH	; FOR SPECIFIC HOST
	MOV	#$IHQ,R2	; SAME FOR IMP-HOST QUEUE
	JSR	PC,IMDQH	; DELETE ELEMENTS AND FREE STORAGE
	$POP	R2		; RESTORE CALLER
	JSR	PC,$HTRST	; RESET HOST TABLE
	RTS	PC		;RETURN FROM RESET
IHPNX3:	$POP	R1		;RESTORE REGS
	RTS	PC		;AND RETURN

IHDNX0:	$PUSH	R0,R1,R2	;SAVE REGS
IHDNX1:	CLRB	CTSTAT(R2)	;CLOSE CONN
	MOV	CTCCT(R2),R3	;CCT ASSOC?
	BEQ	IHDNSC		;NO
	MOVB	4(SP),CCTCC(R3)	; SET COMPLETING STATUS
IHDNSC:	TSTB	CTPCI(R2)	;PCT DEFINED?
	BEQ	IHDNP		;NOPE, DON'T SIGNAL
	JSR	PC,NCSIGN	;SIGNAL ASSOC PROCESS
IHDNP:	MOV	(SP),R2		; CT POINTER TO R2
	MOV	CTMQA(R2),R0	; ANY ACTIVE MSG ON CONNX ?
	BEQ	1$		; NOPE
	JSR	PC,IMQCH	; NOW CHECK IT FOR ON HIQ OR IHQ
	CLR	CTMQA(R2)	; AND INDICATE NO ACTIVE MSG
1$:	MOV	CTQ(R2),R0	; NOW CHECK ANY OUTSTANDING REQUESTS
	BEQ	3$		; THERE AREN'T ANY
2$:	$PUSH	(R0)		; REMEMBER PREVIOUS LINK TO NEXT
	JSR	PC,$DISMQ	; DISCARD THEM
	$POP	R0		; RETRIEVE POINTER TO NEXT
	BNE	2$		; FOR EACH MQE ON CTQ
	CLR	CTQ(R2)		; AND INDICATE NO MORE EXIST
3$:	$POP	R2		;RESTORE
	$PUSH	(R2)		;SAVE PTR TO NEXT
	CLRB	CTSTAT(R2)	; INDICATE ITS NOW CLOSED
	$SIGNL	$NCPI,#OPNCXS,R2 ; SIGNAL CHANGE OF STATE
	MOV	@SP,R2		;GET NEXT CT IN CHAIN
	BNE	IHDNX1
	$POP	R2,R1,R0		;RESTORE REGS
	RTS	PC

;			THE FOLLOWING PROCEDURE DISCARDS
;			A QUEUE ELEMENT ON THE CONDITION THAT
;			IT IS NOT RESIDENT ON THE HOST-IMP OR
;			IMP-HOST QUEUES.   ASSUME R0 = ADDR MQE.

IMQCH:	$PUSH	R0,R1		; SAVE MQE PTR AND HTE
	MOV	#$IHQ,R1	; CHECK IMP-HOST QUEUE
1$:	MOV	(R1),R1		; ADVANCE TO NEXT ELEMENT
	BEQ	3$		; THAT'S ALL THERE IS
	CMP	R0,R1		; IS THIS ELEMENT SAME AS ONE TO BE DEL
	BNE	1$		; NO, KEEP SCANNING
	BR	6$		; YES, EXIT WITHOUT RELEASING IT

3$:	MOV	#$HIQ,R1	; NOW CHECK HOST-IMP QUEUE
4$:	MOV	(R1),R1		; ADVANCE TO NEXT ENTRY
	BEQ	5$		; THAT'S IT
	CMP	R0,R1		; IS MQE FOUND ON QUEUE ?
	BNE	4$		; NOT YET, KEEP SCANNING
	BR	6$		; YES, DON'T DEL IT
5$:	JSR	PC,$DISMQ	; DISCARD MQE
6$:	$POP	R1,R0		; RESTORE THE REGS
	RTS	PC		; AND THAT'S ALL FOLKS

;			THE FOLLOWING PROCEDURE REMOVES ALL ELEMENTS
;			FROM THE QUEUE POINTED TO BY R2, AND ASSOCIATED
;			WITH HOST HAVING HTE POINTER IN R1.

IMDQH:	$PUSH	R0		; R2 POINTS TO QUEUE
IMDQ2:	$PUSH	R2		; SAVE QUEUE POINTER
1$:	MOV	(R2),R0		; OBTAIN ELEMENT FROM QUEUE
	BEQ	IMDONE		; I'M DONE, EXIT FROM THIS QUEUE
	CMP	(R1),@-2(R0)	; DO HOST ADDRESSES CORRESPOND?
	BEQ	IMDQIT		; DEQUEUE IT
	MOV	R0,R2		; ELSE JUST ADVANCE TO NEXT
	BR	1$		; AND KEEP SCANNING
IMDQIT:	MOV	(SP),R2		; MAIN QUEUE PTR TO R2 AGAIN
	$PUSH	R1		; SAVE HTE POINTER
	JSR	PC,$QDEL	; REMOVE ELEMENT FROM QUEUE
	JSR	PC,$DISMQ	; DISCARD ELEMENT
	$POP	R1,R2		; RESTORE MAIN QUEUE POINTER
	BR	IMDQ2		; PUSH R2 AGAIN AND KEEP GOING
IMDONE:	$POP	R2,R0		; RESTORE REGS
	RTS	PC		; AND BACK WE GO - ALL CLEAN!
	.PAGE
	.SBTTL	HHRFC -- HOST/HOST INPUT RFC PROCESSOR

;			INPUT R1 = HT POINTER



HHRTS:
HHSTR:
HHRFC:	MOV	#9.,R3		;SETUP FOR COPY
	SUB	R3,R2		;DECREMENT BYTE COUNT
	$PUSH	R2		;AND SAVE IT
	MOV	#RFMSYS,R0	;ADDR FOR COPY
RFC0:	MOVB	(R4)+,(R0)+	;TO TEMP AREA
	DEC	R3		;TALLY
	BGT	RFC0
	$PUSH	R4		;SAVE MSG POINTER
	SWAB	RFMSYS		;SWAP BACK FGN SCK
	SWAB	RFMSYS+2
	SWAB	RFMSYS+6	;AND LOW WORD LCL SCK
	TST	RFMSYS+4	;TEST VALIDITY
	BNE	RFCR	;RETURN, INVALID LCL SCK
	MOV	RFMSYS+6,R0	;GET LCL SCK ID
	JSR	PC,$SLL		;SEE IF SOCK IS LISTENING
	BNE	RFCMLS		;YES, PLACE IN RULING STATE
	MOV	RFMSYS,R3	;PERFORM COMPARE
	MOV	RFMSYS+2,R4	;OF BOTH LCL, FGN SOCKS
	JSR	PC,$MATSK	;MATCH THEM
	BEQ	RFC01		;BRCH IF NO LUCK
RFSIM1:	MOV	R2,IHCT	;SET CT
	MOVB	CTSTAT(R2),R3	;GET CT STATUS
	BIC	#177760,R3	;TRIM BITS
	ASL	R3		;GET BRANCH INDEX
RFSIM0:	JSR	PC,@RFCTB(R3)	;JUMP TO CORRECT INTERPRETER
RFCR:	$POP	R4,R2		;RESTORE MSG PTR, BYTE COUNT
	RTS	PC		;TO HERE TO RETURN

RFC01:	JSR	PC,$BLDCT	;BUILD A CT
	BNE	RFSIM1		;GO SIMULATE STATE 0
	MOV	@IHTE,R0	; ELSE GET HOST ID
	MOV	#RFMSYS,R1	; POINTER TO SOKET NUMBERS
	JSR	PC,$SBCLS	; SEND BACK A CLOSE
	BR	RFCR

RFCMLS:	MOV	(R2),(R3)	;DELETE FROM LISTEN LIST
	ROR	R0		;SEND OR RECEIVE ?
	BCS	RFSNDL		;BRCH IF SEND
	MOV	HTECTI(R1),(R2)	;INSERT ON INPUT QUEUE
	MOV	R2,HTECTI(R1)
RFC22:	MOV	R1,CTHTA(R2)	;SET HTE POINTER IN CT
	MOV	CTCCT(R2),R0	;GET CCT ADDRESS
	MOV	RFMSYS,CCTFGN(R0)	;AND COPY FGN SOCK
	MOV	RFMSYS+2,CCTFGN+2(R0) ;TO CCT
	MOV	(R1),(R0)	;AND SET CALLER'S HOSTID
	BR	RFSIM1		;CARRY ON WITH FORMER LISTENER

RFSNDL:	MOV	HTECTO(R1),(R2)	;STICK ON OUTPUT CT QUEUE
	MOV	R2,HTECTO(R1)	;AND UPDATE QUEUE HEAD
	BR	RFC22		;BACK TO PUT SCKS IN CCT.

;			*** BRANCH TBL  ***
;			*** FOR RFC     ***

RFCTB:	.WORD	RFPND		;0 (CLOSED) GO TO PENDING CALLS
	.WORD	RFRUL		;1 (LISTEN) GO TO RULING
	.WORD	RFNUL,RFNUL,RFNUL,RFNUL,RFNUL	;SENSELESS
	.WORD	RFOPN		;7 (CONNECT) GO TO OPEN
	.WORD	RFNUL,RFNUL	;SENSELESS STATE TRANSITIONS

RFPND:	JSR	PC,$ICT		;INIT CT
	MOVB	#10,R0		;SET CONN STATE TO PENDING CALLS
	JSR	PC,$ETCST	;CALL STATE SETTER
	JSR	PC,RFCSCK	;SETUP SOCKETS IN CT
	RTS	PC		;AND RETURN
RFCSCK:	MOV	RFMSYS,CTFGN(R2)	;SET FGN SCK
	MOV	RFMSYS+2,CTFGN+2(R2)	;IN CT
	RORB	RFMSYS+2	;CHECK GENDER OF FGN SCK
	BCS	RFSTR		;IF 1, WAS STR OP
	MOVB	RFMSYS+10,CTLINK(R2)	;SETUP LINK NR
	RTS	PC		;RETURN
RFSTR:	MOVB	RFMSYS+10,CTBSIZ(R2)	;SETUP BYTE SIZE
	RTS	PC
RFRUL:	JSR	PC,$ICT		;INIT ALLOCATION PARAMS
	MOV	#STRUL,R0	;GO TO RULING STATE
	JSR	PC,$ETCST	;SET THE STATE
	JSR	PC,RFCSCK	;SETUP SOCKETS
RFPOS:	MOV	CTCCT(R2),R3	;GET CCT ADDR
	BEQ	RCNRTS
	MOVB	#WCCCMP,CCTCC(R3)	;SET CONDITION CODE
	JSR	PC,NCSIGN	;SIGNL ASSOC PROCESS
RCNRTS:	RTS	PC
RFOPN:	JSR	PC,$ICT		;INIT CT ALL PARAMS
	MOV	#STOPEN,R0	;GO TO OPEN STATE
	JSR	PC,$ETCST	;TO SET STATE
	JSR	PC,RFCSCK	;AND SET OPEN LINK OR B.S.
	MOV	#OPNCXS*400,R0	; OPCODE TO SIGNAL NCP NEW CONNX
	$SIGNL	R0,R0,R2	; SET WAKEUP FOR NEW CONNX
	BR	RFPOS	;POST CCT AND WAITING PRC

RFNUL:	RTS	PC
	.PAGE
	.SBTTL	HHCLS -- CLS PROCESSOR

HHCLS:	MOV	#8.,R3	;BYTE COUNT
	SUB	R3,R2		;DECREMENT REMAINING
	$PUSH	R2		;AND SAVE IT
	MOV	#RFMSYS,R0	;ADDR OF WORK SPACE
CLS0:	MOVB	(R4)+,(R0)+	;MOVE SCKS TO WORK SPC
	DEC	R3		;TALLY
	BGT	CLS0
	$PUSH	R4		;NOW SAVE CURRENT MSG PTR
	SWAB	-(R0)		;SWAP LCL SCK
	TST	-(R0)		;SHOULD BE 0
	SWAB	-(R0)		;FGN SCK, WD 1
	MOV	@R0,R4		;TO REG 4
	SWAB	-(R0)		;SWAP FGN SCK, WD 0
	MOV	@R0,R3		;AND BACK OFF...
	MOV	6(R0),R0	;PUT LCL SCK IN R0
	JSR	PC,$MATSK	;FIND MATCHING PAIR
	BEQ	CLSB		;NOP, CANT FIND MATCH
	MOV	R2,IHCT		;SET CONN TBL
	MOVB	CTSTAT(R2),R3	;SETUP TO BRANCH THRU TBL
	BIC	#177760,R3	;SETUP TO BRNCH
	ASL	R3		;THRU STATE TABLE
	JSR	PC,@CLSTB(R3)	;OFF WE GO
CLRTS:	$POP	R4,R2		;RESTORE MSG CNT
CLSNL:	RTS	PC		;AND RETURN
CLSB:	MOV	@IHTE,R0		;HOST ID TO R0
	MOV	#RFMSYS,R1		;INPUT SCK SPECIFIERS
	JSR	PC,$SBCLS		;SEND A MATCHING CLS
	BR	CLRTS			;POP STACK AND RETURN


;			***  CLS  ***
;			*** BRANCH ***
;			*** TABLE ***

CLSTB:	.WORD	CLSNL,CLSNL	;NULL (CLOSED, LISTEN)
	.WORD	CLSCLS		;CLOSE IT (RULING)
	.WORD	CLSW1		;CLOSE WAIT
	.WORD	CLSNL	; CLS RCD WHILE IN CLOSE-WAIT-LOCAL -> NO ACTION
	.WORD	CLSDRS	; CLS RECD WHILE IN DRAIN-WAIT - SEE IF RCV/SEND
	.WORD	CLSRS	; CLS RECEIVED WHILE OPEN -- SEE IF RECV/SEND
	.WORD	CLSSIG	; CLS RECEIVED WHILE ATTEMPTING CONNECT
	.WORD	CLSCL2		;PENDING

;			CONNECTION WAS RULING, BUT REMOTE END
;			'CHANGED ITS MIND' BY SENDING A CLS;
;			GO TO CLOSE-WAIT-LOCAL

CLSCLS:
	MOV	#STCLWL,R0	; NEW STATE
	JSR	PC,$ETCST	; AND BACK WE GO.
	RTS	PC

CLSCL2:
	CLR	R0		;INDICATE CLS OPERATION
	$PUSH	R2		;SAVE CT POINTER
	JSR	PC,$RFCLS	;ISSUE CLS TO CT
	$POP	R2		;RESTORE CT PTR
CLSW1:	MOV	CTCCT(R2),R0	;RECOVER CCT PTR
	BEQ	CLSRTS		;RTS IF NO CCT
	MOVB	#WCCCMP,CCTCC(R0)	;SET CMPL CODE IN CCT
	$PUSH	R2		;SAVE CT PTR
	JSR	PC,NCSIGN	;SIGNAL ASSOC PROCESS
	$POP	R2		;RESTORE CT
$CLSCW:
CLSRTS:	CLRB	CTSTAT(R2)	; INDICATE CLOSED
	$PUSH	R2		; SAVE CT POINTER
	MOV	R2,R0		; SAVE POINTER TO ELEMENT
	MOV	CTHTA(R2),R1	; HOST TABLE ENTRY ADDR
	ADD	#HTECTI,R1	; OFFSET TO INPUT LIST
	BIT	#1,CTLCL(R2)	; WAS IT SEND SOCKET?
	BEQ	1$		; NO, IT WAS RECEIVE
	TST	(R1)+		; ELSE ADVANCE TO SEND LIST
1$:	MOV	R1,R2		; QUEUE HEAD ADDR
	JSR	PC,$LLDEL	; DELETE ELEMENT FROM LINKED LIST
	$POP	R2		; RESTORE CT POINTER/FREE IT
	$SIGNL	$NCPI,#OPNCXS,R2 ; LET NCP PROCESS DO THE RELEASE OF CT
	RTS	PC		;AND RETURN

CLSDRS:	BIT	#1,CTLCL(R2)	; TEST LOCAL SOCK NUMBER
	BNE	$CLSCW		; SIGNAL USER CLOSED IF SEND CONN
	RTS	PC		; ELSE IGNORE CLS

NCSIGN:	MOV	CTPCI(R2),R0	; SET PROCESS ID AND OPCODE
	$SIGNL	R0,R0,CTCCT(R2)	; SIGNAL USER OF NCP
	RTS	PC		;AND RETURN



;			CONNECTION WAS OPEN AND CLS RECEIVED
;			... CHECK TO SEE IF SEND/RECEIVE CONN.


CLSRS:	BIT	#1,CTLCL(R2)	;SEND SOCKET?
	BEQ	CLSCLR		;IF RECEIVER, CHECK DATA RECD.
	TST	CTMQA(R2)	;IF SND SOCK, SEE IF RFNM AWAITED
	BNE	CLSSI2		; DON'T SIGNAL USER IF RFNM AWAITED

;			SIGNAL USER THAT CONNECTION CLOSED
;			REMOTELY, AND PUT CONNECTION IN
;			THE CLOSE-WAIT-LOCAL (STCLWL) STATE

CLSSIG:	MOV	CTCCT(R2),R0	; OBTAIN CCT ADDRESS
	MOVB	#WCCCLS,CCTCC(R0)	; SET CCT COND CODE
	JSR	PC,NCSIGN	; SIGNAL USER
CLSSI2:	MOV	#STCLWL,R0	; WAIT FOR USER TO CLOSE
	JSR	PC,$ETCST	;SET STATUS
	RTS	PC		;RETURN


;			CLS RECEIVED FOR RECEIVE CONNECTION:

CLSCLR:	TST	CTQ(R2)		;RECEIVER EXHAUSTED DATA?
	BEQ	CLSCS		; NO MORE DATA, SIGNAL USER
;				; RECEIVE CONNECTION - GO TO DRAIN WAIT
;				(REMAINS IN DRAIN-WAIT
;				UNTIL RECEIVER TAKES ALL
;				OUTSTANDING DATA)
;				(WAIT FOR PORT I/O COMPLETE)
	MOV	#STDRAI,R0	; SETUP NEW STATE
	JSR	PC,$ETCST	; NEW CONN STATE
	RTS	PC		; AND RETURN
CLSCS:	MOV	#40002,CTIFCN(R2)	; SET FUNCTION CODE
	MOV	R2,R0		; SEND END-OF STREAM
	ADD	#CTIPP,R0	; POINTER TO IPP IORB
	$SIO	R0
	BR	CLSSIG		; SIGNAL USER
	.PAGE
	.SBTTL	ALL PROCESSOR

HHALL:	MOV	#7,R3		;SET NR BYTES TO EAT
	SUB	R3,R2		;DECREMENT REM CNT IN MSG
	$PUSH	R2		;SAVE FOR INTERPRETER
	MOVB	(R4)+,R0	;GET LINK NUMBER
	$PUSH	R4		;SAVE POINTER TO STRING
	MOV	HTECTO(R1),R2	;SETUP FOR FIND CT ENTRY
	JSR	PC,$FCTBL	;BY LINK NR (OUTPUT)
	BEQ	ALLAB		;ABORT, LINK NOT DEFINED
	MOV	#6,R3		;REMAINING COUNT IN R3
	$POP	R4		;RECOVER POINTER TO STRING
	MOV	#RFMSYS,R0	;ADDRX OF WORK AREA
ALL0:	MOVB	(R4)+,(R0)+		;MOVE DATA TO ALIGN
	DEC	R3		;ON WORD BOUNDARY
	BGT	ALL0
	$PUSH	R4		;SAVE PTR TO STRING
	SWAB	RFMSYS		;SWAB BYTES
	ADD	RFMSYS,CTMCT(R2)	;INCREMENT MESSAGE COUNT
	MOV	RFMSYS+2,R3
	MOV	RFMSYS+4,R4	;SETUP TO INCREMENT BIT COUNT
	SWAB	R3
	SWAB	R4		;HAVE TO SWAP BIT COUNTS
	JSR	PC,$INCAL	;INCREASE ALLOCATION
	JSR	PC,$SNFLO	;ENABLE FLOW CONTROL
	$POP	R4,R2		;RESTORE POINTERS
	RTS	PC		;AND RETURN CONTROL TO INTERP

ALLAB:	$POP	R4,R2
	ADD	#6,R4		;BUMP PASE MCT, BITCT
	RTS	PC


HHCLDR:	MOV	IHMA,R3		;FORMAT LEADER
	MOV	(R3)+,(R1)+		;FROM INPUT MSG
	MOV	(R3)+,(R1)+	;NEXT...
	MOV	(R3)+,(R1)+	;UP TO COUNT WORD IN HH MESSAGE
	MOV	(R3)+,(R1)+
	RTS	PC

	.PAGE
	.SBTTL	HIENQ -- PLACE ENTRY ON HOST/IMP QUEUE

;			***  HIENQ  ***

;			ASSUMES R0 = MESSAGE QUEUE ADDR


$HIENQ:
HIENQ:	$PUSH	R0	;SAVE MQE PTR
	MOV	R0,R1
	MOV	-(R1),R1
	TST	(R1)
	BNE	NOH
	TST	R1
NOH:	MOV	#'S,R1	;FLAG SEND MSG
	JSR	PC,$DMPMG	;DUMP MSG
	$POP	R0	;RESTORE MQE POINTER
	MOV	#$HIQ,R2		;SETUP QUEUE ADDR
	JSR	PC,$ENQ			;PLACE IN HOST/IMP QUEUE
	$SIGNL	$IMOPI,#OPROM,R1	;SIGNL MESSAGE ON OUTPUT QUEUE
	RTS	PC			;RETURN

;			***  HHENQ  ***

;			PLACE A MSG QUEUE ELEMENT
;			ON HOST MSG QUEUE
;			ASSUMES
;			R0 = A(MSG QUEUE ELEMENT)
;			R1 = A(HTE)
;			R2 = A (CT)  IF LINK NE 0
;			R2 = 0       IF LINK EQ 0

$HHENQ:
HHENQ:	TST	R2		;CONTROL LINK?
	BNE	HHQCON		;NO, ITS FOR A CONNECTION
;			*** ITS FOR THE CONTROL LINK ***
	TST	HTMQA(R1)	;RFNM-AWAITED ON C.L. ?
	BNE	HHQNQ		;YES, PLACE ON CTRL LLINK QUEUE
	MOV	R0,HTMQA(R1)	;SAVE ADDRX OF MQE ACTIVE
HHNQ2:	JSR	PC,HIENQ	;ALL CLEAR, QUEUE FOR IMP
	RTS	PC

HHQNQ:	MOV	R1,R2		;COMPUTE CONTROL LINK Q ADR
	ADD	#HTCLQ,R2
HHNQ3:	JSR	PC,$ENQ		;PLACE ON QUEUE
	RTS	PC		;AND RETURN

HHQCON:	TST	CTMQA(R2)	;SEE IF RFNM-AWAITED ON CONN.
	BEQ	HHNQ4		;NO, SET NEW MQE ACTV AND PUT IN Q
	ADD	#CTQ,R2		;GET ADDR OF CONNECTION QUEUE
	BR	HHNQ3		;ENQUEUE FOR CONNECTION

HHNQ4:	MOV	R0,CTMQA(R2)	;INDIC RFNM-AWAITED
	BR	HHNQ2
	.PAGE
	.SBTTL	NCP WORKING CONSTANTS
	.CSECT
$NCPI:	.BYTE	0		;PROCESS ID OF NCP INPUT PROCESS
$IMIPI:	.BYTE	0		;PROCESS ID OF IMP INPUT PROCESS
$IMOPI:	.BYTE	0		;PROCESS ID OF IMP OUTPUT PROCESS
$NSEM:	.BYTE	0		;NCP INTERLOCK SEMAPHORE
	.EVEN
IHMA:	.WORD	0		;SAVE AREA FOR BUFFER ADRX
$IHQP:	.WORD	0		;SAVE IH MSG QUEUE PTR
IHTE:	.WORD	0		;BASE OF HOST TBL ENTRY
IHCT:	.WORD	0		;BASE OF C.T. ENTRY
HHIM:	.WORD	0		;BASE OF HOST/HOST MSG (OUT)
HINCNT:	.WORD	0		;HOST/IMP NOP COUNT
NITPTR:	.WORD	0		;NCP INIT POINTER TO HTABLE
NITLEN:	.WORD	0		;HTE ENTRY LENGTH
NITCNT:	.WORD	0		;HTE NUMBER OF ENTRIES
$DEAD:	.BYTE	0		; NCP-NETWORK STATUS (NZ=DEAD)
$NSTAT:	.BYTE	0		; NCP STATUS BYTE. BIT ALLOCATION IS
				; BIT 7 - NCP DISABLED
				; BIT 1 - NCP INITIALIZING
				; BIT 0 - NCP LOOP ENABLE (I.E.,
				; LOCAL MESSAGES DO NOT GO TO IMP).

;			*** HOST-IMP/IMP-HOST QUEUES
	.SBTTL	$IHQ,$HIQ -- IMP/HOST, HOST/IMP QUEUES

$LSLST:	.WORD	0	;QUEUE OF LISTENING LOCAL SOCKETS

$IHQ:	.WORD	0,0	;IMP/HOST QUEUE (HEAD,TAIL)
$HIQ:	.WORD	0,0	;HOST/IMP QUEUE (HEAD,TAIL)


RFMSYS:	.WORD	0,0,0,0,0	;HH RFC FROM FGN HOST

	.SBTTL	NCP MESSAGES
	.NLIST	BEX

IHMUP:	.BYTE	15,12
	.ASCII	" NCP: INIT STARTED."
IHMUPL	=	.-IHMUP
IHMDN:	.BYTE	15,12
	.ASCII	" NCP: IMP IS DOWN."
IHMDNL	=	.-IHMDN
IUMSG:	.BYTE	15,12
	.ASCII	" NCP: IMP IS UP."
IUMSGL	=	.-IUMSG
NUPMSG:	.BYTE	15,12
	.ASCII	" NCP: INIT COMPLETED."
NUPMSL	=	.-NUPMSG
	.END	$NINIT		;START NETWORK CONTROL MODULE
   