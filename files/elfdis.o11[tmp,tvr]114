;<VOICE>ELFDIS.M11;11    12-MAR-74 08:38:04	EDIT BY RAVELING

;	Looking for assembler bug (?) - tried changing .blkw's
;	to equates (.=.+...)

;<VOICE>ELFDIS.M11;10    11-MAR-74 08:35:13	EDIT BY RAVELING

;	Corrected consequences of previous correction.  Bah!

;<VOICE>ELFDIS.M11;9    11-MAR-74 08:23:51	EDIT BY RAVELING

;	Corrected addressability errors in branches.

;<VOICE>ELFDIS.M11;8    11-MAR-74 07:37:59	EDIT BY RAVELING

;	Added .SND & .RCV, modified $ATTCH for revised pct format,
;	added labels for enqueue & dequeue pct.

;<VOICE>ELFDIS.M11;7    23-FEB-74 00:32:13	EDIT BY RAVELING
;<VOICE>ELFDIS.M11;6    10-FEB-74 21:46:13	EDIT BY RAVELING
;<VOICE>ELFDIS.M11;5    10-FEB-74 00:29:05	EDIT BY RAVELING
;<VOICE>ELFDIS.M11;4     9-FEB-74 23:12:17	EDIT BY RAVELING
;<VOICE>ELFDIS.M11;3     7-FEB-74 16:11:02	EDIT BY RAVELING
;<VOICE>ELFDIS.M11;2     6-FEB-74 12:47:27	EDIT BY RAVELING
	.LIST	MD,ME
	.NLIST	CND
	.MCALL	$CNFIG
	.MCALL	$GPCT,$GPRQ,$GTQE,$DFREG
	.MCALL	$PUSH,$POP,$ALOCB,$FREEB
	.MCALL	$DISCC,$WAIT,$POST
	$CNFIG
	$DFREG
	$DISCC
	.PCTD


	.TITLE	NETDIS SCRL/ARPANET
	.SBTTL  DISPATCHER CONTROL TABLES
	.CSECT
	.GLOBL	$IEXIT,$SVST,$IH
	.GLOBL	$APCT,$IOC,$TCI
	.GLOBL	$RTPIN,$RTPOU,$IMPIN
	.GLOBL	$DUMP
	.GLOBL	$PCTRO,$PCTIH,$LGPCT,$PCTRI,$PCTIM,$LGR
	.GLOBL	$TSET,$TGET	;TIMER WRITE/READ ROUTINES
	.globl	$CLKIN		; clock initialization routine
	.GLOBL	$WDOG1
	.GLOBL	$FTP0
	.GLOBL	$ALOCB,$FREEB

;			NCP GLOBLS
	.GLOBL	$N.CON,$N.LSN,$N.CLS,$N.SND,$N.RCV,$N.CNT

	.PAGE
	.SBTTL	PROCESS PRIORITY QUEUES


;			***  SCRL ARPANET CONTROL ***
;			***       T A B L E S     ***


$PRQ6:	$GPRQ	$PRQ5,6,$PCTIM,$PCTIM
$PRQ5:	$GPRQ	$PRQ4,5,$PCTRI,$PCTRO
$PRQ4:	$GPRQ	$PRQ3,4,$PCTIH,$PCTIH
$PRQ3:	$GPRQ	$PRQ0,3,$LGPCT,$WDPCT
$PRQ0:	$GPRQ	$PRQ6,0,$PCTD,$PCTD


	.PAGE
	.SBTTL	PROCESS CONTROL TABLES

$PCTIM:	$GPCT	0,$PRQ6,$TIMER,340	;TIMER PROCESSOR
PCTLEN = .-$PCTIM/2		;PCT LEN, WORDS
$PCTRI:	$GPCT	$PCTRO,$PRQ5,$RTPIN,340	;RTP INPUT
$PCTRO:	$GPCT	0,$PRQ5,$RTPOU,340	;RTP OUTPUT
$PCTIH:	$GPCT	0,$PRQ4,$IH,340		;IMP-HOST PROTOCOL
$LGPCT:	$GPCT	$FTPCT,$PRQ3,$LGR,340	;LOGGER, AND TERMINALS
$FTPCT:	$GPCT	$WDPCT,$PRQ3,$FTP0,0
$WDPCT:	$GPCT	0,$PRQ3,$WDOG1,0	;PCT FOR WATCH-DOG PROC.
$PCTD:	$GPCT	$PCTD,$PRQ0,$DUMMY,0	;DUMMY PCT (WAIT-STATE)



$APCT:	.WORD	0	;ADDRESS OF ACTIVE PROCESSOR CONTROL TBL
TSETL:	.WORD	0	;LAST TIMER SETTING
TFQH:	.WORD	TQ+4	;ADDRESS OF TIMER FREE QUEUE HD
TQAH:	.WORD	0	;ADDRESS OF TIMER ACTIVE QUEUE HEAD


TQ:	$GTQE	6	;GENERATE 6 TIMER QUEUE ELEMENTS

VIO = 10		;VDH INTFC INT OUT

REGTLY = 6.		;NR REGS SAVED BY $SVST
PCPOOL = 0		;POOLID FOR PCT
	.PAGE
	.SBTTL	MULTIPROCESSING DISPATCHER

 	;		***  SCRL ARPANET SYSTEM ***
	;		***    MULTIPROCESSING   ***
	;		***     DISPATCHER       ***

$WAIT:	MOV	$APCT,R4	;MOVE ACTIVE PCT ADDRESS
	MOV	SP,2(R4)	;SAVE PROCESS' STACK POINTER
WTST:	TSTB	(R4)		;IS PROCESS READY AGAIN?
	BPL	WTI0		;NO, BUMP TO NEXT PROCESS
	MOV	R4,$APCT	;SAVE ACTIVE PCT PTR
	BIC	#140200,(R4)+	;GO BACK TO PROCESS
	MOV	(R4),SP		;GIVE HIM BACK HIS STACK
	RTI			;AND RETURN...

WTI0:	BIS	#140000,(R4)	;SET WAITING...
deqpct:	MOV	-(R4),@6(R4)	;BUMP QUEUELINK TO NEXT
WTI:	MOV	#$PRQ6+2,R3	;SETUP HEAD OF PRIOQ
	BR	.+4		;JUMP INTO PRIOQ DISPATCHER
	MOV	-(R3),R3	;NEXT IN CHAIN
	MOV	(R3),R4		;PCT ADDR
	BEQ	.-4		;BACK TO NEXT
	TST	(R4)+		;BUMP TO CONTROL BYTE
	TST	(R4)		;WAS HE WAITING
	BMI	WTST		;YES, SEE IF HE'S RDY
	MOV	R4,$APCT	;SETUP ACTIVE PCT ADDR
	MOV	2(R4),SP		;GET HIS STACK POINTER
	JSR	R5,SRST		;RESTORE STATUS
	RTI			;AND RETURN


	.PAGE
	.SBTTL	$POST  --  PLACE PROCESS IN READY QUEUE

;			***  $POST  ***

;			ASSUMES:
;			R0 = A(PCT CONTROL BYTE)
;			R1 = COMPLETION CODE

$POST:	BIS	R1,(R0)		;SET COMPLETION CODE
	BIT	#40000,(R0)	;IS HE IN RDY QUEUE ALREADY?
	BEQ	POSWT		;YES, JUST RETURN
enqpct:	BIC	#40000,(R0)	;OK, INDICATE HES IN RDY QUEUE
	MOV	4(R0),R3	;GET PRIOQ POINTER
	CLR	-(R0)		;CLEAR CHAIN FIELD TO NEXT PCT
	TST	(R3)+		;IS THERE ONE IN QUEUE
	BNE	POSW2		;BRCH IF YES
	MOV	R0,(R3)		;SET NEW TAIL
POSW0:	MOV	R0,-(R3)	;SET HEAD PTR (OR TAIL)
POSWT:	RTI			;RETURN

POSW2:	MOV	R0,@(R3)+	;SET LINK FROM CURRENT 'LAST'
	BR	POSW0		;GO SET NEW TAIL PTR






	.PAGE
	.SBTTL	DISPATCHER RETURN, REGSAVE, RESTORE.


$IEXIT:	MOV	$APCT,R4	;GE ACTIVE PCT ADDR
	MOV	SP,2(R4)	;SAVE HIS STACK POINTER
	BR	WTI		;ENTER DISPATCHER



$SVST:	$PUSH	R0,R1,R2,R3,R4		;SAVE REGS
	MOV	R5,PC		;RETURN

SRST:	INC	(SP)+		;THROW AWAY CALLERS R5
	$POP	R4,R3,R2,R1,R0
	RTS	R5	;R5 GETS RESTORED TOO...

	.page
	.sbttl	.SEND Primitive (temporary version)

;	   This isn't commented because it's temporary &
;	   the !#$)&$#""$( system probably won't stay up
;	   long enough.

.SEND:	jsr	r5,$SVST
	bit	r1,pctrcm(r0)	; waiting for this msg?
	beq	mesenq
	clr	pctrcm(r0)		; yes.
	mov	pctsp(r0),r5
	jsr	pc,setmes
	tst	(r0)+
	br	enqpct


mesenq:	mov	freemq,r5
	bne	.+4
	halt
	mov	(r5)+,freemq
	jsr	pc,setmes
	clr	-(r5)

	mov	#pctpmq,r4
	add	r0,r4

1$:	mov	@r4,r3
	beq	atend
	mov	r3,r4
	br	1$

atend:	mov	r5,@r4
	br	$IEXIT



setmes:	mov	.TOD,(r5)+
	mov	r3,(r5)+
	mov	r2,(r5)+
	mov	r1,(r5)+
	mov	$APCT,r3
	tst	-(r3)
	mov	r3,(r5)+
	mov	.TOD+2,(r5)+
	sub	#12.,r5
	rts	pc
	.page
	.sbttl	.RCV primitive -- temporary version


.RCV:	jsr	r5,$SVST
	mov	#pctpmq-2,r4
	add	$APCT,r4

rqn:	mov	@r4,r5
	beq	block
	bit	r1,8.(r5)
	beq	rqs
	tst	r0
	beq	rtrv
	cmp	r0,10.(r5)
	beq	rtrv
rqs:	mov	r5,r4
	br	rqn



rtrv:	mov	(r5)+,@r4
	mov	sp,r4
	mov	#6,r0
1$:	mov	(r5)+,(r4)+
	.loop	r0,1$

	sub	#14.,r5
	mov	freemq,@r5
	mov	r5,freemq
	br	$IEXIT


block:	mov	$APCT,r4
	mov	r1,pctrcm-2(r4)
	bis	#040000,@R4
	jmp	deqpct
	.sbttl	Free message block queue

.TOD:	0,0		; temp..

freemq:	.+2
	.rept	7
	.+16.
	.=.+14.
	.endr

	0
	.=.+14.
	.PAGE
	.SBTTL	TIMER PROCESSOR

TSMAX = 520.		;520 MSEC. MAX SETTING FOR HWR TIMER

TWAIT:	$WAIT			;TIMER PROCESSOR INACTIVE
$TIMER:	MOV	TSETL,R1	;GET LAST VALUE SET IN R1
	MOV	TQAH,R0		;GET ACTIVE QUEUE HEAD
	BEQ	TWAIT		;WAIT IF NO QUEUE ENTRIES
TLMOD:	SUB	R1,-2(R0)	;CORRECT ENTRIES BY TIME LAPSE
	BGT	TSVQ		;BRANCH IF ENTRY NOT EXPIRED
	$PUSH	R0,R1		;SAVE PARAM REGS
	$POST	-4(R0),#RDY+TIM	;POST HIM
	$POP	R1,R0		;RESTORE REGS
	MOV	(R0),TQAH	;DELETE FROM QUEUE
	MOV	TFQH,(R0)	;LINK TO FREE QUEUE HEAD
	MOV	R0,TFQH		;STICK HIS ADDRX ON FREE QUEUE
	MOV	TQAH,R0		;GET NEW VALUE
	BNE	TLMOD		;BRANCH IF MORE TO GO
	CLR	R0		;TURN OFF THE TIMER
	JSR	PC,$TSET	;BY SETTING IT TO 0
	BR	TWAIT		;AND WAIT FOR WORK...

TLMOD2:	SUB	R1,-2(R0)	;FIX REMAINING ENTRIES IN QUEUE
TSVQ:	MOV	(R0),R0		;BUMP QUEUE POINTER
	BNE	TLMOD2		;AND CORRECT THEIR TIME VALS

;				NOW SET VALUE OF TIME TO VALUE
;				AT HEAD OF QUEUE

	MOV	TQAH,R4		;ACTIVE QUEUE EL PTR
	MOV	-(R4),R0	;GET REQUEST SET VALUE
	CMP	R0,#TSMAX	;IS IT GREATER THAN MAXIMUM
	BLOS	STNTR		;NO, BY-PASS TRIM
	MOV	#TSMAX,R0	;YES, TRIM TO MAX ALLOWED.
STNTR:	MOV	R0,TSETL	;SAVE CURRENT SETTING VALUE
	JSR	PC,$TSET	;SET TIMER TO NR MSECS IN R0
	BR	TWAIT		;WAIT ON R.T. CLOCK


	.PAGE
	.SBTTL	SET PROCESS TIMER
			;  THIS PROCESSOR ROUTINE
			;
			;  RUNS AT PRIO 7
			; ASSUMES TIMER VAL IN R1
			; AND PCT ADDR IN R2, OR 0 IN R2


$STIME:	TST	R2		;SEE IF HAVE NULL ARGUMENT
	BNE	STNUL		;DONT LOAD $APCT
	MOV	$APCT,R2	;SETUP ADDRX OF PCT CONTROL BYTE
STNUL:	MOV	#TQAH,R3	;POINTER TO TQ ACTIVE WD
	MOV	(R3),R0		;FIRST ENTRY
	BEQ	STADD		;BRANCH IF NONE
STCMP:	CMP	R2,-4(R0)	;SAME PCT?
	BEQ	STREM		;YUP, REMOVE HIME FROM LIST
	MOV	R0,R3		;GET NEXT IN LIST...
	MOV	(R0),R0
	BNE	STCMP		;SERCH FOR SPECIFIED PCT
	TST	TFQH		;ANY IN FREE QUEUE?
	BEQ	STERR		;IF NOT, THROW UP OUR HANDS
STCON1:	$PUSH	R1		;SAVE REQUEST TIME SETTING
	JSR	PC,$TGET	;GET CURRENT TIME, IN MSECS.
	$PUSH	R0		;AND SAVE IT ON STACK
	CLR	R0		;THEN STOP TIMER
	JSR	PC,$TSET	;BY SETTING TO 0
	$POP	R3,R1		;PUT CURRENT TIME IN R3
	SUB	TSETL,R3	;SUBTRACT TO GET TIME GONE BY
	MOV	#TQAH,R0	;ACTIVE HEAD TO R0
	BR	STCH		;CORRECT EVERYBODY AS IF
STCOR:	ADD	R3,-2(R0)	;TIMER HAD EXPIRED.
STCH:	MOV	(R0),R0		;MOVE TO NEXT ENTRY
	BNE	STCOR		;LOOP THRU TBL
	TST	R1		;ONLY ALLOW POS TIME VAL
	BEQ	STNSET		;IF 0 , take him out of queue
	MOV	#TQAH,R0	;POINT TO BEGIN
	BR	STSTEP	;	ENTRY SEARCH
STSTP2:	CMP	R1,-2(R0)
	BLE	STADD		;BRAH IF NEW TIME L.E.
STSTEP:	MOV	R0,R3		;BUMP POINTER
	MOV	(R0),R0		; TO ENTRY
	BNE	STSTP2		;BRANCH IF NOT AT END
STADD:	MOV	TFQH,(R3)	;STICK NEW GUY IN QUEUE
	MOV	(R3),R3		;BUMP TO NEXT
	MOV	(R3),TFQH	;CHAIN FREE QUEUE
	MOV	R0,(R3)		;NEW LINK FROM CURRENT...
	MOV	R1,-(R3)	;STORE TIME VALUE
	MOV	R2,-(R3)	;STORE PCT ADDR
STNSET:	CLR	TSETL		;INDICATE TIMER CLEARED
	$POST	#$PCTIM+2,#RDY+TIM	;POST TIMER PROCESS
; (TIMER PROCESSOR WILL SET TIMER)
	BIC	#TIM,@$APCT	;CLEAR TIM BIT IN ACTIVE PCT
STPOST:	RTI		;RETURN FROM $STIME

STREM:	MOV	(R0),(R3)	;CHAIN AROUND HIM
	MOV	TFQH,(R0)	;LINK TO PREV HD OF Q
	MOV	R0,TFQH	;SETUP NEW HEAD
	BR	STCON1		;BACK TO SEARCH LIST

STERR:	TRAP	200		;TEMP *** ERROR CONDX
	.PAGE
	.SBTTL	$ATTCH  --  CREATE A NEW SYSTEM PROCESS

;			***  $ATTCH  ***

;			ASSUMES
;			(SP) CONTAINS ENTRY POINT OF NEW
;			  PROCESS
;			2(SP) CONTAINS ITS PRIORITY


$ATTCH:	JSR	R5,$SVST	;SAVE CALLERS STATUS
	MOV	REGTLY+3 * 2 (SP), R0	;SOFTWARE PRIORITY TO R0
	MOV	#$PRQ6+2,R1	;POINTER TO PRIORITY QUEUE LIS
ANCKF:	MOV	4(R1),R2	;GET HIS PRIO
	BEQ	ANF00	;WE'RE AT END OF LIST
	CMPB	R0,R2		;COMPARE PRIORITY
	BEQ	ANOKF	;THIS IS IT
	MOV	-(R1),R1	;BUMP TO NEXT IN CHAIN
	BR	ANCKF		;SEARCH FOR SPECIFIED PRIO
ANF00:	ADD	#REGTLY*2,SP	;BUMP STACK PTR PAST SVST WDS
	MOV	#2,R0		;SET ERROR CODE (UNDEF. PRIO)
	BR	ATRTI		;CLEAN STACK AND RETURN

ANOKF:	$PUSH	R1		;SAVE PTR TO PROCESS PRIO Q
	MOV	#PCPOOL,R0	;GET POOLID FOR PCT
	$ALOCB			;TRY TO GET A BUFFER
	BEQ	ATNBF	;CANT FIND A BUFFER
	MOV	#REGTLY,R3	;GET NR WDS TO COPY
	MOV	SP,R4		;SO WE CAN FORMAT NEW PCT
	TST	(R4)+		;SKIP OVER PQE POINTER
	MOV	R1,R2		;SAVE NEW PCT ADDR
	ADD	#PCTLEN-REGTLY-2*2,R2	;GET DEST BEGIN AREA
	MOV	R2,4(R1)	;INIT NEW PCT STACK POINTER
	clr	pctrcm(r1)	; Receive mask = 0
	clr	pctpmq(r1)	; Pending msg queue empty
	mov	#70707,pctflg(r1) ; set stack overflow detector
	MOV	REGTLY+3*2(SP),PCTLEN-2*2(R1)
;				WE JUST SETUP HIS ENTRY POINT
	CLR	PCTLEN-1*2(R1)	;CLEAR HIS CONTROL BYTE
AMSTAK:	MOV	(R4)+,(R2)+	;COPY CALLER'S STACK TO NEW PCT
	DEC	R3
	BGT	AMSTAK
	CLR	(R1)+		;NEXT PCT PTR
	CLR	(R1)+		;CLEAR HIS CONTROL BYTE
	TST	(R1)+		;SKIP OVER HIS STK PTR
	$POP	(R1)		;STICK PQE PTR IN PCT
	MOV	R1,R0		;SETUP FOR POST
	CMP	-(R0),-(R0)	;GET ADDR PCT CNTRL BYTE
	MOV	#40000,R1	;SETUP CMP CODE 
	TRAP	5		;TRAP TO POST ROUTINE
	ADD	#REGTLY*2,SP	;CLEAN STACK
	CLR	R0		;SET SUCCESSFUL COMPLETION
	BR	ATRTI		;AND RETURN

ATNBF:	ADD	#REGTLY+1*2,SP	;SKIP OVER REGS
	MOV	#4,R0		;CC 4 MEANS NO BUFFER SPC

ATRTI:	MOV	(SP)+,2(SP)	;SLIDE STACK
	MOV	(SP)+,2(SP)	;DOWN
	RTI			;AND RETURN

	.SBTTL	$DETCH -- KILL PROCESS
$DETCH:	RTI




$DUMMY:	WAIT		; ------- ACT IDLE -------  /ISI-PR/
	BR	$DUMMY	;			    /ISI-PR/
	.PAGE
	.SBTTL	TRAP -- SYSTEM TRAP PROCESSOR


;			********************
;			*   		   *
;			*  TRAP PROCESSOR  *
;			*   		   *
;			********************

TRAP:	MOV	R0,TR0SV	;SAVE REG 0
	MOV	(SP),R0		;GET ADDR OF TRAPPING INSTR
	MOV	-(R0),R0	;GET TRAP INSTR CAUSING TRAP
	BIC	#177400,R0		;MASK TO GET LOW BYTE
	CMP	R0,#TRMAX	;DONT ALLOW ILLEGAL TRAPS!
	BGE	TRE		;TRAP ERROR
	ASL	R0		;TRAP CODE TIMES 2
	MOV	TTBL(R0),-(SP)	;PUSH ADDR ONTO STACK
	MOV	TR0SV,R0	;RESTORE R0
	RTS	PC		;ENTRY TO TRAP ROUTINE @ PRIO 7

TR0SV:	.WORD	0


TTBL:	.WORD	$WAIT	; TRAP 0 -- WAIT
	.WORD	$STIME	; TRAP 1 -- SET TIMER
	.WORD	$ALOCB	; TRAP 2 -- ALLOC BUFFER
	.WORD	$FREEB	; TRAP 3 -- FREE BUFFER
	.WORD	$ERROR	; TRAP 4 -- ABNORMAL ERROR 
	.WORD	$POST	; TRAP 5 -- INDICATE PROCESS READY
	.WORD	$ATTCH	; TRAP 6 -- CREATE PROCESS
	.WORD	$DETCH	; TRAP 7 -- KILL PROCESS
	.WORD	$IOC	; TRAP 10 -- LINK TO I/O CONTROL
	.WORD	N.CON	; TRAP 11 -- CONNECT TO FGN SCK
	.WORD	N.LSN	; TRAP 12 -- LISTEN ON LCL SCK
	.WORD	N.CLS	; TRAP 13 -- CLOSE CONNECTION
	.WORD	N.SND	; TRAP 14 -- SEND DATA
	.WORD	N.RCV	; TRAP 15 -- RECEIVE DATA
	.WORD	N.CNT	; TRAP 16 -- RETURN BYTE COUNT
	.WORD	N.STA	; TRAP 17 -- RETURN STATUS 
	.word	.SEND	; Trap 20 -- Send
	.word	.RCV	; Trap 21 -- Receive

TRMAX = .-TTBL/2		;NUMBER OF TRAPS ALLOWED



$ERROR:
TRE:	HALT		;HALT PROCESSOR IF ERROR



N.CON:	JSR	PC,$N.CON	;ISSUE CONNECT
	RTI
N.LSN:	JSR	PC,$N.LSN	;ISSUE LISTEN
	RTI
N.CLS:	JSR	PC,$N.CLS
	RTI
N.SND:	JSR	PC,$N.SND
	RTI
N.RCV:	JSR	PC,$N.RCV
	RTI
N.CNT:	JSR	PC,$N.CNT
	RTI
N.STA:	RTI




;				*** SCRL ARPA CONTROL ***
;				*** PROGRAM           ***
;				***  INITIALIZE       ***

NETINI:	RESET		;INITIALIZE SYSTEM
	MOV	#157776,SP	; USE TOP OF ADDR SPACE FOR STACK
	MOV	#340,R1
	MOV	R1,@#PS	;RISE TO PRIORITY 7 NOW
	MOV	#TRAP,@#34	;INIT TRAP VECTOR
	MOV	R1,@#36		;AND ITS PRIORITY
	MOV	#ETRAP,@#4	;SETUP ERROR TRAP
	MOV	R1,@#6		;AND ITS PRIORITY
	MOV	#RTRAP,@#10	;RESERVED-INSTRUCTION TRP
	MOV	R1,@#12
	MOV	#IOTRAP,@#20	;IOT TRAP
	MOV	R1,@#22		;ITS PRIO

	jsr	pc,$clkin	; Initialize clock
	JSR	PC,$IMPIN	;INITIALIZE IMP
	JSR	PC,$TCI		;INIT TERMINAL CONTROLLER


	MOV	#100200,$PCTRI+2	;INIT RTP INPUT
	mov	#100200,$pctro+2	; init RTP output
	MOV	#100200,$PCTD+2		;INIT DUMMY PROCESS
	MOV	#100200,$WDPCT+2	;INIT WATCHDOG PROCESS
	JMP	WTI	;ENTER DISPATCHER
;			;ERROR TRAP ENTRY ADDRESSES

;			;TRAP TO SYSTEM DUMP ROUTINE

ETRAP:	JSR	R5,$DUMP	;ERROR TRAP
	.WORD	342		;CODE = 342

ETTRAP:	JSR	R5,$DUMP
	.WORD	346	;TRACE TRAP

RTRAP:	JSR	R5,$DUMP	;RESERVED-INSTRUCTION TRAP
	.WORD	344

IOTRAP:	JSR	R5,$DUMP
	.WORD	360		;IO TRAP


	.END	NETINI	;END SCRL NET, MODULE 1


    